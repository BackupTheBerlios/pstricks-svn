% \iffalse meta-comment
%
% pstricks2: PSTricks 2005
%
% Extract package files and create documentation:
%   `latex pstricks2.dtx'
%   `latex pstricks2.dtx'
%   `makeindex -s gglo.ist -o pstricks2.gls pstricks2.glo'
%   `makeindex -s gind.ist -o pstricks2.ind pstricks2.idx'
%   `latex pstricks2.dtx'
%   `latex pstricks2.dtx'
%
% To finish the installation you have to move the following
% files into a directory searched by (La)TeX and dvips:
%    pstricks2.tex
%    pstricks2.sty
%    pstricks2.pro
%
%% ------------------------------------------------------------------
%% Copyright (C) 1993, 1994, 1999 by Timothy Van Zandt, <tvz@nwu.edu>
%% Copyright (C) 2004 by Herbert Voss, <voss _at_ PSTricks.de>
%% ------------------------------------------------------------------
%%
%% This file may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.2
%% of this license or (at your option) any later version.
%% The latest version of this license is in:
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \fi
%
% \iffalse
%<*batchfile>
\begingroup
\input docstrip.tex
% Let the macro ¡ gobble up the argument when stripping.
\catcode`\¡=\active
\def¡#1;{}
\keepsilent
\preamble
\endpreamble
\askforoverwritefalse
\generate{%
  \file{pstricks2.tex}{\from{pstricks2.dtx}{tex}}
  \file{pstricks2.sty}{\from{pstricks2.dtx}{latex}}
}
\edef\postamblePSTHeader{%
  \MetaPrefix ^^J%
  \MetaPrefix\space End of file `\outFileName'.%
  }
\usepostamble\postamblePSTHeader
\generate{%
  \file{pstricks2.pro}{\from{pstricks2.dtx}{dvips}}
}
\endgroup
%</batchfile>
%<*driver>
\documentclass{ltxdoc}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{pstricks2}
\geometry{a4paper,margin=1cm,includemp,includeheadfoot,marginpar=2.5cm}
\lstnewenvironment{command}{%
  \lstset{columns=flexible,frame=single,backgroundcolor=\color{yellow},%
    xleftmargin=\fboxsep,xrightmargin=\fboxsep,escapeinside=`',gobble=1}}{}
\lstnewenvironment{example}{%
  \lstset{basicstyle=\footnotesize\ttfamily,columns=flexible,frame=single,%
    backgroundcolor=\color{yellow!20},xleftmargin=\fboxsep,%
    xrightmargin=\fboxsep,gobble=1}}{}
\makeatletter
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}
\renewcommand\theparagraph    {\thesubsubsection.\@alph\c@paragraph}
\renewcommand\thesubparagraph {\theparagraph.\@roman\c@subparagraph}
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
                                     {-3.25ex\@plus -1ex \@minus -.2ex}%
                                     {1.5ex \@plus .2ex}%
                                    {\normalfont\normalsize\bfseries\slshape}}
\renewcommand\subparagraph{\@startsection{subparagraph}{5}{\parindent}%
                                      {-3.25ex\@plus -1ex \@minus -.2ex}%
                                     {1.5ex \@plus .2ex}%
                                      {\normalfont\normalsize\itshape}}
\def\changes@#1#2#3{%
  \protected@edef\@tempa{%
    \noexpand\glossary{\textbf{#1}\hfill\emph{(#2)}%
      \levelchar
      \ifx\saved@macroname\@empty
        \space\actualchar\generalname
      \else
        \expandafter\@gobble\saved@macroname
        \actualchar\string\verb\quotechar*%
        \verbatimchar\saved@macroname\verbatimchar
      \fi
      :\levelchar #3}%
    }%
  \@tempa\endgroup\@esphack
}
% Let the macro ¡ make a label at the current code line.
% This macro can be used in a macrocode environment as
% code¡label:1;
% Referring happens in the ordinary way: \ref{label:1}.
\catcode`\¡=\active
\def¡#1;{%
  \protected@edef\@currentlabel{\number\c@CodelineNo}%
  \label{#1}%
}

\newbox\bombbox
\setbox\bombbox=\hbox to\z@{%
  \hss
  \rput[r](-1.5cm,0){%
    \psset{unit=7pt}
    \begin{pspicture}(-4,-4)(4,4)
      \pscircle[fillcolor=gray,fillstyle=solid]{4}
      \rput{45}{\psscaleboxto(6,0){PS\kern-1pt}}
      \psellipse*(0,3.8)(1,.2)
      \psellipse*(0,5.5)(1,.2)
      \psframe*(-1,3.8)(1,5.5)
      \psbezier(0,5.5)(0,7)(1,8)(3.5,8)
      \multido{\r=-0+40}{9}{\rput{\r}(3.5,8){\psline(0,0)(.4,0)}}
    \end{pspicture}}}

\def\Warning{%
  \trivlist\item[]
  \leavevmode\kern\@totalleftmargin
  \valign\bgroup%
    \vfil##\vfil\cr
    \copy\bombbox\cr
    \minipage{\textwidth}
    \quote
    \em Warning:\hskip 1em
    \ignorespaces}
\def\endWarning{\endquote\endminipage\cr\egroup\endtrivlist}

\newbox\filebox
\setbox\filebox=\hbox{%
  \pspicture(-1,-.5)(1,.7)
  \pspolygon[linearc=2pt,shadow=true,shadowangle=45,xunit=1.1]%
    (-1,-.55)(-1,.5)(-.8,.5)(-.8,.65)(-.2,.65)(-.2,.5)(1,.5)(1,-.55)
   \endpspicture}
\def\File#1{%
  \leavevmode
  \marginpar{%
    \leavevmode\lower 20pt\hbox{%
      \hbox to0pt{\hbox to \linewidth{\hss\copy\filebox\hss}\hss}%
      \raise 10pt\hbox to \linewidth{\hss\large\bf\sf #1\hss}}}%
   \ignorespaces}

\def\PSTAuthors{%
  \shortstack{Timothy \textsc{Van Zandt} (original author)\\
    Christophe \textsc{Jorssen}\\
    Herbert \textsc{Voss}}}

\makeatother

\def\PrintChangesX{%
  \begingroup
  \let\efill\relax
  \setlength{\columnsep}{18pt}%
  \setlength{\columnseprule}{.4pt}%
  \PrintChanges
  \endgroup
}
\def\larg#1{{\ttfamily\char`\<}\meta{#1}{\ttfamily\char`\>}}
\def\pf#1{\textsf{#1}}
\def\bs{\symbol{'134}}
\def\ci#1{\texttt{\bs#1}}
\EnableCrossrefs
\RecordChanges
\GlossaryPrologue{\section*{Version history}\addcontentsline{toc}{section}{Version history}}
\CodelineIndex
\begin{document}
\DocInput{pstricks2.dtx}
\end{document}
%</driver>
% \fi
%
% \changes{v2.0}{2004/04/29}{Initial release of PSTricks 2005}
%
% \GetFileInfo{pstricks2.sty}
%
%
% \DoNotIndex{\@empty,\csname,\def,\do,\edef,\else,\endcsname}
% \DoNotIndex{\expandafter,\fi,\futurelet,\ifnum,\ifx,\let,\long}
% \DoNotIndex{\newif,\newtoks,\noexpand,\relax,\space,\string,\the}
% \DoNotIndex{\xdef,\@nil,\@nnil}
% \DoNotIndex{\@undefined,\begingroup,\bgroup}
% \DoNotIndex{\catcode,\endgroup,\gdef,\global,\if,\input,\lowercase}
% \DoNotIndex{\@gobble,\@ifnextchar}
% \DoNotIndex{\@ifundefined}
% \DoNotIndex{\@namedef\@nameuse,\afterassignment}
% \DoNotIndex{\lowercase,\meaning}
% \DoNotIndex{\message,\errmessage,\NeedsTeXFormat,\PackageError}
% \DoNotIndex{\PackageWarning,\protect,\ProvidesFile,\ProvidesPackage}
% \DoNotIndex{\iffalse,\iftrue,\escapechar}
% \DoNotIndex{\m@ne,\z@,\@ne,\tw@}
% \DoNotIndex{\endinput}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \begin{titlepage}
%
% \setcounter{page}{0}
% \centering
%   {\Huge\bfseries PSTricks 2005}
%
%   \vspace*{2cm}
%
%   {\large\bfseries PostScript macros for Generic \TeX.}
%
%   \vspace*{2cm}
%
%   \begingroup
%   \psset{unit=.4cm}
%   \begin{pspicture}(0,-2)(31,12)
%     \rput(1.5,0){%
%       \psellipse[linewidth=1pt](8,7)(1,3)
%       \psframe[linecolor=white,fillstyle=solid,fillcolor=white]
%         (6.4,6.5)(8,7.5)
%       \psline[linearc=.3,linewidth=1pt](8,8)(8,7.5)(4,7.5)
%       \psbezier[linewidth=1pt](4,7.5)(3,7.5)(3,6.5)(3,5.5)
%       \psline[linearc=.3,linewidth=1pt](8,6)(8,6.5)(5,6.5)
%       \psbezier[linewidth=1pt](5,6.5)(4,6.5)(4,6.5)(4,5.5)
%       \psline[linewidth=1pt](3,5.5)(4,5.5)
%       \psline[linearc=.3,linewidth=1pt](5,7.5)(5,8)(6,8)(6,7.5)
%       \psframe[linewidth=1pt](5.3,8)(5.7,8.7)
%       \psframe[linewidth=1pt,framearc=1,fillstyle=solid,
%         fillcolor=white](4,8.7)(7,9)
%       \multirput(3.5,4.8)(0,-1){4}{%
%         \psbezier[linewidth=.5pt](0,0)(.25,-.4)(-.25,-.4)(0,0)}
%       \rput[t](5.5,0){Dripping Faucet}}
%     \rput(20,5){%
%       \pspolygon[linecolor=white,fillstyle=vlines,
%         fillcolor=darkgray,hatchsep=.2](1,4.5)(1,4)(4,4)(4,4.5)
%       \psline[linewidth=2pt](1,4)(4,4)
%       \psline[linewidth=1.5pt](2.5,4)(2.5,3.5)(2.9,3.3)(2.1,2.9)
%         (2.9,2.5)(2.1,2.1)(2.9,1.7)(2.1,1.3)(2.5,1.1)(2.5,0.6)
%       \psframe[linecolor=black,linewidth=1.5pt,fillstyle=solid,
%         fillcolor=lightgray](1.8,-1)(3.2,.6)
%       \rput(2.5,-.2){$M$}
%       \psline{<->}(3.7,-.9)(3.7,.5)
%       \psframe[linecolor=black,linewidth=1.5pt,fillstyle=solid,
%         fillcolor=lightgray](1.8,-3.5)(3.2,-1.9)
%       \rput(2.5,-2.7){$m$}
%       \psline{->}(5,1)(5,-1)
%       \rput[l](5.5,0){$g$}
%       \psline{->}(3.7,-2)(3.7,-3.4)
%       \rput[t](2.5,-4){Mathematical Model for}
%       \rput[t](2.5,-5){a Dripping Faucet}
%       \rput(-6,-2){%
%         \psset{linewidth=2pt}
%         \psline(0,.5)(2,.5)
%         \psline(0,-.5)(2,-.5)
%         \psline(1.5,1)(2.5,0)(1.5,-1)}}
%     \psframe[linewidth=2pt,framearc=.05,linecolor=gray](0,-2.5)(31,12)
%     \uput[l]{90}(0,4.75){\tt{leecheng}}
%   \end{pspicture}
%   \endgroup
%
%   \vspace*{2cm}
%
% {\LARGE\bf User's Guide}
%
%   \vspace*{2cm}
%
% {\large\PSTAuthors}
% \end{titlepage}
%
%
%\title{The \pf{pstricks2} package}
%\author{\PSTAuthors}
%\date{\fileversion\ (\filedate)
%\thanks{This package can be downloaded from the CTAN mirrors:
%\texttt{/macros/generic/pstricks2/}. See \texttt{pstricks2.dtx} or the
%\TeX\ Frequently Asked Questions \cite{TeXFAQInst} for information
%on installing \pf{pstricks2} into your \TeX\ or \LaTeX\ distribution.}}
%\maketitle
%
%\tableofcontents
%
% \section{Welcome to PSTricks}
%
% PSTricks is a collection of PostScript-based \TeX{} macros that is compatible
% with most \TeX\ macro packages, including Plain \TeX, \LaTeX, \AmSTeX, and
% \AmS-\LaTeX. PSTricks gives you color, graphics, rotation, trees and overlays.
% PSTricks puts the icing (PostScript) on your cake (\TeX)!
%
% To install PSTricks, follow the instructions in the file "read-me.pst" that
% comes with the PSTricks package. Even if PSTricks has already been installed
% for you, give "read-me.pst" a look over.
%
% This \emph{User's Guide} verges on being a reference manual, meaning that it is
% not designed to be read linearly. Here is a recommended strategy: finish
% reading this brief overview of the features in PSTricks. Then thumb through
% the entire \emph{User's Guide} to get your own overview. Return to section
% \ref{sec:essentials} (Essentials) and read it carefully. Refer to the remaining
% sections as the need arises.
%
% When you cannot figure out how to do something or when trouble arises, check
% out the appendices (Help). You just might be lucky enough to find a solution.
% There is also a \LaTeX{} file "samples.pst" of samples that is distributed with
% PSTricks. Look to this file for further inspiration.
%
% This documentation is written with \LaTeX. Some examples use \LaTeX{} specific
% constructs and some don't. However, there is nothing \LaTeX{} specific about
% any of the macros, nor is there anything that does not work with \LaTeX. This
% package has been tested with Plain \TeX, \LaTeX, \AmS-\LaTeX{} and \AmSTeX, and
% should work with other \TeX{} macro packages as well.
%
%\File{pstricks}
% The main macro file is "pstricks.tex"/"pstricks.sty". Each of the PSTricks
% macro files comes with a ".tex" extension and a ".sty" extension; these are
% equivalent, but the ".sty" extension means that you can include the file name
% as a \LaTeX{} package.
%
% There are numerous supplementary macro files. A file, like the one above and
% the left, is used in this \emph{User's Guide} to remind you that you must input
% a file before using the macros it contains.
%
% For most PSTricks macros, even if you misuse them, you will not get PostScript
% errors in the output. However, it is recommended that you resolve any \TeX{}
% errors before attempting to print your document. A few PSTricks macros pass on
% PostScript errors without warning. Use these with care, especially if you are
% using a networked printer, because PostScript errors can cause a printer to
% bomb. Such macros are pointed out in strong terms, using a warning like this
% one:
%
% \begin{Warning}
% Use macros that do not check for PostScript errors with care. PostScript
% errors can cause a printer to bomb!
% \end{Warning}
%
% Keep in mind the following typographical conventions in this User's Guide.
% \begin{itemize}
% \item All literal input characters, \emph{i.e.}, those that should appear verbatim in
% your input file, appear in \texttt{teletype} font.
% \item Meta arguments, for which you are supposed to substitute a value (\emph{e.g.},
% \meta{angle}) appear in \textsl{slanted} font inside brackets.
% \item The main entry for a macro or parameter that states its syntax appears
% in a large bold font, \emph{except for the optional arguments, which are in
% medium weight}. This is how you can recognize the optional arguments.
% \item References to PSTricks commands and parameters within paragraphs are set
% in { Helvetica-Bold}.
% \end{itemize}
%
%\begin{command}
% `\ci{fileplot*}\oarg{parameters}\marg{file}'
%\end{command}
%
%
%\StopEventually{
%
%\begin{thebibliography}{1}
%\addcontentsline{toc}{section}{References}
%\bibitem{pst-xkey}
%Hendri Adriaens.
%\newblock \pf{pst-xkey} package.
%\newblock \url{http://www.ctan.org/tex-archive/macros/generic/xkeyval}.
%\end{thebibliography}
%
%\section*{Acknowledgements}
%\addcontentsline{toc}{section}{Acknowledgements}
%Manuel Luque, Dominique Rodriguez, Jean-C\^ome Charpentier, Denis Girou,
%Sebastian Rahtz, Jacques L'helgoualc'h and all contributors to the pstricks mailing
%list.
%
%\PrintChangesX
%\addcontentsline{toc}{section}{Index}%
%\PrintIndex
%}
%
% \section{Implementation}\label{sec:imple}
% \subsection{\TeX\ program}
% \subsubsection{Former pstricks.tex (adapted)}
% Check whether file has been loaded already.
%    \begin{macrocode}
%<*tex>
\csname PSTricksLoaded\endcsname
\let\PSTricksLoaded\endinput
\ifx\PSTXKeyLoaded\endinput\else\input pst-xkey \fi
%
\def\fileversion{2.00}
\def\filedate{2004/11/23}
\message{ v\fileversion, \filedate}
\message{`pstricks2' v\fileversion, \filedate\space (tvz,hv)}
%
%    \end{macrocode}
% Take care of the catcode of @.
%    \begin{macrocode}
\edef\PstAtCode{\the\catcode`\@}
\catcode`\@=11\relax
%\pst@addfams{pstricks}
%
%    \end{macrocode}
% Here are some hacks borrowed from \LaTeX{}, which are defined
% if \LaTeX{} is not being used.
%    \begin{macrocode}
\expandafter\ifx\csname @latexerr\endcsname\relax
  \long\def\@ifundefined#1#2#3{\expandafter\ifx\csname
    #1\endcsname\relax#2\else#3\fi}
  \def\@namedef#1{\expandafter\def\csname #1\endcsname}
  \def\@nameuse#1{\csname #1\endcsname}
  \def\@eha{%
    Your command was ignored.^^J
    Type \space I <command> <return> \space to replace
    it with another command,^^J
    or \space <return> \space to continue without it.}
  \def\@spaces{\space\space\space\space}
  \def\typeout#1{\immediate\write\@unused{#1}}
  \alloc@7\write\chardef\sixt@@n\@unused
  \def\@empty{}
  \def\@gobble#1{}
  \def\@nnil{\@nil}
  \def\@ifnextchar#1#2#3{%
    \let\@tempe#1\def\@tempa{#2}\def\@tempb{#3}\futurelet\@tempc\@ifnch}
  \def\@ifnch{%
    \ifx\@tempc\@sptoken
      \let\@tempd\@xifnch
    \else
      \ifx\@tempc\@tempe \let\@tempd\@tempa \else \let\@tempd\@tempb \fi
    \fi
    \@tempd}
  \begingroup
    \def\:{\global\let\@sptoken= } \:
    \def\:{\@xifnch} \expandafter\gdef\: {\futurelet\@tempc\@ifnch}
  \endgroup
\fi
%    \end{macrocode}
% Announce that the file is being loaded.
%    \begin{macrocode}
\typeout{`PSTricks' v\fileversion\space\space <\filedate> (tvz)}
%    \end{macrocode}
% \paragraph{Error messages}
% \begin{macro}{\@pstrickserr}
% |\@pstrickserr| is analogous to |\@latexerr|.
%    \begin{macrocode}
\def\@pstrickserr#1#2{%
  \begingroup
  \newlinechar`\^^J
  \edef\pst@tempc{#2}%
  \expandafter\errhelp\expandafter{\pst@tempc}%
  \typeout{%
    PSTricks error. \space See User's Guide for further information.^^J
    \@spaces\@spaces\@spaces\@spaces
    Type \space H <return> \space for immediate help.}%
  \errmessage{#1}%
  \endgroup}
%    \end{macrocode}
% \end{macro}
% Here are some extra |\errhelp| message.
% \begin{macro}{\@ehpa}
%    \begin{macrocode}
\def\@ehpa{%
  Your command was ignored. Default value substituted.^^J
  Type \space <return> \space to procede.}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@ehpb}
%    \begin{macrocode}
\def\@ehpb{%
  Your command was ignored. Will recover best I can.^^J
  Type \space <return> \space to procede.}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@ehpc}
%    \begin{macrocode}
\def\@ehpc{%
  You better fix this before proceding.^^J
  See the PSTricks User's Guide or ask your system administrator for help.^^J
  Type \space X <return> \space to quit.}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@misplaced}
%    \begin{macrocode}
\def\pst@misplaced#1{\@pstrickserr{Misplaced \string#1 command}\@ehpb}
%    \end{macrocode}
% \end{macro}
% \paragraph{Scratch registers}
% There are various classes of scratch registers.
% \subparagraph{Global}
% These can be changed using |\global|, etc.
%    \begin{macrocode}
\def\pst@tempg{}
\def\pst@temph{}
\newdimen\pst@dimg
\newdimen\pst@dimh
\newcount\pst@cntg
\newcount\pst@cnth
\newbox\pst@boxg
%    \end{macrocode}
% \subparagraph{Local Ia}
% These cannot be changed with |\global|, but otherwise there
% are no restrictions.
%    \begin{macrocode}
\def\next{}
\def\@tempa{}
%    \end{macrocode}
% \subparagraph{Local Ib}
% Changes to these must be local to the macro in which they occur (be
% grouping).
%    \begin{macrocode}
\def\pst@tempa{}
\def\pst@tempb{}
\def\pst@tempc{}
\def\pst@tempd{}
%    \end{macrocode}
% \subparagraph{Local II}
% Changes to these must be local to the macro in which they
% occur, and it must be possible to use these as arguments of macros. There is one
% exception. When using these in coordinates that are processed directly
% as Cartesian coordinates rather than with |\pst@getcoor|, they must
% be used in this order: |(\pst@dima,\pst@dimb)(\pst@dimc,\pst@dimd)|.
%    \begin{macrocode}
\newdimen\pst@dima
\newdimen\pst@dimb
\newdimen\pst@dimc
\newdimen\pst@dimd
\newif\if@pst
%    \end{macrocode}
% \subparagraph{Shared}
% These are used to share information between macros. Their
% value may be set by one macro and then used by another. Use with care. Do
% not set with |\global|.
% \begin{macro}{\pst@hbox}
% Box created and manipulated in HR-box macros.
%    \begin{macrocode}
\newbox\pst@hbox
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@coor}
% Stores the PostScript code for a coordinate.
%    \begin{macrocode}
\def\pst@coor{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@angle}
% Stores the PostScript code for an angle.
%    \begin{macrocode}
\def\pst@angle{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@rot}
% Stores the PostScript code for a rotation angle.
%    \begin{macrocode}
\def\pst@rot{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\if@star}
% This is a flag to keep track of optional |*|.
%    \begin{macrocode}
\newif\if@star
%    \end{macrocode}
% \end{macro}
% \subparagraph{Unidentified type yet...}
%    \begin{macrocode}
\newdimen\pst@dimm% hv
\newdimen\pst@dimn% hv
\newdimen\pst@dimo% hv
\newdimen\pst@dimp% hv
\newcount\pst@cnta
\newcount\pst@cntb
\newcount\pst@cntc
\newcount\pst@cntd
\newcount\pst@cntm% hv
\newcount\pst@cntn% hv
\newcount\pst@cnto% hv
\newcount\pst@cntp% hv
\newtoks\pst@toks
%    \end{macrocode}
% \paragraph{Useful hacks}
% \begin{macro}{\pst@ifstar}
%    \begin{macrocode}
\def\pst@ifstar#1{%
  \@ifnextchar*{\@startrue\def\next*{#1}\next}{\@starfalse#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@expandafter}
%    \begin{macrocode}
\def\pst@expandafter#1#2{%
  \def\next{#1}%
  \edef\@tempa{#2}%
  \ifx\@tempa\@empty
    \@pstrickserr{Unexpected empty argument!}\@ehpb
    \def\@tempa{\@empty}%
  \fi
  \expandafter\next\@tempa}
%    \end{macrocode}
% \end{macro}
% \paragraph{Arithmetic}
% \begin{macro}{\pst@dimtonum}
% This macro strips the value of |#1|, a dimension register, of the |pt|, and
% assigns the result to |#2|, a command sequence. This is used for arithmetic
% and for converting \TeX{} dimensions to PostScript.
%    \begin{macrocode}
\def\pst@dimtonum#1#2{\edef#2{\pst@@dimtonum#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@dimtonum}
%    \begin{macrocode}
\def\pst@@dimtonum#1{\expandafter\pst@@@dimtonum\the#1}
{\catcode`\p=12 \catcode`\t=12 \global\@namedef{pst@@@dimtonum}#1pt{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@pyth}
% This is a piecewise-linear approximation to $\sqrt{\mathtt{\#1}^2+\mathtt{\#2}^2}$. The
% answer is assigned to |#3|. All arguments should be dimension registers.
%    \begin{macrocode}
\def\pst@pyth#1#2#3{%
  \ifdim#1>#2\pst@@pyth#1#2#3\else\pst@@pyth#2#1#3\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@pyth}
%    \begin{macrocode}
\def\pst@@pyth#1#2#3{%
  \ifdim4#1>9#2%
  #3=#1\advance#3 .2122#2%
  \else
  #3=.8384#1\advance#3 .5758#2%
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@divide}
% This computes |#1|/|#2| reasonably quickly and stores it in |#3|. |#1| and |#2| should be
% dimensions, and |#3| should be a command sequence.
%    \begin{macrocode}
\def\pst@divide#1#2#3{%
  \pst@@divide{#1}{#2}%
  \pst@dimtonum\pst@dimg{#3}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@divide}
%    \begin{macrocode}
\def\pst@@divide#1#2{%
  \pst@dimg=#1\relax
  \pst@dimh=#2\relax
  \pst@cntg=\pst@dimh
  \pst@cnth=67108863
  \pst@@@divide\pst@@@divide\pst@@@divide\pst@@@divide
  \divide\pst@dimg\pst@cntg}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@@divide}
%    \begin{macrocode}
\def\pst@@@divide{%
  \ifnum
    \ifnum\pst@dimg<\z@-\fi\pst@dimg<\pst@cnth
    \multiply\pst@dimg\sixt@@n
  \else
    \divide\pst@cntg\sixt@@n
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getdimdim}
%    \begin{macrocode}
\def\pst@getdimdim#1 #2 #3\@nil{% hv
  \pssetlength\pst@dimm{#1}%
  \ifx#2\pst@missing\relax%
    \pst@dimn=\pst@dimm\pst@dimm=-\pst@dimn%
  \else%
    \pssetlength\pst@dimn{#2}%
  \fi%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getxdimdim}
%    \begin{macrocode}
\def\pst@getxdimdim#1 #2 #3\@nil{% hv
  \pssetxlength\pst@dimm{#1}%
  \ifx#2\pst@missing\relax%
    \pst@dimn=\pst@dimm\pst@dimm=-\pst@dimn%
  \else%
    \pssetxlength\pst@dimn{#2}%
  \fi%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getydimdim}
%    \begin{macrocode}
\def\pst@getydimdim#1 #2 #3\@nil{%  hv
  \pssetylength\pst@dimm{#1}%
  \ifx#2\pst@missing\relax%
    \pst@dimn=\pst@dimm\pst@dimm=-\pst@dimn%
  \else%
    \pssetylength\pst@dimn{#2}%
  \fi%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@mod}
% A modulo macro for integer values
% |\pst@mod{34}{6}\value| ==> |\value| is 4
%    \begin{macrocode}
\def\pst@mod#1#2#3{%  hv
  \begingroup%
  \pst@cntm=#1\pst@cntn=#2\relax%
  \pst@cnto=\pst@cntm%
  \divide\pst@cntm by \pst@cntn%
  \multiply\pst@cntn by \pst@cntm%
  \advance\pst@cnto by -\pst@cntn%
  \edef\value{\endgroup\def\noexpand#3{\number\pst@cnto}}\value%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@max}
%    \begin{macrocode}
\def\pst@max#1#2#3{% hv
  \begingroup%
  \pst@cntm=#1\pst@cntn=#2\relax%
  \ifnum\pst@cntm<\pst@cntn\pst@cntm=\pst@cntn\fi
  \global#3=\the\pst@cntm%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@maxdim}
%    \begin{macrocode}
\def\pst@maxdim#1#2#3{% hv
  \begingroup%
  \pst@dimm=#1\pst@dimn=#2\relax%
  \ifdim\pst@dimm<\pst@dimn\pst@dimm=\pst@dimn\fi
  \global#3=\the\pst@dimm%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@abs}
%    \begin{macrocode}
\def\pst@abs#1#2{% hv
  \begingroup%
  \pst@cntm=#1\relax%
  \ifnum\pst@cntm<\z@\pst@cntm=-\pst@cntm\fi%
  \global#2=\the\pst@cntm
  \endgroup%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@absdim}
%    \begin{macrocode}
\def\pst@absdim#1#2{% hv
  \begingroup%
  \pst@dimm=#1\relax%
  \ifdim\pst@dimm<\z@\pst@dimm=-\pst@dimm\fi%
  \global#2=\the\pst@dimm%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}
% \paragraph{Configuration file}
% \begin{macro}{\pst@configerr}
%    \begin{macrocode}
\def\pst@configerr#1{%
  \@pstrickserr{\string#1 not defined in pstricks.con}\@ehpc}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstVerb}
%    \begin{macrocode}
\def\pstVerb#1{\pst@configerr\pstVerb}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstverb}
%    \begin{macrocode}
\def\pstverb#1{\pst@configerr\pstverb}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstverbscale}
%    \begin{macrocode}
\def\pstverbscale{\pst@configerr\pstverbscale}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstrotate}
%    \begin{macrocode}
\def\pstrotate{\pst@configerr\pstrotate}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstheader}
%    \begin{macrocode}
\def\pstheader#1{\pst@configerr\pstheader}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstdriver}
%    \begin{macrocode}
\def\pstdriver{\pst@configerr\pstdriver}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\@ifundefined{pstcustomize}{%
  \def\pstcustomize{\endinput\let\pstcustomize\relax}}{}
\input pstricks.con
%    \end{macrocode}
% \begin{macro}{\ifPSTricks}
%    \begin{macrocode}
\newif\ifPSTricks
\PSTrickstrue
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\PSTricksOff}
%    \begin{macrocode}
\def\PSTricksOff{%
  \def\pstheader##1{}%
  \def\pstverb##1{}%
  \def\pstVerb##1{}%
  \PSTricksfalse}
%    \end{macrocode}
% \end{macro}
% \paragraph{PostScript header}
%    \begin{macrocode}
\pstheader{pstricks2.pro}
%
\@ifundefined{pst@def}{\def\pst@def#1<#2>{\@namedef{tx@#1}{#2 }}}{}
\@ifundefined{pst@ATH}{\def\pst@ATH<#1>{}}{}
\def\pst@dict{tx@Dict begin }
\def\pst@theheaders{pstricks.pro}
\def\pst@Verb#1{\pstVerb{\pst@dict #1 end}}
\def\tx@Atan{Atan }
\def\tx@Div{Div }
\def\tx@NET{NET }
\def\tx@Pyth{Pyth }
\def\tx@PtoC{PtoC }
\def\tx@PathLength@{PathLength@ }
\def\tx@PathLength{PathLength }
\pst@dimg=\pstunit\relax
\ifdim\pst@dimg=1bp
\def\pst@stp{.996264 dup scale}
\else
\edef\pst@stp{1 \pst@@dimtonum\pst@dimg\space div dup scale}
\fi
\def\tx@STP{STP }
\def\tx@STV{STV }
\def\pst@number#1{\pst@@dimtonum#1\space}
%    \end{macrocode}
% \begin{macro}{\pst@checknum}
% The first argument of |\pst@checknum| should be a number, and the second
% argument is a command. There are three possible outcomes:
% \begin{enumerate}
%   \item The number is suitable for PostScript consumption, the command is set
%   to the number, and |\pst@num| is set to |1| if the number is positive and to
%   |2| if the number is negative.
%   \item |\pst@checknum| detects that the number is not suitable for
%   PostScript; |\pst@num| is set to |0|, an error is given, and the command is
%   defined to be |0|.
%   \item The number is not suitable for PostScript consumption, but
%   |\pst@checknum| does not detect this. |\pst@num| is set to |1| or |2|, and
%   the command is set to some number that \emph{is} suitable for PostScript.
% \end{enumerate}
%
% A trailing space is always added.
%
% |\pst@checknum| should generate no extraneous errors nor output, even if the
% first argument is a bad number.
%
% This macro is probably pretty close to optimal for what it does, as many
% variations have been tried.
%    \begin{macrocode}
\def\pst@checknum#1#2{%
  \edef\next{#1}%
  \ifx\next\@empty
    \let\pst@num\z@
  \else
    \expandafter\pst@@checknum\next..\@nil
  \fi
  \ifnum\pst@num=\z@
    \@pstrickserr{Bad number: `#1'. 0 substituted.}\@ehpa
    \def#2{0 }%
  \else
    \edef#2{\ifnum\pst@num=\tw@-\fi\the\pst@cntg.%
    \expandafter\@gobble\the\pst@cnth\space}%
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@checknum}
%    \begin{macrocode}
\def\pst@@checknum{%
  \@ifnextchar-%
  {\let\pst@num\tw@\expandafter\pst@@@checknum\@gobble}%
  {\let\pst@num\@ne\pst@@@checknum}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@@checknum}
%    \begin{macrocode}
\def\pst@@@checknum#1.#2.#3\@nil{%
  \afterassignment\pst@@@@checknum\pst@cntg=0#1\relax\@nil
  \afterassignment\pst@@@@checknum\pst@cnth=1#2\relax\@nil}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@@@checknum}
%    \begin{macrocode}
\def\pst@@@@checknum#1\relax\@nil{%
  \ifx\@nil#1\@nil\else\let\pst@num\z@\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getnumii}
% These are for processing comma-separated lists of numbers. They assign the
% numbers to |\pst@tempg|, |\pst@temph|, etc. Use like
% |\pst@expandafter\pst@getnumiii{foo}{}{}{}{}\@nil|
%
% If there are too few numbers, an error results. If there are too many, the
% extra numbers are ignored.
%    \begin{macrocode}
\def\pst@getnumii#1 #2 #3\@nil{%
  \pst@checknum{#1}\pst@tempg
  \pst@checknum{#2}\pst@temph}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getnumiii}
%    \begin{macrocode}
\def\pst@getnumiii#1 #2 #3 #4\@nil{%
  \pst@checknum{#1}\pst@tempg
  \pst@checknum{#2}\pst@temph
  \pst@checknum{#3}\pst@tempi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getnumiv}
%    \begin{macrocode}
\def\pst@getnumiv#1 #2 #3 #4 #5\@nil{%
\pst@checknum{#1}\pst@tempg
\pst@checknum{#2}\pst@temph
\pst@checknum{#3}\pst@tempi
\pst@checknum{#4}\pst@tempj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getdimnum}
% Like |\pst@getnumii|, but first item is a dimension and second is a number.
%    \begin{macrocode}
\def\pst@getdimnum#1 #2 #3\@nil{%
  \pssetlength\pst@dimg{#1}%
  \pst@checknum{#2}\pst@tempg}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getscale}
% |\pst@getscale| can have one or two numbers in its first argument.
%    \begin{macrocode}
\def\pst@getscale#1#2{%
  \edef\pst@tempg{#1}%
  \ifx\pst@tempg\@none
    \def#2{}%
  \else
    \pst@expandafter\pst@getnumii{#1 #1} {} {} {}\@nil
    \ifdim\pst@tempg\p@=\z@
      \@pstrickserr{Bad scaling argument `#1'}\@ehpa
      \def#2{}%
    \else
      \ifdim\pst@temph\p@=\z@
        \@pstrickserr{Bad scaling argument `#1'}\@ehpa
        \def#2{}%
      \else
        \edef#2{\pst@tempg\space \pst@temph\space scale }%
      \fi
    \fi
  \fi%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@getint}
%    \begin{macrocode}
\def\pst@getint#1#2{%
  \pst@cntg=#1\relax
  \edef#2{\the\pst@cntg\space}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pslbrace}
% \begin{macro}{\psrbrace}
% When balanced braces are used, they work without problems in |\special|'s.
% |\pslbrace| and |\psrbrace| let you use unbalanced braces.
%    \begin{macrocode}
\begingroup
  \catcode`\{=12
  \catcode`\}=12
  \catcode`\[=1
  \catcode`\]=2
  \gdef\pslbrace[{ ]
  \gdef\psrbrace[} ]
\endgroup
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \paragraph{Colors}
% \begin{macro}{\@newcolor}
% |\@newcolor{<color>}{<spec>}|, where <color> is a name and <spec> is the
% associated PostScript color specification , sets
% \begin{itemize}
%   \item |\<color>| to |\pst@color{<spec>}|, and
%   \item |\color@<color>| to <spec>.
% \end{itemize}
% Then |\<color>| can be used by the user to color text, etc., and
% |\color@<color>| is used by PSTricks graphics objects to find the
% specification for <color>.
%    \begin{macrocode}
\def\@newcolor#1#2{%
  \expandafter\edef\csname #1\endcsname{\noexpand\pst@color{#2}}%
  \expandafter\edef\csname color@#1\endcsname{#2}%
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@color}
% \begin{macro}{\pst@endcolor}
% The argument of |\pst@color| should be a PostScript command for setting the
% color; e.g., "0 setgray". It saves the command in |\pst@currentcolor|, and
% then switches to |\pst@currentcolor| at the end of the current group. The
% color changes do not extend across pages, although this capability could be
% written into the output routines (so that |\pst@currentcolor| is set at the
% beginning of the page, and headers and footers begin with |\black|, etc.).
% Moving boxes cause problems, but there is no way around this until \TeX{}
% supports color internally.
%    \begin{macrocode}
\def\pst@color#1{%
  \def\pst@currentcolor{#1}\pstVerb{#1}\aftergroup\pst@endcolor}
\def\pst@endcolor{\pstVerb{\pst@currentcolor}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%    \begin{macrocode}
\def\pst@currentcolor{0 setgray}
\def\altcolormode{%
\def\pst@color##1{%
\pstVerb{gsave ##1}\aftergroup\pst@endcolor}%
\def\pst@endcolor{\pstVerb{\pst@grestore}}}
\def\pst@grestore{%
currentpoint
matrix currentmatrix
currentfont
grestore
setfont
setmatrix
moveto}
\def\pst@usecolor#1{\csname color@#1\endcsname\space}
\def\newgray#1#2{%
\pst@checknum{#2}\pst@tempg
\@newcolor{#1}{\pst@tempg setgray}}
\def\newrgbcolor#1#2{%
\pst@expandafter\pst@getnumiii{#2} {} {} {} {}\@nil
\@newcolor{#1}{\pst@tempg \pst@temph \pst@tempi setrgbcolor}}
\def\newhsbcolor#1#2{%
\pst@expandafter\pst@getnumiii{#2} {} {} {} {}\@nil
\@newcolor{#1}{\pst@tempg \pst@temph \pst@tempi sethsbcolor}}
\def\newcmykcolor#1#2{%
\pst@expandafter\pst@getnumiv{#2} {} {} {} {} {}\@nil
\@newcolor{#1}{\pst@tempg \pst@temph \pst@tempi \pst@tempj setcmykcolor}}
\newgray{black}{0}
\newgray{darkgray}{.25}
\newgray{gray}{.5}
\newgray{lightgray}{.75}
\newgray{white}{1}
\newrgbcolor{red}{1 0 0}
\newrgbcolor{green}{0 1 0}
\newrgbcolor{blue}{0 0 1}
\newrgbcolor{yellow}{1 1 0}
\newrgbcolor{cyan}{0 1 1}
\newrgbcolor{magenta}{1 0 1}
\define@key[psset]{}{style}{%
  \@ifundefined{pscs@#1}%
    {\@pstrickserr{Custom style `#1' undefined}\@ehpa}%
    {\@nameuse{pscs@#1}}}
\def\newpsstyle#1#2{\@namedef{pscs@#1}{\psset{#2}}}
\def\@none{none}
\def\pst@getcolor#1#2{%
\@ifundefined{color@#1}%
{\@pstrickserr{Color `#1' not defined}\@eha}%
{\edef#2{#1}}}
\newdimen\psunit \psunit 1cm
\newdimen\psxunit \psxunit 1cm
\newdimen\psyunit \psyunit 1cm
\let\psrunit\psunit
\def\pstunit@off{\let\@psunit\ignorespaces\ignorespaces}
\def\pssetlength#1#2{%
\let\@psunit\psunit
\afterassignment\pstunit@off
#1 #2\@psunit}
\def\psaddtolength#1#2{%
\let\@psunit\psunit
\afterassignment\pstunit@off
\advance#1 #2\@psunit}
\def\pssetxlength#1#2{%
\let\@psunit\psxunit
\afterassignment\pstunit@off
#1 #2\@psunit}
\def\pssetylength#1#2{%
\let\@psunit\psyunit
\afterassignment\pstunit@off
#1 #2\@psunit}
\define@key[psset]{}{unit}{%
  \pssetlength\psunit{#1}%
  \psxunit=\psunit
  \psyunit=\psunit}
\define@key[psset]{}{runit}{\pssetlength\psrunit{#1}}
\define@key[psset]{}{xunit}{\pssetxlength\psxunit{#1}}
\define@key[psset]{}{yunit}{\pssetylength\psyunit{#1}}
\define@key[psset]{}{PstDebug}{\pst@getint{#1}{\Pst@Debug}}% hv 2004-06-22
%
\def\pst@getlength#1#2{%
  \pssetlength\pst@dimg{#1}%
  \edef#2{\pst@number\pst@dimg}%
}
\def\pst@@getlength#1#2{%
  \pssetlength\pst@dimg{#1}%
  \edef#2{\number\pst@dimg sp}%
}
\def\pst@getcoor#1#2{\pst@@getcoor{#1}\let#2\pst@coor}
\def\pst@coor{0 0 }
\def\pst@getcoors#1#2{%
\def\pst@aftercoors{\addto@pscode{#1 \pst@coors }#2}%
\def\pst@coors{}%
\pst@@getcoors}
\def\pst@@getcoors(#1){%
\pst@@getcoor{#1}%
\edef\pst@coors{\pst@coor\pst@coors}%
\@ifnextchar({\pst@@getcoors}{\pst@aftercoors}}
\def\pst@getangle#1#2{\pst@@getangle{#1}\let#2\pst@angle}
\def\pst@angle{0 }
\def\cartesian@coor#1,#2,#3\@nil{%
\pssetxlength\pst@dimg{#1}%
\pssetylength\pst@dimh{#2}%
\edef\pst@coor{\pst@number\pst@dimg \pst@number\pst@dimh}}
\def\NormalCoor{%
\def\pst@@getcoor##1{\pst@expandafter\cartesian@coor{##1},\relax,\@nil}%
\def\pst@@getangle##1{%
\pst@checknum{##1}\pst@angle
\edef\pst@angle{\pst@angle \pst@angleunit}}%
\def\psput@##1{\pst@@getcoor{##1}\leavevmode\psput@cartesian}}
\NormalCoor
\def\degrees{\@ifnextchar[{\@degrees}{\def\pst@angleunit{}}}
\def\@degrees[#1]{%
\pst@checknum{#1}\pst@tempg
\edef\pst@angleunit{360 \pst@tempg div mul }%
\ignorespaces}
\def\radians{\def\pst@angleunit{57.2956 mul }}
\def\pst@angleunit{}
\def\SpecialCoor{%
\def\pst@@getcoor##1{%
\begingroup
\pst@activecoor
\xdef\pst@tempg{##1}%
\endgroup
\expandafter\special@coor\pst@tempg||\@nil}%
\def\pst@@getangle##1{%
\begingroup
\pst@activecoor
\xdef\pst@tempg{##1}%
\endgroup
\expandafter\special@angle\pst@tempg\@empty)\@nil}%
\def\psput@##1{\pst@@getcoor{##1}\leavevmode\psput@special}}
\begingroup
\catcode`\|=13
\catcode`\;=13
\catcode`\!=13
\gdef\pst@activecoor{%
\def|{\string|}%
\def;{\string;}%
\def!{\string!}}
\endgroup
\def\special@coor#1|#2|#3\@nil{%
\ifx#3|\relax
\mixed@coor{#1}{#2}%
\else
\special@@coor#1;;\@nil
\fi}
\def\special@@coor#1{%
\ifcat#1a\relax
\def\next{\node@coor#1}%
\else
\ifx#1[\relax
\def\next{\Node@coor[}%
\else
\ifx#1!\relax
\def\next{\raw@coor}%
\else
\def\next{\special@@@coor#1}%
\fi
\fi
\fi
\next}
\def\special@@@coor#1;#2;#3\@nil{%
\ifx#3;\relax
\polar@coor{#1}{#2}%
\else
\cartesian@coor#1,\relax,\@nil
\fi}
\def\mixed@coor#1#2{%
\begingroup
% DG/SR modification begin - Oct. 27, 1997 - Patch 6
%\specialcoor@ii#1;;\@nil
%\let\pst@tempa\pst@coor
%\specialcoor@ii#2;;\@nil
\special@@coor#1;;\@nil
\let\pst@tempa\pst@coor
\special@@coor#2;;\@nil
% DG/SR modification end
\xdef\pst@tempg{\pst@tempa pop \pst@coor exch pop }%
\endgroup
\let\pst@coor\pst@tempg}
\def\polar@coor#1#2{%
\pssetlength\pst@dimg{#1}%
\pst@@getangle{#2}%
\edef\pst@coor{\pst@number\pst@dimg \pst@angle \tx@PtoC}}
\def\raw@coor#1;#2\@nil{%
\edef\pst@coor{%
#1 \pst@number\psyunit mul exch \pst@number\psxunit mul exch }}
\def\node@coor#1\@nil{%
\@pstrickserr{You must load `pst-node.tex' to use node coordinates.}\@ehps
\def\pst@coor{0 0 }}
\def\Node@coor{\node@coor}
\def\special@angle#1#2)#3\@nil{%
\ifx!#1\relax
\edef\pst@angle{#2 \pst@angleunit}%
\else
\ifx(#1\relax
\pst@@getcoor{#2}%
\edef\pst@angle{\pst@coor exch \tx@Atan}%
\else
\pst@checknum{#1#2}\pst@angle
\edef\pst@angle{\pst@angle \pst@angleunit}%
\fi
\fi}
\def\Cartesian{%
\def\cartesian@coor##1,##2,##3\@nil{%
\pssetxlength\pst@dimg{##1}%
\pssetylength\pst@dimh{##2}%
\edef\pst@coor{\pst@number\pst@dimg \pst@number\pst@dimh}}%
\@ifnextchar({\Cartesian@}{}}
\def\Cartesian@(#1,#2){%
\pssetxlength\psxunit{#1}%
\pssetylength\psyunit{#2}%
\ignorespaces}
\def\Polar{%
  \def\psput@cartesian{\psput@special}%
  \def\cartesian@coor##1,##2,##3\@nil{\polar@coor{##1}{##2}}}%
\define@key[psset]{}{origin}{%
  \pst@@getcoor{#1}%
  \edef\psk@origin{\pst@coor \tx@NET }}
\def\psk@origin{}
\newif\ifswapaxes
\define@key[psset]{}{swapaxes}{%
  \@nameuse{@pst#1}%
  \if@pst
    \def\psk@swapaxes{-90 rotate -1 1 scale }%
  \else
    \def\psk@swapaxes{}%
  \fi}
\newif\ifshowpoints
\define@key[psset]{}{showpoints}{\@nameuse{showpoints#1}}
\let\pst@setrepeatarrowsflag\relax
\define@key[psset]{}{border}{%
  \pst@getlength{#1}\psk@border
  \pst@setrepeatarrowsflag}
\define@key[psset]{}{bordercolor}{\pst@getcolor{#1}\psbordercolor}
\newif\ifpsdoubleline
\define@key[psset]{}{doubleline}{%
  \@nameuse{psdoubleline#1}%
  \pst@setrepeatarrowsflag}
\define@key[psset]{}{doublesep}{\def\psdoublesep{#1}}
\define@key[psset]{}{doublecolor}{\pst@getcolor{#1}\psdoublecolor}
\newif\ifpsshadow
\define@key[psset]{}{shadow}{%
  \@nameuse{psshadow#1}%
  \pst@setrepeatarrowsflag}
\define@key[psset]{}{shadowsize}{\pst@getlength{#1}\psk@shadowsize}
\define@key[psset]{}{shadowangle}{\pst@getangle{#1}\psk@shadowangle}
\define@key[psset]{}{shadowcolor}{\pst@getcolor{#1}\psshadowcolor}
\def\pst@repeatarrowsflag{\z@}
\def\pst@setrepeatarrowsflag{%
\edef\pst@repeatarrowsflag{%
\ifdim\psk@border\p@>\z@ 1\else\ifpsdoubleline 1\else
\ifpsshadow 1\else \z@\fi\fi\fi}}
\def\psls@none{}
\newdimen\pslinewidth
\define@key[psset]{}{linewidth}{\pssetlength\pslinewidth{#1}}
\define@key[psset]{}{linecolor}{\pst@getcolor{#1}\pslinecolor}
\def\psls@solid{0 setlinecap stroke }
\def\pst@missing{%
  \z@
  \@pstrickserr{Missing number or dimension. 0 substituted}\@ehpa}
%
\def\pst@empty{\z@}
\define@key[psset]{}{dash}{\pst@expandafter\pst@@dash{#1}\@nil}% Error handling for empty argument.
\define@key[psset]{}{maxdashes}{\edef\psk@maxdashes{#1}}
%
\def\pst@@dash#1\@nil{%
  \def\psk@dash{}%
  \pst@cntm=0\relax%
  \def\next##1 ##2\relax{%
    \expandafter\ifnum\psk@maxdashes > \pst@cntm\relax% 04-08-07
    \edef\@tempa{##1}%
    \ifx\@tempa\@empty\else% gobble leading spaces
      \pssetlength\pst@dimc{##1}%
        \advance\pst@cntm by 1%
      \edef\psk@dash{\psk@dash\space\pst@number\pst@dimc}%
    \fi%
   \edef\@tempa{##2}%
   \ifx\@tempa\@empty\else% detect end
   \ifx\@tempa\space\else% gobble trailing spaces
     \next##2\relax%
   \fi\fi%
   \else% 04-08-07
     \@pstrickserr{Number of dashes > \psk@maxdashes . Increasing `maxdashes' might work.}\@ehpa% 04-08-07
   \fi% 04-08-07
 }%
\expandafter\next#1 \relax}
%
\newif\ifpsdashadjust
\define@key[psset]{}{dashadjust}{\@nameuse{psdashadjust#1}}
\def\psls@dashed{%
  \ifpsdashadjust
    \psk@dash \pst@linetype\space \tx@DashLine
  \else
    [ \psk@dash ] 0 setdash stroke
  \fi}
%
\def\tx@DashLine{DashLine }
%
\def\psls@dashed{%
  \ifpsdashadjust
    [ \psk@dash ] \pst@linetype\space \tx@DashLine
  \else
    [ \psk@dash ] 0 setdash stroke
  \fi}
\define@key[psset]{}{dotsep}{\pst@getlength{#1}\psk@dotsep}
\def\psls@dotted{%
  \ifpsdashadjust
    \psk@dotsep \pst@linetype\space \tx@DotLine
  \else
    [ 0 \psk@dotsep CLW add ] 0 setdash 1 setlinecap stroke
  \fi}
\def\tx@DotLine{DotLine }
\define@key[psset]{}{linestyle}{%
  \@ifundefined{psls@#1}%
    {\@pstrickserr{Line style `#1' not defined}\@eha}%
    {\edef\pslinestyle{#1}}%
}
\def\psfs@none{}
\define@key[psset]{}{fillcolor}{\pst@getcolor{#1}\psfillcolor}
\def\psfs@solid{\pst@fill{\pst@usecolor\psfillcolor fill}}
\def\psfs@eofill{\pst@fill{\pst@usecolor\psfillcolor eofill}}% hv
\define@key[psset]{}{hatchwidth}{\pst@getlength{#1}\psk@hatchwidth}
\define@key[psset]{}{hatchsep}{\pst@getlength{#1}\psk@hatchsep}
\define@key[psset]{}{hatchcolor}{\pst@getcolor{#1}\pshatchcolor}
\define@key[psset]{}{hatchangle}{\pst@getangle{#1}\psk@hatchangle}
%
\def\pst@linefill{%
  \psk@hatchangle rotate
  \psk@hatchwidth SLW
  \pst@usecolor\pshatchcolor
  \psk@hatchsep \tx@LineFill}
\def\psfs@vlines{\pst@fill\pst@linefill}
\@namedef{psfs@vlines*}{\psfs@solid \psfs@vlines}
\def\psfs@hlines{\pst@fill{90 rotate \pst@linefill}}
\@namedef{psfs@hlines*}{\psfs@solid \psfs@hlines}
\def\psfs@crosshatch{\psfs@vlines \psfs@hlines}
\@namedef{psfs@crosshatch*}{\psfs@solid \psfs@vlines \psfs@hlines}
\def\tx@LineFill{LineFill }
\define@key[psset]{}{fillstyle}{%
  \edef\pst@tempg{#1}\def\pst@temph{none}%
  \ifx\pst@tempg\pst@temph
    \let\psk@fillstyle\relax
  \else
    \@ifundefined{psfs@#1}%
      {\@pstrickserr{Undefined fill style: `#1'}\@eha}%
      {\edef\psk@fillstyle{\expandafter\noexpand\csname psfs@#1\endcsname}}%
  \fi}
\define@key[psset]{}{addfillstyle}{%
  \@ifundefined{psfs@#1}%
    {\@pstrickserr{Undefined fill style: `#1'}\@eha}%
    {\edef\psk@fillstyle{%
      \expandafter\noexpand\psk@fillstyle
      \expandafter\noexpand\csname psfs@#1\endcsname}}}
\define@key[psset]{}{arrows}{%
  \begingroup
    \pst@activearrows
    \xdef\pst@tempg{#1}%
  \endgroup
  \expandafter\arrows@ii\pst@tempg\@empty-\@empty\@nil
  \if@pst\else
    \@pstrickserr{Bad arrows specification: #1}\@ehpa
  \fi%
}
\def\arrows@ii#1-#2\@empty#3\@nil{%
  \@psttrue
  \def\next##1,#1-##2,##3\@nil{\def\pst@tempg{##2}}%
  \expandafter\next\pst@arrowtable,#1-#1,\@nil
  \@ifundefined{psas@\pst@tempg}%
    {\@pstfalse\def\psk@arrowA{}}%
    {\let\psk@arrowA\pst@tempg}%
  \@ifundefined{psas@#2}%
    {\@pstfalse\def\psk@arrowB{}}%
    {\def\psk@arrowB{#2}}%
}
\def\psk@arrowA{}
\def\psk@arrowB{}
\edef\pst@arrowtable{,<->,<<->>,>-<,>>-<<,(-),[-],)-(,]-[,|>-<|,H-H,|<*-*>|,|<->|}% hv
\begingroup
  \catcode`\<=13
  \catcode`\>=13
  \catcode`\|=13
  \gdef\pst@activearrows{\def<{\string<}\def>{\string>}\def|{\string|}}
\endgroup
\def\tx@BeginArrow{BeginArrow }
\def\tx@EndArrow{EndArrow }
\define@key[psset]{}{arrowscale}{%
  \pst@@arrowscale@i#1 \@nil
  \pst@getscale{\pst@arrowscale}\psk@arrowscale}
\def\pst@@arrowscale@i#1 #2\@nil{\edef\pst@arrowscale{#1}}
%
\define@key[psset]{}{arrowsize}{%
  \pst@expandafter\pst@getdimnum{#1} 0 {} {}\@nil
  \edef\psk@arrowsize{\pst@number\pst@dimg \pst@tempg}%
}
\define@key[psset]{}{arrowlength}{\pst@checknum{#1}\psk@arrowlength}
\define@key[psset]{}{arrowinset}{\pst@checknum{#1}\psk@arrowinset}%
%
\def\tx@Arrow{Arrow }
% New parameter "arrowfill", with default as "true"
\newif\ifpsArrowFill
\define@key[psset]{}{ArrowFill}{\@nameuse{psArrowFill#1}}

% Modification of the PostScript macro Arrow to choose to fill or not the arrow
% (it require to restore the current linewidth, despite of the scaling)
\pst@def{Arrow}<{%
    CLW mul add dup 2 div
    /w ED mul dup
    /h ED mul
    /a ED { 0 h T 1 -1 scale } if
    gsave
    \ifpsArrowFill\else\pst@number\pslinewidth \pst@arrowscale\space div SLW \fi
    w neg h moveto
    0 0 L w h L w neg a neg rlineto
    \ifpsArrowFill gsave fill grestore \else gsave closepath stroke grestore \fi
    grestore
    0 h a sub moveto
}>
%
\@namedef{psas@>}{%
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
}
\@namedef{psas@>>}{%
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
  0 h T
  gsave
  newpath
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
  CP
  grestore
  CP newpath moveto
  2 copy
  L
  stroke
  moveto
}
\@namedef{psas@<}{true \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow}
\@namedef{psas@<<}{%
  true \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
  CP newpath moveto 0 a neg L stroke 0 h neg T
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
}
\define@key[psset]{}{tbarsize}{%
  \pst@expandafter\pst@getdimnum{#1} 0 {} {}\@nil
  \edef\psk@tbarsize{\pst@number\pst@dimg \pst@tempg}%
}
\def\tx@Tbar{Tbar }
\@namedef{psas@|}{\psk@tbarsize \tx@Tbar}
\@namedef{psas@|*}{0 CLW -2 div T \psk@tbarsize \tx@Tbar}
\@namedef{psas@>|}{%
  \psk@tbarsize \tx@Tbar
  0 CLW 2 div T
  newpath
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
}
\@namedef{psas@>|*}{%
  0 CLW -2 div T
  \psk@tbarsize \tx@Tbar
  0 CLW 2 div T
  newpath
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
}
%
\define@key[psset]{}{bracketlength}{\pst@checknum{#1}\psk@bracketlength}
\def\tx@Bracket{Bracket }
\@namedef{psas@]}{\psk@bracketlength \psk@tbarsize \tx@Bracket}
\define@key[psset]{}{rbracketlength}{\pst@checknum{#1}\psk@rbracketlength}
%
\def\tx@RoundBracket{RoundBracket }
\@namedef{psas@)}{\psk@rbracketlength \psk@tbarsize \tx@RoundBracket}
\def\psas@c{1 \psas@@c}
\def\psas@cc{0 CLW 2 div T 1 \psas@@c}
\def\psas@C{2 \psas@@c}
\def\psas@@c{%
  setlinecap
  0 0 moveto
%%-------------------- v.1.04 begin HV 2004-05-18 ----------------
%  0 CLW 2 div L
  0 0.5 L
%%-------------------- v. 1.04 end HV 2004-05-18 ----------------
  stroke
  0 0 moveto
}
% HookLeft/RightArrow
\newdimen\pshooklength
\newdimen\pshookwidth
\define@key[psset]{}{hooklength}{\pssetlength\pshooklength{#1}}
\define@key[psset]{}{hookwidth}{\pssetlength\pshookwidth{#1}}
%
\def\tx@RHook{RHook }         % PostScript name
\@namedef{psas@H}{%
  /RHook {
    /x ED                     % hook width
    /y ED                     % hook length
    /z CLW 2 div def          % save it
    x y moveto                % goto first point
    x 0 0 0 0 y
    curveto                   % draw Bezier
    stroke
    0 y moveto                % define current point
  } def
  \pst@number\pshooklength
  \pst@number\pshookwidth
  \tx@RHook
}
%
\@namedef{psas@<|}{%
    \psk@tbarsize\space \tx@Tbar
    0 CLW 2 div T
    newpath
    true \psk@arrowinset\space \psk@arrowlength\space \psk@arrowsize\space \tx@Arrow%
}
% ]-[ arrow
\def\tx@BracketOut{BracketOut }
\@namedef{psas@[}{%
  /BracketOut {%
  CLW mul add dup CLW sub 2 div
%/x ED mul CLW add
  /x ED mul neg
  /y ED
  /z CLW 2 div def
  x neg y moveto
  x neg CLW 2 div L x CLW 2 div L x y L stroke 0 CLW moveto } def
  \psk@bracketlength\space \psk@tbarsize\space \tx@BracketOut
}
% )-( arrow
\def\tx@RoundBracketOut{RoundBracketOut }
\@namedef{psas@(}{%
  /RoundBracketOut {%
    CLW mul add dup 2 div
%/x ED mul
    /x ED mul neg
    /y ED
    /mtrx CM def
    0 CLW
    2 div T x y mul 0 ne { x y scale } if
    1 1 moveto
    .85 .5 .35 0 0 0 curveto
    -.35 0 -.85 .5 -1 1 curveto
    mtrx setmatrix stroke 0 CLW moveto } def
  \psk@rbracketlength\space \psk@tbarsize\space \tx@RoundBracketOut
}
%
\define@key[psset]{}{nArrowsA}{\def\psk@nArrowsA{#1}}
\define@key[psset]{}{nArrowsB}{\def\psk@nArrowsB{#1}}
\define@key[psset]{}{nArrows}{\def\psk@nArrowsA{#1}\def\psk@nArrowsB{#1}}
%
\@namedef{psas@>>}{%
    \psk@nArrowsA\space 1 sub {
      false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
      0 h a sub T
    } repeat
    gsave
    newpath
    false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
    CP
    grestore
    moveto
}
%
\@namedef{psas@<<}{%
    true \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
    0 h neg a add T
  \psk@nArrowsB\space 2 sub {
    false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
    0 h neg a add T
  } repeat
  false \psk@arrowinset \psk@arrowlength \psk@arrowsize \tx@Arrow
  0 h a 5 mul 2 div sub moveto
}
%
\define@key[psset]{}{ArrowInside}{%
  \def\pst@tempa{#1}%
  \ifx\pst@tempa\@empty\def\psk@ArrowInside{}
  \else
    \begingroup
      \pst@activearrows
      \xdef\pst@tempg{<#1}%
    \endgroup
    \expandafter\pst@@ArrowInside\pst@tempg\@empty-\@empty\@nil
    \if@pst\else\@pstrickserr{Bad intermediate arrow specification: #1}\@ehpa\fi%
  \fi%
}
% Adapted from \psset@@arrows
\def\pst@@ArrowInside#1-#2\@empty#3\@nil{%
  \@psttrue
  \def\next##1,#1-##2,##3\@nil{\def\pst@tempg{##2}}%
  \expandafter\next\pst@arrowtable,#1-#1,\@nil
  \@ifundefined{psas@#2}%
    {\@pstfalse\def\psk@ArrowInside{}}%
    {\def\psk@ArrowInside{#2}}%
}
% Modified version of \pst@addarrowdef
\def\pst@addarrowdef{%
  \addto@pscode{%
    /ArrowA {
      \ifx\psk@arrowA\@empty
  \pst@oplineto
      \else
  \pst@arrowdef{A}
  moveto
      \fi
    } def
    /ArrowB { \ifx\psk@arrowB\@empty \else \pst@arrowdef{B} \fi } def
% DG addition
    /ArrowInside { \ifx\psk@ArrowInside\@empty \else \pst@arrowdefA{Inside} \fi } def
    }%
}
% Adapted from \pst@arrowdef
\def\pst@arrowdefA#1{%
  \ifnum\pst@repeatarrowsflag>\z@
    /Arrow#1c [ 6 2 roll ] cvx def Arrow#1c
  \fi
  \tx@BeginArrow
  \psk@arrowscale
  \@nameuse{psas@\@nameuse{psk@Arrow#1}}
  \tx@EndArrow%
}
% ArrowInsidePos parameter (default value 0.5)
\define@key[psset]{}{ArrowInsidePos}{\pst@checknum{#1}\psk@ArrowInsidePos}%
\define@key[psset]{}{ArrowInsideNo}{\pst@checknum{#1}\psk@ArrowInsideNo}% hv 20031001
\define@key[psset]{}{ArrowInsideOffset}{\pst@checknum{#1}\psk@ArrowInsideOffset}% hv 20031001
%
\def\psas@{}
%
\def\tx@SD{SD }
\def\tx@EndDot{EndDot }
\def\psas@oo{{\pst@usecolor\psfillcolor true} true \psk@dotsize \tx@EndDot}
\def\psas@o{{\pst@usecolor\psfillcolor true} false \psk@dotsize \tx@EndDot}
\@namedef{psas@**}{{false} true \psk@dotsize \tx@EndDot}
\@namedef{psas@*}{{false} false \psk@dotsize \tx@EndDot}
\def\pst@par{}
\def\addto@par#1{%
  \ifx\pst@par\@empty
    \def\pst@par{#1}%
  \else
    \expandafter\def\expandafter\pst@par\expandafter{\pst@par,#1}%
  \fi}
\def\addbefore@par#1{%
  \ifx\pst@par\@empty%
    \def\pst@par{#1}%
  \else%
    \toks@{#1}%
    \pst@toks\expandafter{\pst@par}%
    \edef\pst@par{\the\toks@,\the\pst@toks}%
  \fi}
\def\use@par{%
  \ifx\pst@par\@empty\else%
    \expandafter\psset\expandafter{\pst@par}%
    \def\pst@par{}%
  \fi}
\def\pst@object#1{%
\pst@ifstar{%
\@ifnextchar[%
{\pst@@object{#1}}%
{\def\pst@par{}\@nameuse{#1@i}}}}
\def\pst@@object#1[#2]{%
\def\pst@par{#2}%
\@ifnextchar+{\@nameuse{#1@i}}{\@nameuse{#1@i}}}
\def\newpsobject#1#2#3{%
\@ifundefined{#2@i}%
{\@pstrickserr{Graphics object `#2' not defined}\@eha}{%
\@namedef{#1}{\pst@object{#1}}%
\@namedef{#1@i}{\addbefore@par{#3}\@nameuse{#2@i}}}%
\ignorespaces}
\def\pst@getarrows#1{\@ifnextchar({#1}{\pst@@getarrows{#1}}}
\def\pst@@getarrows#1#2{\addto@par{arrows=#2}#1}
%
\def\begin@ClosedObj{%
  \leavevmode%
  \pst@killglue%
  \begingroup%
  \use@par%
  \solid@star%
  \ifpsdoubleline \pst@setdoublesep \fi%
  \pst@addarrowdef% DG addition
  \init@pscode%
}
\def\end@ClosedObj{%
  \ifpsshadow \pst@closedshadow \fi%
  \ifdim\psk@border\p@>\z@ \pst@addborder \fi%
  \psk@fillstyle%
  \pst@stroke%
  \ifpsdoubleline \pst@doublestroke \fi%
  \ifshowpoints%
% DG modification begin - Mar. 4, 1995
%\addto@pscode{Points aload length 2 div cvi /N ED \psdots@iii}%
    \pst@OpenShowPoints%
% DG modification end
\fi
\use@pscode
\endgroup
\ignorespaces}
\def\begin@OpenObj{%
  \begin@ClosedObj%
  \let\pst@linetype\pst@arrowtype%
  \pst@addarrowdef}
\def\begin@AltOpenObj{%
  \begin@ClosedObj%
  \def\pst@repeatarrowsflag{\z@}%
  \def\pst@linetype{0}}
\def\end@OpenObj{%
\ifpsshadow \pst@openshadow \fi
\ifdim\psk@border\p@>\z@ \pst@addborder \fi
\psk@fillstyle
\pst@stroke
\ifpsdoubleline \pst@doublestroke \fi
\ifnum\pst@repeatarrowsflag>\z@ \pst@repeatarrows \fi
\ifshowpoints \pst@OpenShowPoints \fi
\use@pscode
\endgroup
\ignorespaces}
\def\begin@SpecialObj{%
\leavevmode
\pst@killglue
\begingroup
\use@par
\init@pscode}
\def\end@SpecialObj{%
\use@pscode
\endgroup
\ignorespaces}
\def\pst@code{}%
\def\init@pscode{%
\addto@pscode{%
\pst@number\pslinewidth SLW
\pst@usecolor\pslinecolor}}
\def\addto@pscode#1{\xdef\pst@code{\pst@code#1\space}}
\def\use@pscode{%
\pstverb{%
\pst@dict
\tx@STP
\pst@newpath
\psk@origin
\psk@swapaxes
\pst@code
end}%
\gdef\pst@code{}}
\def\pst@newpath{newpath }
\def\pst@@killglue{\unskip\ifdim\lastskip>\z@\expandafter\pst@@killglue\fi}
\def\KillGlue{\let\pst@killglue\pst@@killglue}
\def\DontKillGlue{\let\pst@killglue\relax}
\DontKillGlue
\def\solid@star{%
\if@star
\pslinewidth=\z@
\psdoublelinefalse
\def\pslinestyle{none}%
\def\psk@fillstyle{\psfs@solid}%
\let\psfillcolor\pslinecolor
\fi}
\def\pst@setdoublesep{%
\pst@getlength\psdoublesep\psdoublesep
\pslinewidth=2\pslinewidth
\advance\pslinewidth\psdoublesep\p@
\let\pst@setdoublesep\relax}
\def\tx@Shadow{Shadow }
\def\pst@closedshadow{%
\addto@pscode{%
gsave
\psk@shadowsize \psk@shadowangle \tx@PtoC
\tx@Shadow
\pst@usecolor\psshadowcolor
gsave fill grestore
stroke
grestore
gsave
\pst@usecolor\psfillcolor
gsave fill grestore
stroke
grestore}}
\def\pst@openshadow{%
  \addto@pscode{%
    gsave
    \psk@shadowsize \psk@shadowangle \tx@PtoC
    \tx@Shadow
    \pst@usecolor\psshadowcolor
    \ifx\psk@fillstyle\relax\else gsave fill grestore \fi
    stroke
  }%
  \pst@repeatarrows
  \addto@pscode{grestore}
  \ifx\psk@fillstyle\relax\else
    \addto@pscode{%
      gsave
      \pst@usecolor\psfillcolor
      gsave fill grestore
      stroke
      grestore
    }%
  \fi%
}
\def\pst@addborder{%
  \addto@pscode{%
    gsave
    \psk@border 2 mul
    CLW add SLW
    \pst@usecolor\psbordercolor
    stroke
    grestore
}}
\def\pst@stroke{%
  \ifx\pslinestyle\@none\else
    \addto@pscode{%
      gsave
      \pst@number\pslinewidth SLW
      \pst@usecolor\pslinecolor
      \@nameuse{psls@\pslinestyle}
      grestore
    }%
  \fi%
}
\def\pst@fill#1{\addto@pscode{gsave #1 grestore}}%
\def\pst@doublestroke{%
  \addto@pscode{%
    gsave
    \psdoublesep SLW
    \pst@usecolor\psdoublecolor
    stroke
    grestore
}}
\def\pst@arrowtype{%
  \ifx\psk@arrowB\@empty 0 \else -2 \fi
  \ifx\psk@arrowA\@empty 0 \else -1 \fi
  add
}
%
\def\pst@arrowdef#1{%
  \ifnum\pst@repeatarrowsflag>\z@ /Arrow#1c [ 6 2 roll ] cvx def Arrow#1c \fi
  \tx@BeginArrow
  \psk@arrowscale
  \@nameuse{psas@\@nameuse{psk@arrow#1}}
  \tx@EndArrow
}
%
\def\pst@repeatarrows{%
  \addto@pscode{%
    gsave
    \ifx\psk@arrowA\@empty\else ArrowAc ArrowA pop pop \fi
    \ifx\psk@arrowB\@empty\else ArrowBc ArrowB pop pop pop pop \fi
    grestore
}}
\def\pst@OpenShowPoints{%
  \addto@pscode{%
    gsave
    \psk@dotsize
    \@nameuse{psds@\psk@dotstyle}
    newpath
    Points aload length 2 div 2 sub cvi /N ED
    N 0 ge {
      \ifx\psk@arrowA\@empty  Dot \else pop pop \fi
      N { Dot } repeat
      \ifx\psk@arrowB\@empty Dot \else pop pop \fi
    }{ N 2 mul { pop } repeat } ifelse
    grestore
  }%
}
\def\pscustom{\pst@object{pscustom}}
\long\def\pscustom@i#1{%
  \begin@SpecialObj
  \solid@star
  \let\pst@ifcustom\iftrue
  \let\begin@ClosedObj\begin@CustomObj
  \let\end@ClosedObj\endgroup
  \def\begin@OpenObj{\begin@CustomObj\pst@addarrowdef}%
  \let\end@OpenObj\endgroup
  \let\begin@AltOpenObj\begin@CustomObj
  \def\begin@SpecialObj{%
    \begingroup
    \pst@misplaced{special graphics object}%
    \def\addto@pscode####1{}
    \let\end@SpecialObj\endgroup}%
  \def\@multips(##1)(##2)##3##4{\pst@misplaced\multips}%
  \def\psclip##1{\pst@misplaced\psclip}%
  \def\pst@repeatarrowsflag{\z@}%
  \let\pst@setrepeatarrowsflag\relax
  \showpointsfalse
  \let\showpointstrue\relax
  \def\pst@linetype{\pslinetype}%
  \psset{liftpen=\z@}%
  \def\pst@cp{/currentpoint load stopped pop }%
  \def\pst@oplineto{/lineto load stopped { moveto } if }%
  \def\pst@optcp##1##2{%
    \ifnum##1=\z@\def##2{/currentpoint load stopped { 0 0 } if }\fi}%
  \let\caddto@pscode\addto@pscode
  \def\cuse@par##1{{\use@par##1}}%
  \the\pst@customdefs
  \setbox\pst@hbox=\hbox{#1}%
  \psk@fillstyle
  \pst@stroke
  \end@SpecialObj}
%
\def\begin@CustomObj{%
\begingroup
\use@par
\addto@pscode{%
\pst@number\pslinewidth SLW
\pst@usecolor\pslinecolor}}
\def\pst@oplineto{moveto }
\def\pst@cp{}
\def\pst@optcp#1#2{}
\define@key[psset]{}{liftpen}{%
  \ifcase#1\relax
    \def\psk@liftpen{\z@}%
    \def\pst@cp{/currentpoint load stopped pop }%
    \def\pst@oplineto{/lineto load stopped { moveto } if }%
  \or
    \def\psk@liftpen{1}%
    \def\pst@cp{}%
    \def\pst@oplineto{/lineto load stopped { moveto } if }%
  \or
    \def\psk@liftpen{2}%
    \def\pst@cp{}%
    \def\pst@oplineto{moveto }%
  \else
    \def\psk@liftpen{}%
  \fi}
\def\psk@liftpen{-1}
%
\define@key[psset]{}{linetype}{%
  \pst@getint{#1}\pslinetype
  \ifnum\pst@dimg<-3
    \@pstrickserr{linetype must be greater than -3}\@ehpa
%----------------- hv begin 2004-05-07 ------------- patch 15
% \def\pslinetype{0}%
    \def\pslinetype{2}%
  \fi%
}
%\psset@linetype{0}
\psset{linetype=2}% otherwise there is a problem when using e.g.
%                     \psaxes[axesstyle=frame,linestyle=dashed]{->}(3,-2)
%----------------- hv end 2004-05-07 ------------- patch 15
%
\def\caddto@pscode#1{%
    \@pstrickserr{Command can only be used in \string\pscustom}\@ehpa%
}
\let\cuse@par\caddto@pscode
\def\tx@MSave{%
  /msavematrx
    [ tx@Dict /msavematrx known % does msavematrix exists?
        { msavematrx aload pop } if
        CM % matrix currentmatrix
    ] def
%----------------- hv begin 2004-05-07 ------------- patch 15
    msavematrx
%----------------- hv end 2004-05-07 ------------- patch 15
}
\def\tx@MRestore{%
tx@Dict /msavemtrx known { length 0 gt } { false } ifelse
{ /msavematrx [ msavematrx aload pop setmatrix ] def }
if }
\newtoks\pst@customdefs
\pst@customdefs{%
  \def\newpath{\addto@pscode{newpath}}%
  \def\moveto(#1){\pst@@getcoor{#1}\addto@pscode{\pst@coor moveto}}%
  \def\closepath{\addto@pscode{closepath}}%
  \def\gsave{\begingroup\addto@pscode{gsave}}%
  \def\grestore{\endgroup\addto@pscode{grestore}}%
% DG/SR modification begin - May 12, 1997 - Patch 2
%  \def\translate(#1){\pst@@getcoor{#1}\addto@pscode{\pst@coor moveto}}%
  \def\translate(#1){\pst@@getcoor{#1}\addto@pscode{\pst@coor translate}}%
% DG/SR modification end
  \def\rotate#1{\pst@@getangle{#1}\addto@pscode{\pst@angle rotate}}%
  \def\scale#1{\pst@getscale{#1}\pst@tempg\addto@pscode{\pst@tempg}}%
  \def\msave{\addto@pscode{\tx@MSave}}%
  \def\mrestore{\addto@pscode{\tx@MRestore}}%
  \def\swapaxes{\addto@pscode{-90 rotate -1 1 scale}}%
  \def\stroke{\pst@object{stroke}}%
  \def\fill{\pst@object{fill}}%
  \def\openshadow{\pst@object{openshadow}}%
  \def\closedshadow{\pst@object{closedshadow}}%
% DG/SR modification begin - Jan. 7, 1998 - Patch 8
% \def\movepath(#1){\pst@@getcoor{#1}\addto@pscode{\pst@coor tx@Shadow}}%
  \def\movepath(#1){\pst@@getcoor{#1}\addto@pscode{\pst@coor \tx@Shadow}}%
% DG/SR modification end
  \def\lineto{\pst@onecoor{lineto}}%
  \def\rlineto{\pst@onecoor{rlineto}}%
  \def\curveto{\pst@threecoor{curveto}}%
  \def\rcurveto{\pst@threecoor{rcurveto}}%
  \def\code#1{\addto@pscode{#1}}%
  \def\coor(#1){\pst@@getcoor{#1}\addto@pscode\pst@coor\@ifnextchar({\coor}{}}%
  \def\rcoor{\pst@getcoors{}{}}%
  \def\dim#1{\pssetlength\pst@dimg{#1}\addto@pscode{\pst@number\pst@dimg}}%
  \def\setcolor#1{%
% ----------------hv begin 2004-05-07-------------------- patch 15
%  \@ifundefined{color@#1}{}{\addto@pscode{\use@color{#1}}}}%
    \@ifundefined{color@#1}{}{\addto@pscode{\pst@usecolor{#1}}}}%
% ----------------hv end 2004-05-07--------------------
  \def\arrows#1{{\psset{arrows=#1}\pst@addarrowdef}}%
  \let\file\pst@rawfile
} % END \pst@customdefs
\def\closedshadow@i{\cuse@par\pst@closedshadow}
\def\openshadow@i{\cuse@par\pst@openshadow}
\def\stroke@i{\cuse@par\pst@stroke}%
\def\fill@i{\cuse@par\psk@fillstyle}%
\def\pst@onecoor#1(#2){%
\pst@@getcoor{#2}%
\addto@pscode{\pst@coor #1}}
\def\pst@threecoor#1(#2)#3(#4)#5(#6){%
\begingroup
\pst@getcoor{#2}\pst@tempa
\pst@getcoor{#4}\pst@tempb
% DG/SR modification begin - Aug.  4, 1999 - Patch 11
%\pst@getcoor{#6}\pst@tembc
\pst@getcoor{#6}\pst@tempc
% DG/SR modification end
\addto@pscode{\pst@tempa \pst@tempb \pst@tempc #1}%
\endgroup}
\def\pst@rawfile#1{%
\begingroup
\def\do##1{\catcode`##1=12\relax}"
\dospecials
\catcode`\%=14
\pst@@rawfile{#1}%
\endgroup}
\def\pst@@rawfile#1{%
\immediate\openin1 #1
\ifeof1
\@pstrickserr{File `#1' not found}\@ehpa
\else
\immediate\read1 to \pst@tempg
\loop
\ifeof1 \@pstfalse\else\@psttrue\fi
\if@pst
\addto@pscode\pst@tempg
\immediate\read1 to \pst@tempg
\repeat
\fi
\immediate\closein1\relax}
\def\tx@NArray{NArray }
\def\tx@NArray{NArray }
\def\tx@Line{Line }
\def\tx@Arcto{Arcto }
\def\tx@CheckClosed{CheckClosed }
\def\tx@Polygon{Polygon }
\define@key[psset]{}{gangle}{\pst@getangle{#1}\psk@gangle}
\def\tx@Diamond{Diamond }
\def\psdiamond{\pst@object{psdiamond}}
\def\psdiamond@i(#1){%
\@ifnextchar({\psdiamond@ii(#1)}{\psdiamond@ii(0,0)(#1)}}
\def\psdiamond@ii(#1)(#2){%
\begin@ClosedObj
\pst@getcoor{#1}\pst@tempa
\pst@getcoor{#2}\pst@tempb
\addto@pscode{%
\psline@iii
pop
\psk@dimen
\pst@tempb
\psk@gangle
\pst@tempa
\tx@Diamond}%
\def\pst@linetype{4}%
\end@ClosedObj}
\def\tx@Triangle{Triangle }
\def\pstriangle{\pst@object{pstriangle}}
\def\pstriangle@i(#1){%
\@ifnextchar({\pstriangle@ii(#1)}{\pstriangle@ii(0,0)(#1)}}
\def\pstriangle@ii(#1)(#2){%
\begin@ClosedObj
\pst@getcoor{#1}\pst@tempa
\pst@getcoor{#2}\pst@tempb
\addto@pscode{%
\psline@iii
pop
\psk@dimen
\pst@tempb
\psk@gangle
\pst@tempa
\tx@Triangle}%
\def\pst@linetype{2}%
\end@ClosedObj}
\def\tx@CCA{CCA }
\def\tx@CCA{CCA }
\def\tx@CC{CC }
\def\tx@IC{IC }
\def\tx@BOC{BOC }
\def\tx@NC{NC }
\def\tx@EOC{EOC }
\def\tx@BAC{BAC }
\def\tx@NAC{NAC }
\def\tx@EAC{EAC }
\def\tx@OpenCurve{OpenCurve }
\def\tx@AltCurve{AltCurve }
\def\tx@ClosedCurve{ClosedCurve }
\define@key[psset]{}{curvature}{%
  \edef\pst@tempg{#1 }%
  \expandafter\curvature@ii\pst@tempg * * * \@nil}
  \def\curvature@ii#1 #2 #3 #4\@nil{%
    \pst@checknum{#1}\pst@tempg
    \pst@checknum{#2}\pst@temph
    \pst@checknum{#3}\pst@tempi
    \edef\psk@curvature{\pst@tempg \pst@temph \pst@tempi}}
\def\pscurve{\pst@object{pscurve}}
\def\pscurve@i{%
\pst@getarrows{%
\begin@OpenObj
\pst@getcoors[\pscurve@ii}}
\def\pscurve@ii{%
  \addto@pscode{%
    \pst@cp
    \psk@curvature\space /c ED /b ED /a ED
    \ifshowpoints true \else false \fi
    \tx@OpenCurve%
}%
\end@OpenObj}
\def\psecurve{\pst@object{psecurve}}
\def\psecurve@i{%
\pst@getarrows{%
\begin@OpenObj
\pst@getcoors[\psecurve@ii}}
\def\psecurve@ii{%
\addto@pscode{%
\psk@curvature\space /c ED /b ED /a ED
\ifshowpoints true \else false \fi
\tx@AltCurve}%
\end@OpenObj}
\def\psccurve{\pst@object{psccurve}}
\def\psccurve@i{%
\begin@ClosedObj
\pst@getcoors[\psccurve@ii}
\def\psccurve@ii{%
\addto@pscode{%
\psk@curvature\space /c ED /b ED /a ED
\ifshowpoints true \else false \fi
\tx@ClosedCurve}%
\def\pst@linetype{1}%
\end@ClosedObj}
\define@key[psset]{}{dotsize}{%
  \pst@expandafter\pst@getdimnum{#1} 0 {} {}\@nil
  \edef\psk@@dotsize{\pst@number\pst@dimg}%
\let\psk@@@dotsize\pst@tempg
\edef\psk@dotsize{%
/DS \psk@@dotsize \psk@@@dotsize CLW mul add 2 div def }}
\define@key[psset]{}{dotscale}{%
  \pst@getscale{#1}\psk@dotscale
  \ifx\psk@dotscale\@empty
    \def\psk@xdotscale{1 }%
    \def\psk@ydotscale{1 }%
  \else
    \let\psk@xdotscale\pst@tempg
    \let\psk@ydotscale\pst@temph
  \fi}
% DG/SR modification begin - Oct. 17, 1997 - Patch 5
%\psset@dotscale{1}
% DG/SR modification end
\def\pst@Getangle#1#2{%
\pst@getangle{#1}\pst@tempg
\def\pst@temph{0. }%
\ifx\pst@tempg\pst@temph
\def#2{}%
\else
\edef#2{\pst@tempg\space rotate }%
\fi}
\define@key[psset]{}{dotangle}{%
  \pst@getangle{#1}\psk@@dotangle
  \ifdim\psk@@dotangle\p@=\z@
    \let\psk@dotangle\@empty
  \else
% DG/SR modification begin - Aug. 8, 1997 - Patch 4
%\edef\psk@dotangle{\psk@@dotangle rotate }
  \edef\psk@dotangle{\psk@@dotangle rotate }%
% DG/SR modification end
  \fi}
\def\pst@getdotsize{%
\pst@dimg=\psk@@@dotsize\pslinewidth
\advance\pst@dimg\psk@@dotsize\p@
\pst@dimh=\psk@ydotscale\pst@dimg
\pst@dimg=\psk@xdotscale\pst@dimg
\divide\pst@dimh 2
\divide\pst@dimg 2\relax}
% DG/SR modification begin - Oct. 17, 1997 - Patch 5
\psset{dotscale=1}
% DG/SR modification end
\def\psdot{\pst@object{psdot}}
\def\psdot@i{\@ifnextchar({\psdot@ii}{\psdot@ii(\z@,\z@)}}
\def\psdot@ii(#1){%
\begin@SpecialObj
\pst@@getcoor{#1}%
\addto@pscode{%
\psk@dotsize
\@nameuse{psds@\psk@dotstyle}%
\pst@coor Dot}%
\end@SpecialObj}
\def\psdots{\pst@object{psdots}}
\def\psdots@i{%
\begin@SpecialObj
\pst@getcoors[\psdots@ii}
\def\psdots@ii{%
\addto@pscode{false \tx@NArray \psdots@iii}%
\end@SpecialObj}
\def\psdots@iii{%
\psk@dotsize
\@nameuse{psds@\psk@dotstyle}
newpath
n { transform floor .5 add exch floor .5 add exch itransform Dot } repeat}
% DG: dead code (to suppress until \psset@dotstyle) ? - Aug. 4, 1997
\def\tx@SQ{SQ }
\def\tx@ST{ST }
\def\tx@SP{SP }
\def\pst@gdot#1{/Dot { gsave T \psk@dotangle \psk@dotscale #1 grestore } def }
\@namedef{psds@*}{\pst@gdot{0 0 DS \tx@SD}}
\@namedef{psds@o}{%
  /r2 DS CLW sub def
  \pst@gdot{0 0 DS \tx@SD \pst@usecolor\psfillcolor 0 0 r2 \tx@SD}}
\@namedef{psds@square*}{%
  /r1 DS .886 mul def
  \pst@gdot{r1 \tx@SQ}}
\@namedef{psds@square}{%
  /r1 DS .886 mul def /r2 r1 CLW sub def
  \pst@gdot{r1 \tx@SQ \pst@usecolor\psfillcolor r2 \tx@SQ}}
\@namedef{psds@triangle*}{%
  /y1 DS .778 mul neg def /x1 y1 1.732 mul neg def
  \pst@gdot{x1 y1 \tx@ST}}
\@namedef{psds@triangle}{%
  /y1 DS .778 mul neg def /x1 y1 1.732 mul neg def
  /y2 y1 CLW add def /x2 y2 1.732 mul neg def
  \pst@gdot{x1 y1 \tx@ST \pst@usecolor\psfillcolor x2 y2 \tx@ST}}
\@namedef{psds@pentagon*}{%
  /r1 DS 1.149 mul def
  \pst@gdot{r1 \tx@SP}}
\@namedef{psds@pentagon}{%
  DS .93 mul dup 1.236 mul /r1 ED CLW sub 1.236 mul /r2 ED
  \pst@gdot{r1 \tx@SP \pst@usecolor\psfillcolor r2 \tx@SP}}
\@namedef{psds@+}{%
  /DS DS 1.253 mul def
  \pst@gdot{DS 0 moveto DS neg 0 L stroke 0 DS moveto 0 DS neg L stroke}}
\@namedef{psds@|}{%
  \psk@tbarsize CLW mul add 2 div /DS ED
  \pst@gdot{0 DS moveto 0 DS neg L stroke}}
% DG: end dead code?
\define@key[psset]{}{dotstyle}{%
  \@ifundefined{psds@#1}%
    {\@pstrickserr{Dot style `#1' not defined}\@eha}%
    {\edef\psk@dotstyle{#1}}}
\def\tx@FontDot{FontDot }
\def\newpsfontdot#1[#2]#3#4{%
  \@namedef{psds@#1}{%
    /#3 \psk@@dotangle [#2] \tx@FontDot
% DG/SR modification begin - Dec. 12, 1999 - Patch 14
%/Dot { moveto #4 show } bind def }}
    /Dot { moveto gsave \psk@dotscale #4 show grestore } bind def
}}
% DG/SR modification end
\def\newpsfontdotH#1[#2]#3#4#5{%
  \@namedef{psds@#1}{%
    /#3 \psk@@dotangle [#2] \tx@FontDot
    /Dot {
      moveto
      \iftrue
% DG/SR modification begin - Dec. 23, 1999 - Patch 14
%gsave \pst@usecolor\psfillcolor #5 show grestore
%\fi
%#4 show
      gsave \psk@dotscale \pst@usecolor\psfillcolor #5 show grestore
      \fi
      gsave \psk@dotscale #4 show grestore
% DG/SR modification end
    } bind def
}}
%
\pstheader{pst-dots.pro}
\newpsfontdot{*}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(b)}
\newpsfontdotH{o}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(c)}{(b)}
\newpsfontdotH{Bo}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(C)}{(b)}
\newpsfontdotH{triangle}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(t)}{(u)}
\newpsfontdotH{Btriangle}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(T)}{(u)}
\newpsfontdot{triangle*}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(u)}
\newpsfontdotH{square}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(s)}{(r)}
\newpsfontdotH{Bsquare}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(S)}{(r)}
\newpsfontdot{square*}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(r)}
\newpsfontdotH{pentagon}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(p)}{(q)}
\newpsfontdotH{Bpentagon}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(P)}{(q)}
\newpsfontdot{pentagon*}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(q)}
% DG/SR modification begin - Mar. 18, 1997 and Dec. 16, 1999 - Patch 14
%\newpsfontdot{diamond*}%
%[1.9 0.0 0.0 1.9 -0.4598 -0.70775]{Symbol}{<E0>}
%\newpsfontdot{diamond}%
%[2.3 0.0 0.0 2.3 -0.8533 -0.5336]{Symbol}{<A8>}
% D.G. modification begin - Jan. 17, 2000
\newpsfontdotH{diamond}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(d)}{(l)}
\newpsfontdotH{Bdiamond}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(D)}{(l)}
\newpsfontdot{diamond*}[1.0 0.0 0.0 1.0 0.0 0.0]{PSTricksDotFont}{(l)}
% DG/SR modification end
\newpsfontdot{oplus}[1.44928 0.0 0.0 1.44928 -0.562319 -0.478261]{Symbol}{<C5>}
\newpsfontdot{otimes}[1.44928 0.0 0.0 1.44928 -0.562319 -0.475362]{Symbol}{<C4>}
\newpsfontdot{x}[1.8 0.0 0.0 1.8 -0.495 -0.4788]{Symbol}{<B4>}
\newpsfontdot{+}[2.3 0.0 0.0 2.3 -0.6486 -0.5819]{Times-Roman}{<2B>}
\newpsfontdot{asterisk}[2.43309 0.0 0.0 2.43309 -0.609489 -1.14477]{Times-Roman}{<2A>}
\newpsfontdot{B+}[2.3 0.0 0.0 2.3 -0.6555 -0.5819]{Times-Bold}{<2B>}
\newpsfontdot{Basterisk}[2.29358 0.0 0.0 2.29358 -0.576835 -1.08486]{Times-Bold}{<2A>}
\newpsfontdot{|}[1.98413 0.0 0.0 1.38 -0.258929 -0.5]{Helvetica}{(|)}
% DG/SR modification begin - Oct. 27, 1997 - Patch 7
%[1.98413 0.0 0.0 1.98413 -0.258929 -0.712302]{Helvetica}{(|)}
% DG/SR modification end
\newpsfontdot{B|}[1.98413 0.0 0.0 1.38 -0.277778 -0.5]{Helvetica-Bold}{(|)}%
% DG/SR modification begin - Oct. 27, 1997 - Patch 7
%[1.98413 0.0 0.0 1.98413 -0.277778 -0.78302]{Helvetica-Bold}{(|)}

% DG/SR modification end
\iffalse
\newpsfontdot{*}[2.77778 0.0 0.0 2.77778 -0.638889 -0.813889]{Symbol}{<B7>}
\newpsfontdot{o}[3.33333 0.0 0.0 3.33333 -0.666667 -1.78167]{Symbol}{<B0>}
\newpsfontdot{Bo}[4.69484 0.0 0.0 4.69484 -0.78169 -2.97418]{Times-Bold}{<CA>}
\fi
\newdimen\pslinearc
\define@key[psset]{}{linearc}{\pssetlength\pslinearc{#1}}
\def\psline{\pst@object{psline}}
\def\psline@i{%
  \pst@getarrows{%
    \begin@OpenObj
    \use@par
    \pst@getcoors[\psline@ii}}
\def\psline@ii{%
  \addto@pscode{%
    (\psk@ArrowInside) length 0 gt { true }{ false } ifelse /IfArrowInside exch def
    \psk@ArrowInsidePos\space /ArrowInsidePos exch def
    \psk@ArrowInsideOffset\space /ArrowInsideOffset exch def
    \psk@ArrowInsideNo\space cvi /ArrowInsideNo exch def
    \pst@cp
    \psline@iii
    \tx@Line}%
  \end@OpenObj}
\def\psline@iii{%
  \ifdim\pslinearc>\z@
    /r \pst@number\pslinearc def
    /Lineto { \tx@Arcto } def
  \else
    /Lineto /lineto load def
  \fi
  \ifshowpoints true \else false \fi}
\def\qline(#1)(#2){%
  \def\pst@par{}%
  \begin@SpecialObj
  \def\pst@linetype{0}%
  \pst@getcoor{#1}\pst@tempa
  \pst@@getcoor{#2}%
  \addto@pscode{%
    \pst@tempa moveto \pst@coor L
    \@nameuse{psls@\pslinestyle}}%
  \end@SpecialObj}
\def\pspolygon{\pst@object{pspolygon}}
\def\pspolygon@i{%
  \begin@ClosedObj%
  \def\pst@cp{}%
  \pst@getcoors[\pspolygon@ii}
\def\pspolygon@ii{%
  \addto@pscode{
    (\psk@ArrowInside) length 0 gt { true }{ false } ifelse /IfArrowInside exch def
    \psk@ArrowInsidePos\space /ArrowInsidePos exch def
    \psk@ArrowInsideOffset\space /ArrowInsideOffset exch def
    \psk@ArrowInsideNo\space cvi /ArrowInsideNo exch def
    \psline@iii
    \tx@Polygon}%
  \def\pst@linetype{1}%
  \end@ClosedObj}
\define@key[psset]{}{framearc}{\pst@checknum{#1}\psk@framearc}
\define@key[psset]{}{cornersize}{\pst@expandafter\cornersize@ii{#1}\@nil}
\def\cornersize@ii#1#2\@nil{%
  \if #1a\relax
    \def\psk@cornersize{\pst@number\pslinearc false }%
  \else
    \def\psk@cornersize{\psk@framearc true }%
  \fi}
\def\tx@Rect{Rect }
\def\tx@OvalFrame{OvalFrame }
\def\tx@Frame{Frame }
\define@key[psset]{}{dimen}{\pst@expandafter\pstdimen@ii{#1}\@nil}
\def\pstdimen@ii#1#2\@nil{%
  \if #1o\relax%
    \def\psk@dimen{.5 }%
  \else%
    \if #1m\relax%
      \def\psk@dimen{0 }%
    \else%
      \if #1i\relax%
        \def\psk@dimen{-.5 }%
  \fi\fi\fi}
%
\def\psframe{\pst@object{psframe}}
\def\psframe@i(#1){%
\@ifnextchar({\psframe@ii(#1)}{\psframe@ii(0,0)(#1)}}
\def\psframe@ii(#1)(#2){%
\begin@ClosedObj
\pst@getcoor{#1}\pst@tempa
\pst@@getcoor{#2}%
\addto@pscode{\psk@cornersize \pst@tempa \pst@coor \psk@dimen \tx@Frame}%
\def\pst@linetype{2}%
\showpointsfalse
\end@ClosedObj}
\def\tx@BezierNArray{BezierNArray }
\def\tx@OpenBezier{OpenBezier }
\def\tx@ClosedBezier{ClosedBezier }
\def\tx@BezierShowPoints{BezierShowPoints }
\def\psbezier{\pst@object{psbezier}}
\def\psbezier@i{%
\pst@getarrows{%
\begin@OpenObj
\pst@getcoors[\psbezier@ii}}
\def\psbezier@ii{%
  \addto@pscode{%
    (\psk@ArrowInside) length 0 gt { true }{ false } ifelse /IfArrowInside exch def
    \psk@ArrowInsidePos\space /ArrowInsidePos exch def
    \psk@ArrowInsideOffset\space /ArrowInsideOffset exch def
    \psk@ArrowInsideNo\space cvi /ArrowInsideNo exch def
% DG/SR modification begin - Apr. 28, 1997 - Patch 1
% \psbezier doesn't work inside \pscustom
%\pst@cp
% DG/SR modification end
    \ifshowpoints true \else false \fi
    \tx@OpenBezier
    \ifshowpoints \tx@BezierShowPoints \fi}%
  \end@OpenObj}
\def\pscbezier{\pst@object{pscbezier}}
\def\pscbezier@i{%
\begin@ClosedObj
\pst@getcoors[\pscbezier@ii}
\def\pscbezier@ii{%
\addto@pscode{%
\ifshowpoints true \else false \fi
\tx@ClosedBezier
\ifshowpoints \tx@BezierShowPoints \fi}%
\chardef\pst@linetype=1
\end@ClosedObj}
\def\tx@Parab{Parab }
\def\parabola{\pst@object{parabola}}
\def\parabola@i{\pst@getarrows\parabola@ii}
\def\parabola@ii#1(#2)#3(#4){%
  \begin@OpenObj
  \pst@getcoor{#2}\pst@tempa
  \pst@@getcoor{#4}%
  \addto@pscode{\pst@tempa \pst@coor \tx@Parab}%
  \end@OpenObj}
\define@key[psset]{}{gridwidth}{\pst@getlength{#1}\psk@gridwidth}
\define@key[psset]{}{griddots}{%
  \pst@cntg=#1\relax
  \edef\psk@griddots{\the\pst@cntg}}
\define@key[psset]{}{gridcolor}{\pst@getcolor{#1}\psgridcolor}
\define@key[psset]{}{subgridwidth}{\pst@getlength{#1}\psk@subgridwidth}
\define@key[psset]{}{subgridcolor}{\pst@getcolor{#1}\pssubgridcolor}
\define@key[psset]{}{subgriddots}{%
  \pst@cntg=#1\relax\edef\psk@subgriddots{\the\pst@cntg}}
\define@key[psset]{}{subgriddiv}{%
  \pst@cntg=#1\relax\edef\psk@subgriddiv{\the\pst@cntg}}
\define@key[psset]{}{gridlabels}{\pst@getlength{#1}\psk@gridlabels}
\define@key[psset]{}{gridlabelcolor}{\pst@getcolor{#1}\psgridlabelcolor}
%
\def\tx@Grid{Grid }
\def\psgrid{\pst@object{psgrid}}
\def\psgrid@i{\@ifnextchar(%
{\psgrid@ii}{\expandafter\psgrid@iv\pic@coor}}
\def\psgrid@ii(#1){\@ifnextchar(%
{\psgrid@iii(#1)}{\psgrid@iv(0,0)(0,0)(#1)}}
\def\psgrid@iii(#1)(#2){\@ifnextchar(%
{\psgrid@iv(#1)(#2)}{\psgrid@iv(#1)(#1)(#2)}}
\def\psgrid@iv(#1)(#2)(#3){%
\begin@SpecialObj
\pst@getcoor{#1}\pst@tempa
\pst@getcoor{#2}\pst@tempb
\pst@@getcoor{#3}%
\ifnum\psk@subgriddiv>1
\addto@pscode{gsave
\psk@subgridwidth SLW \pst@usecolor\pssubgridcolor
\pst@tempb \pst@coor \pst@tempa
\pst@number\psxunit \pst@number\psyunit
\psk@subgriddiv\space \psk@subgriddots\space
{} 0 \tx@Grid grestore}%
\fi
\addto@pscode{gsave
\psk@gridwidth SLW \pst@usecolor\psgridcolor
\pst@tempb \pst@coor \pst@tempa
\pst@number\psxunit \pst@number\psyunit
1 \psk@griddots\space { \pst@usecolor\psgridlabelcolor }
\psk@gridlabels \tx@Grid grestore}%
\end@SpecialObj}
\newif\ifpsmathbox
\psmathboxtrue
\def\pst@mathflag{\z@}
\newtoks\everypsbox
\let\pst@thisbox\relax
\long\def\pst@makenotverbbox#1#2{%
\edef\pst@mathflag{%
\ifpsmathbox\ifmmode\ifinner 1\else 2\fi\else \z@\fi\else \z@\fi}%
\setbox\pst@hbox=\hbox{%
\ifcase\pst@mathflag\or$\m@th\textstyle\or$\m@th\displaystyle\fi
{\pst@thisbox\the\everypsbox#2}%
\ifnum\pst@mathflag>\z@$\fi}%
#1}
\def\pst@makeverbbox#1{%
\def\pst@afterbox{#1}%
\edef\pst@mathflag{%
\ifpsmathbox\ifmmode\ifinner 1\else 2\fi\else \z@\fi\else \z@\fi}%
\afterassignment\pst@beginbox
\setbox\pst@hbox\hbox}
\def\pst@beginbox{%
\ifcase\pst@mathflag\or$\m@th\or$\m@th\displaystyle\fi
\bgroup\aftergroup\pst@endbox
\pst@thisbox
\the\everypsbox}
\def\pst@endbox{%
\ifnum\pst@mathflag>\z@$\fi
\egroup
\pst@afterbox}
\def\pst@makebox{\pst@@makebox}
\def\psverbboxtrue{\def\pst@@makebox{\pst@makeverbbox}}
\def\psverbboxfalse{\def\pst@@makebox{\pst@makenotverbbox}}
\psverbboxfalse
\def\pst@longbox{%
\def\pst@makebox{%
\gdef\pst@makebox{\pst@@makebox}%
\pst@makelongbox}}
\def\pst@makelongbox#1{%
\def\pst@afterbox{#1}%
\edef\pst@mathflag{%
\ifpsmathbox\ifmmode\ifinner 1\else 2\fi\else \z@\fi\else \z@\fi}%
\setbox\pst@hbox\hbox\bgroup
\aftergroup\pst@afterbox
\ifcase\pst@mathflag\or$\m@th\or$\m@th\displaystyle\fi
\begingroup
\pst@thisbox
\the\everypsbox}
\def\pst@endlongbox{%
\endgroup
  \ifnum\pst@mathflag>\z@$\fi
  \egroup%
}
\def\pslongbox#1#2{%
%--------------- hv begin 2004-05-07 ---------- patch 15
    \@namedef{#1}{\pst@longbox#2\ignorespaces}%
%    \@namedef{#1}{\pst@longbox#2}%
%--------------- hv end 2004-05-07 ---------- patch 15
    \@namedef{end#1}{\pst@endlongbox}%
}
\newdimen\psframesep
\define@key[psset]{}{framesep}{\pssetlength\psframesep{#1}}
\newif\ifpsboxsep
\define@key[psset]{}{boxsep}{\@nameuse{psboxsep#1}}
%
\def\pst@useboxpar{%
\use@par
\if@star
\let\pslinecolor\psfillcolor
\solid@star
\let\solid@star\relax
\fi
\ifpsdoubleline \pst@setdoublesep \fi}
\def\psframebox{\pst@object{psframebox}}
\def\psframebox@i{\pst@makebox\psframebox@ii}
\def\psframebox@ii{%
\begingroup
\pst@useboxpar
\pst@dima=\pslinewidth
\advance\pst@dima by \psframesep
\pst@dimc=\wd\pst@hbox\advance\pst@dimc by \pst@dima
\pst@dimb=\dp\pst@hbox\advance\pst@dimb by \pst@dima
\pst@dimd=\ht\pst@hbox\advance\pst@dimd by \pst@dima
\setbox\pst@hbox=\hbox{%
\ifpsboxsep\kern\pst@dima\fi
\begin@ClosedObj
\addto@pscode{%
\psk@cornersize
\pst@number\pst@dima neg
\pst@number\pst@dimb neg
\pst@number\pst@dimc
\pst@number\pst@dimd
.5
\tx@Frame}%
\def\pst@linetype{2}%
\showpointsfalse
\end@ClosedObj
\box\pst@hbox
\ifpsboxsep\kern\pst@dima\fi}%
\ifpsboxsep\dp\pst@hbox=\pst@dimb\ht\pst@hbox=\pst@dimd\fi
\leavevmode\box\pst@hbox
\endgroup}
\def\psdblframebox{\pst@object{psdblframebox}}
\def\psdblframebox@i{\addto@par{doubleline=true}\psframebox@i}
\def\psclip#1{%
\leavevmode
\begingroup
\begin@psclip
\begingroup
\def\use@pscode{%
\pstVerb{%
\pst@dict
/mtrxc CM def
CP CP T
\tx@STV
\psk@origin
\psk@swapaxes
newpath
\pst@code
clip
newpath
mtrxc setmatrix
moveto
0 setgray
end}%
\gdef\pst@code{}}%
\def\@multips(##1)(##2)##3##4{\pst@misplaced\multips}%
\def\nc@object##1##2##3##4{\pst@misplaced{node connection}}%
\hbox to\z@{#1}%
\endgroup
\def\endpsclip{%
\end@psclip
\endgroup}%
\ignorespaces}
\def\endpsclip{\pst@misplaced\endpsclip}
\let\begin@psclip\relax
\def\end@psclip{\pstVerb{currentpoint initclip moveto}}
\def\AltClipMode{%
\def\end@psclip{\pstVerb{\pst@grestore}}%
\def\begin@psclip{\pstVerb{gsave}}}
\def\clipbox{\@ifnextchar[{\clipbox@}{\clipbox@[\z@]}}
% DG modification begin - Apr. 3, 1997
% From paulus@immd5.informatik.uni-erlangen.de (Dietrich Paulus)
%\def\clipbox@[#1]{\pst@makebox\clipbox@@{#1}}
\def\clipbox@[#1]{\pst@makebox{\clipbox@@{#1}}}
% DG modification end
\def\clipbox@@#1{%
\pssetlength\pst@dimg{#1}%
\leavevmode\hbox{%
\begin@psclip
\pst@Verb{%
CM \tx@STV CP T newpath
/a \pst@number\pst@dimg def
/w \pst@number{\wd\pst@hbox}a add def
/d \pst@number{\dp\pst@hbox}a add neg def
/h \pst@number{\ht\pst@hbox}a add def
a neg d moveto
a neg h L
w h L
w d L
closepath
clip
newpath
0 0 moveto
setmatrix}%
\unhbox\pst@hbox
\end@psclip}}
\def\psshadowbox{\pst@object{psshadowbox}}
\def\psshadowbox@i{\pst@makebox\psshadowbox@ii}
\def\psshadowbox@ii{%
\begingroup
\pst@useboxpar
\psshadowtrue
\psboxseptrue
\def\psk@shadowangle{-45 }%
\setbox\pst@hbox=\hbox{\psframebox@ii}%
\pst@dimh=\psk@shadowsize\p@
\pst@dimh=.7071\pst@dimh
\pst@dimg=\dp\pst@hbox
\advance\pst@dimg\pst@dimh
\dp\pst@hbox=\pst@dimg
\pst@dimg=\wd\pst@hbox
\advance\pst@dimg\pst@dimh
\wd\pst@hbox=\pst@dimg
\leavevmode
\box\pst@hbox
\endgroup}
\def\pscirclebox{\pst@object{pscirclebox}}
\def\pscirclebox@i{\pst@makebox\pscirclebox@ii}
\def\pscirclebox@ii{%
\begingroup
\pst@useboxpar
\setbox\pst@hbox=\hbox{%
\pst@nodehook
\pscirclebox@iii
\box\pst@hbox}%
\ifpsboxsep \pscirclebox@sep \fi
\leavevmode
\box\pst@hbox
\endgroup}
\def\pscirclebox@iii{%
\if@star
\pslinewidth\z@
\pstverb{\pst@dict \tx@STP \pst@usecolor\psfillcolor
newpath \pscirclebox@iv \tx@SD end}%
\else
\begin@ClosedObj
\def\pst@linetype{4}\showpointsfalse
\addto@pscode{%
\pscirclebox@iv CLW 2 div add 0 360 arc closepath}%
\end@ClosedObj
\fi}
\def\pscirclebox@iv{%
\pst@number{\wd\pst@hbox}2 div
\pst@number{\ht\pst@hbox}\pst@number{\dp\pst@hbox}add 2 div
2 copy \pst@number{\dp\pst@hbox}sub 4 2 roll
\tx@Pyth \pst@number\psframesep add }
\def\pscirclebox@sep{%
\pst@dimb=\ht\pst@hbox
\advance\pst@dimb\dp\pst@hbox
\divide\pst@dimb 2
\pst@dima=.5\wd\pst@hbox
\pst@pyth\pst@dima\pst@dimb\pst@dimc
\advance\pst@dimc\pslinewidth
\advance\pst@dimc\psframesep
\advance\pst@dimb-\pst@dimc
\setbox\pst@hbox=\hbox to2\pst@dimc{%
\hss
\vbox{\kern-\pst@dimb\box\pst@hbox}%
\hss}%
\advance\pst@dimb-\dp\pst@hbox
\dp\pst@hbox=-\pst@dimb}
\let\pst@nodehook\relax
\def\psCirclebox{\pst@object{psCirclebox}}
\def\psCirclebox@i{\pst@makebox\psCirclebox@ii}
\def\psCirclebox@ii{%
\begingroup
\pst@useboxpar
\pst@dima=\ht\pst@hbox
\advance\pst@dima\dp\pst@hbox
\divide\pst@dima\tw@
\pssetlength\pst@dimb\psk@radius
\setbox\pst@hbox=\hbox{%
\pst@nodehook
\pscircle(.5\wd\pst@hbox,\pst@dima){\pst@dimb}%
\box\pst@hbox}%
\ifpsboxsep \psCirclebox@sep \fi
\leavevmode
\box\pst@hbox
\endgroup}
\def\psCirclebox@sep{%
\pst@dimc=\pst@dimb
\advance\pst@dimb-\pst@dima
\advance\pst@dima\pst@dimc
\setbox\pst@hbox=\hbox to\tw@\pst@dimc{%
\hss
\vrule width \z@ depth \pst@dimb height \pst@dima
\box\pst@hbox
\hss}}%
\def\psovalbox{\pst@object{psovalbox}}
\def\psovalbox@i{\pst@makebox{\psovalbox@ii}}
\def\psovalbox@ii{%
\begingroup
\pst@useboxpar
\psovalbox@iii
\ifpsboxsep\psovalbox@sep\fi
\leavevmode
\box\pst@hbox
\endgroup}
\def\psovalbox@iii{%
\psovalbox@iv
\setbox\pst@hbox=\hbox{%
\begin@ClosedObj
\addto@pscode{%
0 360
\pst@number\pst@dimc CLW 2 div sub
\pst@number\pst@dimd CLW 2 div sub
\pst@number\pst@dima
\pst@number\pst@dimb
\tx@Ellipse
closepath}%
\def\pst@linetype{2}%
\end@ClosedObj
\unhbox\pst@hbox}}
\def\psovalbox@iv{%
\pst@dimc=\pslinewidth\advance\pst@dimc\psframesep
\pst@dimd=\ht\pst@hbox\advance\pst@dimd\dp\pst@hbox
\pst@dima=.5\wd\pst@hbox
\pst@dimb=.5\pst@dimd\advance\pst@dimb-\dp\pst@hbox
\pst@dimd=.707\pst@dimd
\advance\pst@dimd\pst@dimc
\advance\pst@dimc.707\wd\pst@hbox}
\def\psovalbox@sep{%
\setbox\pst@hbox\hbox to 2\pst@dimc{\hss\unhbox\pst@hbox\hss}%
\pst@dimg=\pst@dimd
\advance\pst@dimg-\pst@dimb
\dp\pst@hbox=\pst@dimg
\advance\pst@dimd\pst@dimb
\ht\pst@hbox=\pst@dimd}
\def\psdiabox{\pst@object{psdiabox}}
\def\psdiabox@i{\pst@makebox{\psdiabox@ii}}
\def\psdiabox@ii{%
\begingroup
\pst@useboxpar
\psdiabox@iii
\ifpsboxsep\psdiabox@sep\fi
\leavevmode
\box\pst@hbox
\endgroup}
\def\psdiabox@iv{%
\pst@dimg=.707\pslinewidth
\advance\pst@dimg.707\psframesep
\pst@dima=\wd\pst@hbox
\divide\pst@dima 2
\pst@dimc=\pst@dima
\advance\pst@dimc\pst@dimg
\pst@dimd=\ht\pst@hbox
\advance\pst@dimd\dp\pst@hbox
\divide\pst@dimd 2
\pst@dimb=\pst@dimd
\advance\pst@dimb-\dp\pst@hbox
\advance\pst@dimd\pst@dimg}
\def\psdiabox@iii{%
\psdiabox@iv
\setbox\pst@hbox=\hbox{%
\begin@ClosedObj
\addto@pscode{%
\psline@iii
pop
.5
\pst@number\pst@dimc 2 mul \pst@number\pst@dimd 2 mul
0
\pst@number\pst@dima \pst@number\pst@dimb
\tx@Diamond}%
\def\pst@linetype{4}%
\end@ClosedObj
\box\pst@hbox}}
\def\psdiabox@sep{%
\setbox\pst@hbox\hbox to 4\pst@dimc{\hss\unhbox\pst@hbox\hss}%
\multiply\pst@dimd 2
\advance\pst@dimd\pst@dimb
\ht\pst@hbox\pst@dimd
\advance\pst@dimd-2\pst@dimb
\dp\pst@hbox\pst@dimd}
\define@key[psset]{}{trimode}{\pst@expandafter\trimode@ii{#1}\@empty\@empty\@nil}
\def\trimode@ii#1#2#3\@nil{%
  \let\pst@tempg#1\relax
  \ifx\pst@tempg*%
    \let\psk@@trimode\@empty
    \let\pst@tempg#2\relax
  \else
    \let\psk@@trimode\relax
  \fi
  \edef\psk@trimode{%
    \ifx R\pst@tempg 1 \else\ifx D\pst@tempg 2
    \else\ifx L\pst@tempg 3 \else 0 \fi\fi\fi}}
\def\pstribox{\pst@object{pstribox}}
\def\pstribox@i{\pst@makebox{\pstribox@ii}}
\def\pstribox@ii{%
\begingroup
\pst@useboxpar
\pstribox@iii
\ifpsboxsep\pstribox@sep\fi
\leavevmode
\box\pst@hbox
\endgroup}
\def\pstribox@iii{%
\pstribox@iv
\setbox\pst@hbox=\hbox{%
\begin@ClosedObj
\addto@pscode{%
\psline@iii
pop
.5
\pst@number\pst@dimc \pst@number\pst@dimd
\ifodd\psk@trimode exch \fi
\psk@trimode -90 mul
\pst@number\pst@dima \pst@number\pst@dimb
\tx@Triangle}%
\def\pst@linetype{2}%
\end@ClosedObj
\box\pst@hbox}}
\def\pstribox@iv{%
\pst@dimh=\pslinewidth
\advance\pst@dimh\psframesep
\pst@dimg=\ht\pst@hbox
\advance\pst@dimg-\dp\pst@hbox
\divide\pst@dimg 2
\edef\pst@tempa{\number\pst@dimg sp}% For use by nodes.
\ifodd\psk@trimode
\pst@dimb\pst@dimg
\else
\pst@dima=\wd\pst@hbox
\divide\pst@dima 2
\fi
\ifcase\psk@trimode
\pst@dimb=-\dp\pst@hbox
\advance\pst@dimb-\pst@dimh
\or
\pst@dima=-\pst@dimh
\or
\pst@dimb=\ht\pst@hbox
\advance\pst@dimb\pst@dimh
\or
\pst@dima=\wd\pst@hbox
\advance\pst@dima\pst@dimh
\fi
\pst@dimd=\dp\pst@hbox
\advance\pst@dimd\ht\pst@hbox
\ifx\psk@@trimode\relax
\pst@dimc=\wd\pst@hbox
\advance\pst@dimc\ifodd\psk@trimode 1.447\else 1.789\fi\pst@dimh
\multiply\pst@dimc 2
\advance\pst@dimd\ifodd\psk@trimode 1.789\else 1.447\fi\pst@dimh
\multiply\pst@dimd 2
\else
\ifodd\psk@trimode
\advance\pst@dimd 1.1547\wd\pst@hbox
\advance\pst@dimd 3.4641\pst@dimh
\pst@dimc=.866\pst@dimd
\else
\advance\pst@dimd .866\wd\pst@hbox %.866=(sqrt(3)/2)
\advance\pst@dimd 3\pst@dimh
\pst@dimc=1.1547\pst@dimd % 1.1547=(2/sqrt(3))
\fi
\fi}
\def\pstribox@sep{%
\ifodd\psk@trimode
\advance\pst@dimb.5\pst@dimd
\ht\pst@hbox=\pst@dimb
\advance\pst@dimd-\pst@dimb
\dp\pst@hbox=\pst@dimd
\else
\setbox\pst@hbox\hbox to \pst@dimc{\hss\unhbox\pst@hbox\hss}%
\global\pst@dimg=.5\pst@dimc
\fi
\ifcase\psk@trimode
\dp\pst@hbox-\pst@dimb
\advance\pst@dimd\pst@dimb
\ht\pst@hbox\pst@dimd
\or
\pst@dimg=.5\wd\pst@hbox
\global\advance\pst@dimg-\pst@dima
\setbox\pst@hbox\hbox to \pst@dimc{\kern-\pst@dima\box\pst@hbox\hss}%
\or
\ht\pst@hbox\pst@dimb
\advance\pst@dimd-\pst@dimb
\dp\pst@hbox\pst@dimd
\or
\pst@dimg=\pst@dimc
\advance\pst@dimg-\pst@dima
\global\advance\pst@dimg.5\wd\pst@hbox
\setbox\pst@hbox\hbox to \pst@dimc{%
\hss\box\pst@hbox\kern\psframesep\kern\pslinewidth}%
\fi}
\define@key[psset]{}{arcsepA}{\pst@getlength{#1}\psk@arcsepA}
\define@key[psset]{}{arcsepB}{\pst@getlength{#1}\psk@arcsepB}
\define@key[psset]{}{arcsep}{%
  \psset{arcsepA=#1}\let\psk@arcsepB\psk@arcsepA}
\def\tx@ArcArrow{ArcArrow }
\def\psarc{\pst@object{psarc}}
\def\psarc@i{\@ifnextchar({\psarc@iii}{\psarc@ii}}
\def\psarc@ii#1{\addto@par{arrows=#1}%
  \@ifnextchar({\psarc@iii}{\psarc@iii(0,0)}%
}
\def\psarc@iii(#1)#2#3#4{%
  \begin@OpenObj
    \pst@getangle{#3}\pst@tempa
    \pst@getangle{#4}\pst@tempb
    \pst@@getcoor{#1}%
    \pssetlength\pst@dima{#2}%
    \addto@pscode{\psarc@iv \psarc@v}%
    \gdef\psarc@type{0}%
    \showpointsfalse
  \end@OpenObj%
}
\def\psarc@iv{%
\pst@coor /y ED /x ED
/r \pst@number\pst@dima def
/c 57.2957 r \tx@Div def
/angleA
\pst@tempa
\psk@arcsepA c mul 2 div
\ifcase \psarc@type add \or sub \fi
def
/angleB
\pst@tempb
\psk@arcsepB c mul 2 div
\ifcase \psarc@type sub \or add \fi
def
\ifshowpoints\psarc@showpoints\fi
\ifx\psk@arrowA\@empty
\ifnum\psk@liftpen=2
r angleA \tx@PtoC
y add exch x add exch
moveto
\fi
\fi}
\def\psarc@v{%
  x y r
  angleA
  \ifx\psk@arrowA\@empty\else
    { ArrowA CP }
    { \ifcase\psarc@type add \or sub \fi }
    \tx@ArcArrow
  \fi
  angleB
  \ifx\psk@arrowB\@empty\else
    { ArrowB }
    { \ifcase\psarc@type sub \or add \fi }
 \tx@ArcArrow
  \fi
\ifcase\psarc@type arc \or arcn \fi}
\def\psarc@type{0}
\def\psarc@showpoints{%
  gsave
  newpath
  x y moveto
  x y r \pst@tempa \pst@tempb
  \ifcase\psarc@type arc \or arcn \fi
  closepath
  CLW 2 div SLW
  [ \psk@dash\space ] 0 setdash stroke
  grestore }
\def\psarcn{\pst@object{psarcn}}
\def\psarcn@i{\def\psarc@type{1}\psarc@i}
%
%------------------ tvz/DG/hv (2004-05-10) begin -------------------%%
% from Dennis Giroux: http://www.tug.org/pipermail/pstricks/2001/000507.html
%
% I - Definition of \psellipticwedge, a generalization of \pswedge for wedges
%     of ellipses (from the code of \pswedge and \psellipse)
%
\def\psellipticwedge{\def\pst@par{}\pst@object{psellipticwedge}}
\def\psellipticwedge@i(#1){%
  \@ifnextchar({\psellipticwedge@ii(#1)}{\psellipticwedge@ii(0,0)(#1)}}
\def\psellipticwedge@ii(#1)(#2)#3#4{%
  \begin@ClosedObj
    \pst@getangle{#3}\pst@tempa
    \pst@getangle{#4}\pst@tempb
    \pst@getcoor{#1}\pst@tempc
    \pst@@getcoor{#2}%
    \def\pst@linetype{1}%
    \addto@pscode{%
      \pst@tempa \pst@tempb
      \pst@coor
      \pst@tempc moveto
      \ifdim\psk@dimen\p@=\z@\else
        \psk@dimen CLW mul dup 3 1 roll
        sub 3 1 roll sub exch
      \fi
      \pst@tempc
      \tx@Ellipse
      closepath%
    }%
    \showpointsfalse
  \end@ClosedObj%
}
%
% Code mainly from "pstricks.tex'' 0.94 beta (TvZ)
%
\def\psellipticarcn{\def\pst@par{}\pst@object{psellipticarcn}}
\def\psellipticarcn@i{\let\if@psarcn\iftrue\psellipticarc@ii}
%
\def\psellipticarc{\def\pst@par{}\pst@object{psellipticarc}}
\def\psellipticarc@i{\let\if@psarcn\iffalse\psellipticarc@ii}
%
\let\if@psarcn\iffalse
\def\psellipticarc@ii{\pst@getarrows\psellipticarc@iii}
\def\psellipticarc@iii(#1){%
  \@ifnextchar({\psellipticarc@iv(#1)}{\psellipticarc@iv(0,0)(#1)}}
\def\psellipticarc@iv(#1)(#2)#3#4{%
  \begin@OpenObj
    \pst@getcoor{#1}\pst@tempa
    \pst@getcoor{#2}\pst@tempb
    \pst@getangle{#3}\pst@tempc
    \pst@getangle{#4}\pst@tempd
    \addto@pscode{\psellipticarc@definearg \psellipticarc@draw}%
    \showpointsfalse
  \end@OpenObj%
}
\def\psellipticarc@definearg{%
  \pst@tempa /y ED /x ED  % Origin
  \pst@tempb              % radii. Now adjust:
  \ifdim\psk@dimen\p@=\z@\else
    \psk@dimen CLW mul dup 3 1 roll
    sub 3 1 roll sub exch
  \fi
  /ry ED /rx ED
  /angleA
    /d  {  \if@psarcn sub \else add \fi } def
    \pst@tempc \psk@arcsepA 2 div
    \tx@ArcAdjust
  def
  /angleB
    /d  {  \if@psarcn add \else sub \fi } def
    \pst@tempd \psk@arcsepB 2 div
    \tx@ArcAdjust
  def
  \ifshowpoints\psellipticarc@showpoints\fi
  \ifx\psk@arrowA\@empty
    \ifnum\psk@liftpen=2
      angleA cos rx mul x add
      angleA sin ry mul y add
      moveto
    \fi
  \fi%
}
\def\psellipticarc@draw{%
  0 0 1
  angleA
  \ifx\psk@arrowA\@empty\else
    { ArrowA CP }
    { \if@psarcn sub \else add \fi }
    \tx@EllipticArcArrow
  \fi
  angleB
  \ifx\psk@arrowB\@empty\else
    { ArrowB }
    { \if@psarcn add \else sub \fi }
    \tx@EllipticArcArrow
  \fi
  /mtrx CM def
  x y T
  rx ry scale
  \if@psarcn arcn \else arc \fi
  mtrx setmatrix%
}
\def\psellipticarc@showpoints{%
  gsave
  /mtrx CM def
  x y T
  rx ry scale
  0 0 moveto
  0 0 1 \pst@tempc \pst@tempd
  \ifcase\psarc@type arc \or arcn \fi
  closepath
  mtrx setmatrix
  CLW 2 div SLW
  [ \psk@dash\space ] 0 setdash stroke
  grestore %
}
\pst@def{ArcAdjust}<%
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if
  angle0 exch d
% maximum number of times to iterate the iterative procedure:
  30
% iterative procedure: takes an angle t on top of stack, computes a better angle (an put it on top of stack)
  { dup
% compute distance D between (x0,y0) and M(t)
  dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
  dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
  exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
  2 index \tx@Div targetLength mul y0 add ry \tx@Div exch
  2 index \tx@Div targetLength mul x0 add rx \tx@Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
  atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
%after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
>
\pst@def{EllipticArcArrow}<%
  /d ED      % add/sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch \tx@ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul x add
  a2 sin ry mul y add
  a1 cos rx mul x add
  a1 sin ry mul y add
  % Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  \tx@ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse>  % Adjust angle to give overlap.
%
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
\def\pscircle{\pst@object{pscircle}}
\def\pscircle@i{\@ifnextchar({\pscircle@do}{\pscircle@do(0,0)}}
\def\pscircle@do(#1)#2{%
\if@star
{\use@par\qdisk(#1){#2}}%
\else
\begin@ClosedObj
\pst@@getcoor{#1}%
\pssetlength\pst@dimc{#2}%
\def\pst@linetype{4}%
\addto@pscode{%
\pst@coor
\pst@number\pst@dimc
\psk@dimen CLW mul sub
0 360 arc
closepath}%
\showpointsfalse
\end@ClosedObj
\fi
\ignorespaces}
\def\qdisk(#1)#2{%
\def\pst@par{}%
\begin@SpecialObj
\pst@@getcoor{#1}%
\pssetlength\pst@dimg{#2}%
\addto@pscode{\pst@coor \pst@number\pst@dimg \tx@SD}%
\end@SpecialObj}
\define@key[psset]{}{radius}{\pst@@getlength{#1}\psk@radius}
\def\psCircle{\pst@object{psCircle}}
\def\psCircle@i{\@ifnextchar({\psCircle@ii}{\psCircle@ii(0,0)}}
\def\psCircle@ii(#1){\pscircle@do(#1){\psk@radius}}
\def\pswedge{\pst@object{pswedge}}
\def\pswedge@i{\@ifnextchar({\pswedge@ii}{\pswedge@ii(0,0)}}
\def\pswedge@ii(#1)#2#3#4{%
\begin@ClosedObj
\pssetlength\pst@dimc{#2}
\pst@getangle{#3}\pst@tempa
\pst@getangle{#4}\pst@tempb
\pst@@getcoor{#1}%
\def\pst@linetype{1}%
\addto@pscode{%
\pst@coor
2 copy
moveto
\pst@number\pst@dimc \psk@dimen CLW mul sub % Adjusted radius
\pst@tempa \pst@tempb
arc
closepath}%
\showpointsfalse
\end@ClosedObj}
\def\tx@Ellipse{Ellipse }
\def\psellipse{\pst@object{psellipse}}
\def\psellipse@i(#1){\@ifnextchar(%
{\psellipse@ii(#1)}{\psellipse@ii(0,0)(#1)}}
\def\psellipse@ii(#1)(#2){%
\begin@ClosedObj
\pst@getcoor{#1}\pst@tempa
\pst@@getcoor{#2}%
\addto@pscode{%
0 360
\pst@coor
\ifdim\psk@dimen\p@=\z@\else
\psk@dimen CLW mul
dup 4 -1 roll sub neg 3 1 roll sub
\fi
\pst@tempa
\tx@Ellipse
closepath}%
\def\pst@linetype{2}%
\end@ClosedObj}
\def\multips{\@ifnextchar({\def\pst@par{}\multips@ii}{\multips@i}}
\def\multips@i#1{\def\pst@par{rot=#1}\multips@ii}
\def\multips@ii(#1){\@ifnextchar({\multips@iii(#1)}{\multips@iii(\z@,\z@)(#1)}}
\long\def\multips@iii(#1)(#2)#3#4{%
  \begingroup%
  \use@par%
  \pst@getcoor{#1}\pst@tempa%
  \pst@@getcoor{#2}%
  \pst@cnta=#3\relax%
  \init@pscode%
  \addto@pscode{%
    \pst@tempa T \the\pst@cnta\space \pslbrace
    gsave \ifx\psk@rot\@empty\else\psk@rot rotate \fi}%
  \hbox to\z@{%
    \def\init@pscode{%
      \addto@pscode{%
        gsave
        \pst@number\pslinewidth SLW
        \pst@usecolor\pslinecolor}}%
    \def\use@pscode{\addto@pscode{grestore}}%
    \def\psclip##1{\pst@misplaced\psclip}%
    \def\nc@object##1##2##3##4{\pst@misplaced{node connection}}%
    #4}%
  \addto@pscode{grestore \pst@coor T \psrbrace repeat}%
  \leavevmode%
  \use@pscode%
  \endgroup%
  \ignorespaces}
%
\def\defineTColor{\@ifnextchar[{\defineTColor@i}{\defineTColor@i[]}}% hv
\def\defineTColor@i[#1]#2#3{%     transparency "Colors"
  \newpsstyle{#2}{%
     fillstyle=vlines,hatchcolor=#3,
     hatchwidth=0.1\pslinewidth,hatchsep=1\pslinewidth,#1%
  }%
}
%
\def\rmultiput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\rmultiput@i}{\rmultiput@i[]}}}% hv
\def\rmultiput@i[#1]{\begingroup\psset{#1}\rmultiput@ii}
\def\rmultiput@ii#1{\def\@rmultiputArg{#1}%
  \@ifnextchar({\rmultiput@iii}{\rmultiput@iii(\z@,\z@)}}
\def\rmultiput@iii(#1){%
  \pst@killglue%
  \if@star\rput*(#1){\@rmultiputArg}%
  \else\rput(#1){\@rmultiputArg}%
  \fi%
  \@ifnextchar({\rmultiput@iii}{\endgroup}%
}

%
%
\def\psscalebox#1{\pst@makebox{\@psscalebox{#1}}}
\def\@psscalebox#1{%
  \begingroup
  \pst@getscale{#1}\pst@tempa
  \let\pst@tempc\pst@tempg
  \let\pst@tempd\pst@temph
  \@@psscalebox
  \endgroup}
\def\@@psscalebox{%
  \leavevmode%
  \hbox{%
    \ifdim\pst@tempd\p@<\z@%
      \pst@dimg=\pst@tempd\ht\pst@hbox%
      \pst@dimh=\pst@tempd\dp\pst@hbox%
      \dp\pst@hbox=-\pst@dimg%
      \ht\pst@hbox=-\pst@dimh%
    \else%
      \ht\pst@hbox=\pst@tempd\ht\pst@hbox%
      \dp\pst@hbox=\pst@tempd\dp\pst@hbox%
    \fi%
    \pst@dima=\pst@tempc\wd\pst@hbox%
    \ifdim\pst@dima<\z@\kern-\pst@dima\fi%
    \pst@Verb{CP CP translate \pst@tempa \tx@NET}%
    \hbox to \z@{\box\pst@hbox\hss}%
    \pst@Verb{%
      CP CP translate
      1 \pst@tempc div 1 \pst@tempd div scale
      \tx@NET}%
    \ifdim\pst@dima>\z@\kern\pst@dima\fi}}
\pslongbox{Scalebox}{\psscalebox}
\def\psscaleboxto(#1,#2){\pst@makebox{\@psscaleboxto(#1,#2)}}
\def\@psscaleboxto(#1,#2){%
\begingroup
\pssetlength\pst@dima{#1}%
\pssetlength\pst@dimb{#2}%
\ifdim\pst@dima=\z@\else
\pst@divide{\pst@dima}{\wd\pst@hbox}\pst@tempc
\edef\pst@tempc{\pst@tempc\space}%
\fi
\ifdim\pst@dimb=\z@
\ifdim\pst@dima=\z@
\@pstrickserr{%
\string\psscaleboxto\space dimensions cannot both be zero}\@ehpa
\def\pst@tempa{}%
\def\pst@tempc{1 }%
\def\pst@tempd{1 }%
\else
\let\pst@tempd\pst@tempc
\fi
\else
\pst@dimc=\ht\pst@hbox
\advance\pst@dimc\dp\pst@hbox
\pst@divide{\pst@dimb}{\pst@dimc}\pst@tempd
\edef\pst@tempd{\pst@tempd\space}%
\ifdim\pst@dima=\z@ \let\pst@tempc\pst@tempd \fi
\fi
\edef\pst@tempa{\pst@tempc \pst@tempd scale }%
\@@psscalebox
\endgroup}
\pslongbox{Scaleboxto}{\psscaleboxto}
\def\tx@Rot{Rot }
\def\rotateleft{\pst@makebox{\@rotateleft\pst@hbox}}
\def\@rotateleft#1{%
\leavevmode\hbox{\hskip\ht#1\hskip\dp#1\vbox{\vskip\wd#1%
\pst@Verb{90 \tx@Rot}
\vbox to \z@{\vss\hbox to \z@{\box#1\hss}\vskip\z@}%
\pst@Verb{-90 \tx@Rot}}}}
\def\rotateright{\pst@makebox{\@rotateright\pst@hbox}}
\def\@rotateright#1{%
% ----------- hv begin 2004-05-07 ----------- patch 15
%    \hbox{%
  \leavevmode\hbox{%
% ----------- hv end 2004-05-07 ----------- patch 15
  \hskip\ht#1\hskip\dp#1\vbox{\vskip\wd#1%
  \pst@Verb{-90 \tx@Rot}
  \vbox to \z@{\hbox to \z@{\hss\box#1}\vss}%
  \pst@Verb{90 \tx@Rot}}}}
\def\rotatedown{\pst@makebox{\@rotatedown\pst@hbox}}
\def\@rotatedown#1{%
\hbox{\hskip\wd#1\vbox{\vskip\ht#1\vskip\dp#1%
\pst@Verb{180 \tx@Rot}%
\vbox to \z@{\hbox to \z@{\box#1\hss}\vss}%
\pst@Verb{-180 \tx@Rot}}}}
\pslongbox{Rotateleft}{\rotateleft}
\pslongbox{Rotateright}{\rotateright}
\pslongbox{Rotatedown}{\rotatedown}
\def\pst@starbox{%
\setbox\pst@hbox\hbox{\psframebox*[boxsep=false]{\unhbox\pst@hbox}}}
\def\pst@@makesmall#1{%
\setbox#1=\hbox to\z@{\hss\vbox to \z@{\vss\box#1\vss}\hss}}
\def\pst@@@makesmall#1{%
\pst@dimh=\psk@xref\wd#1%
\ifx\psk@yref\relax
\pst@dimg=\dp#1%
\else
\pst@dimg=\psk@yref\ht#1%
\advance\pst@dimg\psk@yref\dp#1%
\fi
\setbox#1=\hbox to\z@{%
\kern-\pst@dimh\vbox to\z@{\vss\box#1\kern-\pst@dimg}\hss}}
\define@key[psset]{}{ref}{\pst@expandafter\ref@ii{#1}\@empty,,\@nil}
\def\ref@ii#1#2,#3,#4\@nil{%
\def\psk@xref{.5}%
\def\psk@yref{.5}%
\let\pst@makesmall\pst@@@makesmall
\ifx\@empty#3\@empty
\@nameuse{getref@#1}%
\@nameuse{getref@#2}%
\else
\pst@checknum{#1#2}\psk@xref
\pst@checknum{#3}\psk@yref
\fi}
\def\getref@c{\let\pst@makesmall\pst@@makesmall}
\def\getref@t{\def\psk@yref{1}}
\def\getref@b{\def\psk@yref{0}}
\def\getref@B{\let\psk@yref\relax}
\def\getref@l{\def\psk@xref{0}}
\def\getref@r{\def\psk@xref{1}}
\define@key[psset]{}{rot}{%
  \pst@expandafter{\@ifnextchar*{\pstrot@iii}{\pstrot@ii}}{#1}\@nil}
  \def\pstrot@ii#1\@nil{%
    \def\next##1@#1=##2@##3\@nil{%
      \ifx\relax##2%
        \pst@getangle{#1}\psk@rot
      \else
        \def\psk@rot{##2}%
      \fi}%
    \expandafter\next\pst@rottable @#1=\relax @\@nil}
  \def\pstrot@iii#1#2\@nil{%
    \pstrot@ii#2\@nil
    \edef\psk@rot{\pst@rotlist \ifx\psk@rot\@empty\else\psk@rot add \fi}}
  \def\pst@rotlist{mark RAngle /a ED cleartomark a neg }
  \def\pst@rottable{%
    @0=%
    @U=%
    @L=90 %
    @D=180 %
    @R=-90 %
    @N=\pst@rotlist
    @W=\pst@rotlist 90 add %
    @S=\pst@rotlist 180 add %
    @E=\pst@rotlist 90 sub }
%
\def\tx@RotBegin{RotBegin }
\def\tx@RotEnd{RotEnd }
\def\pst@rotate#1#2{%
\ifx#1\@empty\else
\setbox#2=\hbox{\pst@Verb{#1 \tx@RotBegin}\box#2\pst@Verb{\tx@RotEnd}}%
\fi}
\def\psput@cartesian#1{%
\hbox to \z@{\kern\pst@dimg{\vbox to \z@{\vss\box#1\vskip\pst@dimh}\hss}}}
\def\psput@special#1{%
\hbox{%
\pst@Verb{{ \pst@coor } \tx@PutCoor \tx@PutBegin}%
\box#1%
\pst@Verb{\tx@PutEnd}}}
\def\tx@PutCoor{PutCoor }
\def\tx@PutBegin{PutBegin }
\def\tx@PutEnd{PutEnd }
\def\rput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\rput@i}{\rput@ii}}}
\def\rput@i[#1]{\addto@par{ref={#1}}\rput@ii}
\def\rput@ii{\@ifnextchar({\rput@iv}{\rput@iii}}
\def\rput@iii#1{\addto@par{rot={#1}}\@ifnextchar({\rput@iv}{\rput@iv(\z@,\z@)}}
\def\rput@iv(#1){\pst@killglue\pst@makebox{\rput@v{#1}}}
\def\rput@v#1{%
  \begingroup
  \use@par
  \if@star\pst@starbox\fi
  \pst@makesmall\pst@hbox
  \pst@rotate\psk@rot\pst@hbox
  \psput@{#1}\pst@hbox
  \endgroup
  \ignorespaces}
\def\multirput{%
\def\pst@par{}%
\pst@ifstar{\@ifnextchar[{\multirput@i}{\multirput@ii}}}
\def\multirput@i[#1]{\addto@par{ref={#1}}\multirput@ii}
\def\multirput@ii{\@ifnextchar({\multirput@iv}{\multirput@iii}}
\def\multirput@iii#1{\addto@par{rot={#1}}\multirput@iv}
\def\multirput@iv(#1){%
\@ifnextchar({\multirput@v(#1)}{\multirput@v(\z@,\z@)(#1)}}
\def\multirput@v(#1,#2)(#3,#4)#5{%
\pst@makebox{\multirput@vi(#1,#2)(#3,#4){#5}}}
\def\multirput@vi(#1,#2)(#3,#4)#5{%
\begingroup
\use@par
\if@star\pst@starbox\fi
\pst@makesmall\pst@hbox
\pst@rotate\psk@rot\pst@hbox
\pssetxlength\pst@dima{#1}%
\pssetylength\pst@dimb{#2}%
\pssetxlength\pst@dimc{#3}%
\pssetylength\pst@dimd{#4}%
\pst@cntg=#5\relax
\pst@cnth=\@ne
\leavevmode
\loop
\vbox to \z@{%
\vss
\hbox to \z@{\kern\pst@dima\copy\pst@hbox\hss}%
\vskip\pst@dimb}%
\ifnum\pst@cntg>\pst@cnth
\advance\pst@dima\pst@dimc
\advance\pst@dimb\pst@dimd
\advance\pst@cnth\@ne
\repeat
\endgroup
\ignorespaces}
\newif\if@fixedradius
\def\cput{\pst@object{cput}}
\def\cput@i{\@fixedradiusfalse\cput@ii}
\def\cput@ii{\pst@killglue\@ifnextchar({\cput@iv}{\cput@iii}}
\def\cput@iii#1{%
\addto@par{rot={#1}}%
\@ifnextchar({\cput@iv}{\cput@iv(\z@,\z@)}}
\def\cput@iv(#1){\pst@makebox{\cput@v{#1}}}
\def\cput@v#1{%
\begingroup
\use@par
\setbox\pst@hbox=\hbox{%
\psboxsepfalse
\if@fixedradius\psCirclebox@ii\else\pscirclebox@ii\fi}%
\pst@@makesmall\pst@hbox
\pst@rotate\psk@rot\pst@hbox
\psput@{#1}\pst@hbox
\endgroup
\ignorespaces}
\def\Cput{\pst@object{Cput}}
\def\Cput@i{\@fixedradiustrue\cput@ii}
\newdimen\pslabelsep
\define@key[psset]{}{labelsep}{\pssetlength\pslabelsep{#1}}
\define@key[psset]{}{refangle}{\pst@expandafter\refangle@ii{#1}\@nil}
\def\refangle@ii#1\@nil{%
  \def\next##1@#1=##2"##3@##4\@nil{%
    \ifx\relax##2%
      \pst@getangle{#1}\psk@refangle
      \def\psk@uputref{}%
    \else
      \def\psk@refangle{##2 }%
      \def\psk@uputref{##3}%
    \fi}%
  \expandafter\next\pst@refangletable @#1=\relax"@\@nil}
  \def\pst@refangletable{%
    @r=0"20%
    @u=90"02%
    @l=180"10%
    @d=-90"01%
    @ur=45"22%
    @ul=135"12%
    @dr=-135"21%
    @dl=-45"11}
% DG/SR modification begin - Mar. 24, 1999 - Patch 10
%\def\uput{\def\pst@par{}\@ifnextchar[{\uput@ii}{\uput@i}}
\def\uput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\uput@ii}{\uput@i}}}
% DG/SR modification end
\def\uput@i#1{\addto@par{labelsep=#1}\uput@ii}
\def\uput@ii[#1]{%
\addto@par{refangle={#1}}%
\@ifnextchar({\uput@iv}{\uput@iii}}
\def\uput@iii#1{%
\addto@par{rot={#1}}%
\@ifnextchar({\uput@iv}{\uput@iv(\z@,\z@)}}
\def\uput@iv(#1){\pst@killglue\pst@makebox{\uput@v{#1}}}
\def\uput@v#1{%
\begingroup
\use@par
\if@star\pst@starbox\fi
\uput@vi
\psput@{#1}\pst@hbox
\endgroup
\ignorespaces}
\def\uput@vi{%
\ifx\psk@uputref\@empty
\uput@vii\tx@UUput{}%
\else
\ifx\psk@rot\@empty
\expandafter\uput@viii\psk@uputref
\else
\uput@vii\tx@UUput{}%
\fi
\fi}
\def\uput@vii#1#2{%
\edef\pst@coor{%
\pst@number\pslabelsep
#2%
\pst@number{\wd\pst@hbox}%
\pst@number{\ht\pst@hbox}%
\pst@number{\dp\pst@hbox}%
\psk@refangle\space \ifx\psk@rot\@empty\else\psk@rot\space sub \fi
\tx@Uput #1}%
\setbox\pst@hbox=\hbox to\z@{\hss\vbox to\z@{\vss\box\pst@hbox\vss}\hss}%
\setbox\pst@hbox=\psput@special\pst@hbox
\ifx\psk@rot\@empty\else\pst@rotate\psk@rot\pst@hbox\fi}
\def\uput@viii#1#2{%
\ifnum#1>\z@\ifnum#2>\z@\pslabelsep=.707\pslabelsep\fi\fi
\setbox\pst@hbox=\vbox to\z@{%
\ifnum#2=1 \vskip\pslabelsep\else\vss\fi
\hbox to\z@{%
\ifnum#1=2 \hskip\pslabelsep\else\hss\fi
\box\pst@hbox
\ifnum#1=1 \hskip\pslabelsep\else\hss\fi}%
\ifnum#2=2 \vskip\pslabelsep\else\vss\fi}}
\def\tx@Uput{Uput }
\def\tx@UUput{UUput }
\def\Rput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\Rput@ii}{\Rput@i}}}
\def\Rput@i#1{\addto@par{labelsep=#1}\Rput@ii}
\def\Rput@ii[#1]{\addto@par{ref={#1}}\@ifnextchar({\Rput@iv}{\Rput@iii}}
\def\Rput@iii#1{\addto@par{rot={#1}}\@ifnextchar({\Rput@iv}{\Rput@iv(\z@,\z@)}}
\def\Rput@iv(#1){\pst@killglue\pst@makebox{\Rput@v{#1}}}
\def\Rput@v#1{%
\begingroup
\use@par
\if@star\pst@starbox\fi
\Rput@vi
\pst@makesmall\pst@hbox
\pst@rotate\psk@rot\pst@hbox
\psput@{#1}\pst@hbox
\endgroup
\ignorespaces}
\def\Rput@vi{%
\pst@dimg=\dp\pst@hbox
\advance\pst@dimg\pslabelsep
\dp\pst@hbox=\pst@dimg
\pst@dimg=\ht\pst@hbox
\advance\pst@dimg\pslabelsep
\ht\pst@hbox=\pst@dimg
\setbox\pst@hbox\hbox{\kern\pslabelsep\box\pst@hbox\kern\pslabelsep}}%
\def\oldpsput{%
\def\pst@par{}\pst@ifstar{\@ifnextchar[{\oldpsput@i}{\oldpsput@ii}}}
\def\oldpsput@i[#1]{\addto@par{ref={#1}}\oldpsput@ii}
\def\oldpsput@ii{\@ifnextchar<{\oldpsput@iii}{\oldpsput@iv}}
\def\oldpsput@iii<#1>{\rput@iii{#1}}
\def\OldPsput{\let\psput\oldpsput}
\def\NewPsput{\let\psput\rput}
%
\define@key[psset]{}{shift}{\def\psk@shift{#1}}
\newif\ifPst@frame
\define@key[psset]{}{frame}{\@nameuse{Pst@frame#1}}
\newpsstyle{psframestyle}{linewidth=0.1pt,linestyle=dashed}
%
\def\pspicture{\pst@object{pstpicture}}
\def\pstpicture@i#1(#2,#3){\@ifnextchar(%
  {\pstpicture@ii(#2,#3)}%
  {\pstpicture@ii(0,0)(#2,#3)}}
%
\def\pstpicture@ii(#1,#2)(#3,#4){%
  \begin@ClosedObj
  \pssetxlength\pst@dima{#1}%
  \pssetylength\pst@dimb{#2}%
  \pssetxlength\pst@dimc{#3}%
  \pssetylength\pst@dimd{#4}%
  \ifdim\pst@dima>\pst@dimc
    \pst@dimg=\pst@dima
    \pst@dima=\pst@dimc
    \pst@dimc=\pst@dimg
  \fi
  \ifdim\pst@dimb>\pst@dimd
    \pst@dimg=\pst@dimb
    \pst@dimb=\pst@dimd
    \pst@dimd=\pst@dimg
  \fi
  \setbox\pst@hbox=\hbox\bgroup
  \begingroup\KillGlue
  \@ifundefined{@latexerr}{}{\let\unitlength\psunit}%
  \edef\pic@coor{(#1,#2)(#1,#2)(#3,#4)}%
%  \ignorespaces%
}
\def\pic@coor{(0,0)(0,0)(10,10)}
\def\endpspicture{%
  \pst@killglue%
  \endgroup%
  \egroup%
  \ifdim\wd\pst@hbox=\z@\else%
%\@pstrickserr{Extraneous space in the pspicture environment}%
%{Type \space <return> \space to procede.}%
  \fi%
  \ht\pst@hbox=\pst@dimd%
  \dp\pst@hbox=-\pst@dimb%
  \setbox\pst@hbox=\hbox{%
    \kern-\pst@dima
    \ifx\psk@shift\@empty\else%
      \advance\pst@dimd-\pst@dimb%
      \pst@dimd=\psk@shift\pst@dimd%
      \advance\pst@dimd\pst@dimb%
      \lower\pst@dimd%
    \fi%
    \box\pst@hbox%
    \kern\pst@dimc%
  }%
  \if@star\setbox\pst@hbox=\hbox{\clipbox@@\z@}\fi%
  \leavevmode%
  \ifPst@frame\psframebox[style=psframestyle]{\box\pst@hbox}%
  \else\box\pst@hbox\fi%
  \end@ClosedObj%
}
%
\@namedef{pspicture*}{\pspicture*}
\@namedef{endpspicture*}{\endpspicture}
%
\def\tx@BeginOL{BeginOL }
\def\tx@InitOL{InitOL }
\def\pst@initoverlay#1{\pst@Verb{\tx@InitOL /TheOL (#1) def}}
\def\AltOverlayMode{%
  \def\pst@initoverlay##1{%
  \pst@Verb{%
    \tx@InitOL
    /Visible { initclip } def
    /Invisible {
      CP newpath OLUnit itransform moveto clip newpath moveto
    } def
    /TheOL (##1) def}}}
\def\pst@overlay#1{%
  \edef\curr@overlay{#1}%
  \pst@Verb{(#1) BOL}%
  \aftergroup\pst@endoverlay}
\def\pst@endoverlay{%
  \pst@Verb{(\curr@overlay) BOL}}
\def\curr@overlay{all}
\newbox\theoverlaybox
\def\overlaybox{%
  \global\setbox\theoverlaybox=\hbox\bgroup
  \begingroup
  \let\psoverlay\pst@overlay
  \def\overlaybox{%
    \@pstrickserr{Overlays cannot be nested}\@eha}%
  \def\putoverlaybox{%
    \@pstrickserr{You must end the overlay box before using \string\putoverlaybox}}%
  \psoverlay{main}%
  \ignorespaces}
\def\endoverlaybox{\endgroup\egroup}
\def\putoverlaybox#1{%
    \hbox{\pst@initoverlay{#1}\copy\theoverlaybox}}
\def\psoverlay{\@pstrickserr{\string\psoverlay\space can only be used after \string\overlaybox}}
%
\define@key[psset]{}{randomPoints}{\def\psk@randomPoints{#1}}
\newif\ifPst@randomColor
\define@key[psset]{}{color}[true]{\@nameuse{Pst@randomColor#1}}
%
\def\psRandom{\pst@object{psRandom}}%  hv  2004-11-12
\def\psRandom@i{\@ifnextchar({\psRandom@ii}{\psRandom@iii(0,0)(1,1)}}
\def\psRandom@ii(#1){\@ifnextchar({\psRandom@iii(#1)}{\psRandom@iii(0,0)(#1)}}
\def\psRandom@iii(#1)(#2)#3{%
  \def\pst@tempa{#3}%
  \ifx\pst@tempa\pst@empty\psclip{\psframe(#2)}\else\psclip{#3}\fi
  \pst@getcoor{#1}\pst@tempa
  \pst@getcoor{#2}\pst@tempb
  \begin@SpecialObj
  \addto@pscode{
    \pst@tempa\space /yMin exch def
    /xMin exch def
    \pst@tempb\space /yMax exch def
    /xMax exch def
    /dy yMax yMin sub def
    /dx xMax xMin sub def
    rrand srand                 % initializes the random generator
    /getRandReal { rand 2147483647 div } def
    \psk@dotsize % defines /DS ... def
    \@nameuse{psds@\psk@dotstyle}
    \psk@randomPoints {
     \ifPst@randomColor getRandReal getRandReal getRandReal setrgbcolor \fi
     getRandReal dx mul xMin add
     getRandReal dy mul yMin add
     Dot
     \ifx\psk@fillstyle\psfs@solid fill \fi stroke
    } repeat
  }%
  \end@SpecialObj
  \endpsclip
  \ignorespaces
}
%
\def\resetPSTOptions{% hv
  \psset{%
       shift=0,frame=false,%framestyle=dashed,%
       PstDebug=0,%
       swapaxes=false,showpoints=false,border=0pt,bordercolor=white,%
       doubleline=false,doublesep=1.25\pslinewidth,doublecolor=white,%
       shadow=false,shadowsize=3pt,shadowangle=-45,shadowcolor=darkgray,%
       linewidth=.8pt,linecolor=black,
       maxdashes=11,dash=5pt 3pt 0pt 0pt,dashadjust=true,% black white black white
       hatchangle=45,hatchcolor=black,hatchsep=4pt,hatchwidth=.8pt,%
       fillcolor=white,linestyle=solid,dotsep=3pt,%
       arrowinset=.4,arrowlength=1.4,arrowsize=1.5pt 2,%
       arrowscale=1,fillstyle=none,%
       ArrowFill=true,
       rbracketlength=0.15,bracketlength=0.15,tbarsize=2pt 5,
       hooklength=3mm,hookwidth=1mm,
       nArrows=2,
       ArrowInside={},
       ArrowInsidePos=0.5,
       ArrowInsideNo=1,ArrowInsideOffset=0,
       arrows=-,
       liftpen=0,
       linetype=2,% otherwise there is a problem when using e.g.
       gangle=0,
       curvature=1 .1 0,
       dotsize=2pt 2,
       dotangle=0,
       dotscale=1,
       dotstyle=*,
       dimen=outer,cornersize=relative,framearc=0,linearc=0pt,
       gridlabelcolor=black,gridlabels=10pt,subgriddiv=5,subgriddots=0,%
       subgridcolor=gray,subgridwidth=.4pt,gridcolor=black,griddots=0,%
       gridwidth=.8pt,%
       boxsep=true,framesep=3pt,
       trimode=U,
       arcsep=0,
       radius=.25cm,
       rot=0,ref=c,
       labelsep=5pt,
       refangle=0,%
       randomPoints=1000,color=false%
}}
\resetPSTOptions%
%
\ifx\pstcustomize\relax \input pstricks.con \fi
\catcode`\@=\PstAtCode\relax
%    \end{macrocode}
% \subsubsection{Former pst-plot.tex (adapted)}
%    \begin{macrocode}
\csname PSTplotLoaded\endcsname
%    \end{macrocode}
% \begin{macro}{\PSTplotLoaded}
% All pstricks packages define a \texttt{\bs PST\emph{package}Loaded}
% macro.
%    \begin{macrocode}
\let\PSTplotLoaded\endinput
%    \end{macrocode}
% \end{macro}
% Load |pstricks2.tex|, |multido.tex| and |pst-xkey.tex|
% that are riquired packages and avoid to load them twice.
%    \begin{macrocode}
\ifx\PSTricksLoaded\endinput\else\input pstricks \fi
\ifx\MultidoLoaded\endinput\else\input multido \fi
\ifx\PSTXKeyLoaded\endinput\else\input pst-xkey \fi
%    \end{macrocode}
% \begin{macro}{\PstAtCode}
% Adjust some catcodes to safely define macros.
%    \begin{macrocode}
\edef\PstAtCode{\the\catcode`\@}
\catcode`\@=11\relax
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\def\fileversion{2.00}
\def\filedate{2004/11/23}
\message{ v\fileversion, \filedate}
\message{`pst-plot2' v\fileversion, \filedate\space (tvz,hv)}

\SpecialCoor

%\pstheader{pst-eqdf.pro}%

%    \end{macrocode}
% \paragraph{Common macros for data and mathematical plottings}
%    \begin{macrocode}
\define@key[psset]{}{plotstyle}{%
  \@ifundefined{beginplot@#1}%
    {\@pstrickserr{Plot style `#1' not defined}\@eha}%
%    \end{macrocode}
% \begin{macro}{\psk@plotstyle}
%    \begin{macrocode}
    {\edef\psk@plotstyle{#1}}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}
\define@key[psset]{}{plotpoints}{%
  \pst@cntg=#1\relax
  \ifnum\pst@cntg<2
    \@pstrickserr{plotpoints parameter must be at least 2}\@ehpa
  \else
    \advance\pst@cntg\m@ne
%    \end{macrocode}
% \begin{macro}{\psk@plotpoints}
%    \begin{macrocode}
    \edef\psk@plotpoints{\the\pst@cntg\space}%
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@line}
%    \begin{macrocode}
\def\beginplot@line{\begin@OpenObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@line}
%    \begin{macrocode}
\def\endplot@line{\psline@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@polygon}
%    \begin{macrocode}
\def\beginplot@polygon{\begin@ClosedObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@polygon}
%    \begin{macrocode}
\def\endplot@polygon{\pspolygon@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@curve}
%    \begin{macrocode}
\def\beginplot@curve{\begin@OpenObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@curve}
%    \begin{macrocode}
\def\endplot@curve{\pscurve@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@ecurve}
%    \begin{macrocode}
\def\beginplot@ecurve{\begin@OpenObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@ecurve}
%    \begin{macrocode}
\def\endplot@ecurve{\psecurve@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@ccurve}
%    \begin{macrocode}
\def\beginplot@ccurve{\begin@ClosedObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@ccurve}
%    \begin{macrocode}
\def\endplot@ccurve{\psccurve@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@dots}
%    \begin{macrocode}
\def\beginplot@dots{\begin@SpecialObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@dots}
%    \begin{macrocode}
\def\endplot@dots{\psdots@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@bezier}
%    \begin{macrocode}
\def\beginplot@bezier{\begin@OpenObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@bezier}
%    \begin{macrocode}
\def\endplot@bezier{\psbezier@ii}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginplot@cbezier}
%    \begin{macrocode}
\def\beginplot@cbezier{\begin@ClosedObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endplot@cbezier}
%    \begin{macrocode}
\def\endplot@cbezier{\pscbezier@ii}
%    \end{macrocode}
% \end{macro}
%
% For quick plots, define:
%   |\beginqp@<foo>|   : What to do to first point (PS code only).
%   |\doqp@<foo>|      : What to do to subsequent points (PS code only).
%   |\endqp@<foo>|     : How to end plot.
%   |\testqp@<foo>|    : Set |\@psttrue| if OK to use quick plot.
% \begin{macro}{\beginqp@line}
%    \begin{macrocode}
\def\beginqp@line{\pst@oplineto}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\doqp@line}
%    \begin{macrocode}
\def\doqp@line{L }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endqp@line}
%    \begin{macrocode}
\def\endqp@line{\end@OpenObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\testqp@line}
%    \begin{macrocode}
\def\testqp@line{%
  \ifdim\pslinearc>\z@
  \else
    \ifshowpoints
    \else
      \ifx\psk@arrowA\@empty
        \ifx\psk@arrowB\@empty
          \@psttrue
        \fi
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginqp@polygon}
%    \begin{macrocode}
\def\beginqp@polygon{moveto }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\doqp@polygon}
%    \begin{macrocode}
\def\doqp@polygon{L }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endqp@polygon}
%    \begin{macrocode}
\def\endqp@polygon{%
  \addto@pscode{closepath}%
  \end@ClosedObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\testqp@polygon}
%    \begin{macrocode}
\def\testqp@polygon{%
  \ifdim\pslinearc>\z@\else
    \ifshowpoints\else
      \@psttrue
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginqp@dots}
%    \begin{macrocode}
\def\beginqp@dots{%
  \psk@dotsize
  \@nameuse{psds@\psk@dotstyle}
  Dot }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\doqp@dots}
%    \begin{macrocode}
\def\doqp@dots{Dot }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endqp@dots}
%    \begin{macrocode}
\def\endqp@dots{\end@SpecialObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\testqp@dots}
%    \begin{macrocode}
\def\testqp@dots{\@psttrue}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginqp@bezier}
%    \begin{macrocode}
\def\beginqp@bezier{/n 0 def \pst@oplineto}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\doqp@bezier}
%    \begin{macrocode}
\def\doqp@bezier{/n n 1 add def n 3 mod 0 eq { curveto } if }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endqp@bezier}
%    \begin{macrocode}
\def\endqp@bezier{%
  \addto@pscode{n 3 mod { pop pop } repeat}
  \end@OpenObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\testqp@bezier}
%    \begin{macrocode}
\def\testqp@bezier{%
  \ifshowpoints\else
    \ifx\psk@arrowA\@empty
      \ifx\psk@arrowB\@empty
        \@psttrue
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\beginqp@cbezier}
%    \begin{macrocode}
\def\beginqp@cbezier{/n 0 def moveto }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\doqp@cbezier}
%    \begin{macrocode}
\def\doqp@cbezier{\doqp@bezier}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endqp@cbezier}
%    \begin{macrocode}
\def\endqp@cbezier{%
  \addto@pscode{n 3 mod { pop pop } repeat closepath}
  \end@ClosedObj}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\testqp@cbezier}
%    \begin{macrocode}
\def\testqp@cbezier{\ifshowpoints\else\@psttrue\fi}
%    \end{macrocode}
% \end{macro}
% \paragraph{Data plotting}
% \begin{macro}{\psk@nStep}
%    \begin{macrocode}
\define@key[psset]{}{nStep}{\edef\psk@nStep{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@nStart}
%    \begin{macrocode}
\define@key[psset]{}{nStart}{\edef\psk@nStart{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@nEnd}
%    \begin{macrocode}
\define@key[psset]{}{nEnd}{\edef\psk@nEnd{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@xStep}
%    \begin{macrocode}
\define@key[psset]{}{xStep}{\edef\psk@xStep{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@yStep}
%    \begin{macrocode}
\define@key[psset]{}{yStep}{\edef\psk@yStep{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@xStart}
%    \begin{macrocode}
\define@key[psset]{}{xStart}{\edef\psk@xStart{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@xEnd}
%    \begin{macrocode}
\define@key[psset]{}{xEnd}{\edef\psk@xEnd{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@yStart}
%    \begin{macrocode}
\define@key[psset]{}{yStart}{\edef\psk@yStart{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@yEnd}
%    \begin{macrocode}
\define@key[psset]{}{yEnd}{\edef\psk@yEnd{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@plotNo}
%    \begin{macrocode}
\define@key[psset]{}{plotNo}{\edef\psk@plotNo{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@plotNoMax}
%    \begin{macrocode}
\define@key[psset]{}{plotNoMax}{\edef\psk@plotNoMax{#1}}
%    \end{macrocode}
% \end{macro}
% Using lists of data is optimized for |\dataplot| and |\fileplot|
% Here is the tricky part. As each line is read from file,
% we want to ignore trailing delimiters, and convert arbitrary
% strings of non-trailing delimiters to D.
% We end up with
%   D x1 D y1 D x2 D y2 ... D xn D yn
%    \begin{macrocode}
\begingroup
  \catcode`\{=13
  \catcode`\}=13
  \catcode`\(=13
  \catcode`\)=13
  \catcode`\,=13
  \catcode`\ =13
  \catcode`\_=13
  \catcode`\^^M=13
%    \end{macrocode}
% |!| stands for the opening curly brace |{| and |*| stands
% for the closing curly brace |}|.
%    \begin{macrocode}
  \catcode`\!=1
  \catcode`\*=2
%    \end{macrocode}
% \begin{macro}{\pst@datadelimiters}
%    \begin{macrocode}
  \gdef\pst@datadelimiters!%
    \catcode`\{=13
    \catcode`\}=13
    \catcode`\(=13
    \catcode`\)=13
    \catcode`\,=13
    \catcode`\ =13
    \catcode`\^^M=13
%    \end{macrocode}
% Define |,| so that it is replaced by | D |.
%    \begin{macrocode}
    \def,##1!%
      \ifcat\noexpand,\noexpand##1
        \expandafter##1
      \else
        \space D\space##1
      \fi*%
    \let(,\let),\let{,\let},\let ,\let^^M,\let_\@empty*
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\endgroup
%    \end{macrocode}
% \begin{macro}{\savedata}
%    \begin{macrocode}
\def\savedata#1{\begingroup\pst@datadelimiters\savedata@i{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\readdata}
%    \begin{macrocode}
\def\readdata{\@ifnextchar[{\readdata@i}{\readdata@i[]}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\readdata@i}
%    \begin{macrocode}
\def\readdata@i[#1]#2#3{%
%    \end{macrocode}
%We open a group so that |\psset| is local
%    \begin{macrocode}
  \bgroup
    \def\pst@tempa{#1}%
    \ifx\pst@tempa\@empty\else\psset{#1}\fi
    \openin1=#3
%    \end{macrocode}
%We open a group so that |\catcode| changes are local
%    \begin{macrocode}
    \begingroup
      \edef\pst@tempg{}%
      \ifeof1
        \@pstrickserr{Data file `#3' not found.}\@ehpa
      \else
        \pst@datadelimiters
        \catcode`\[=1
        \catcode`\]=2
        \global\linecnt=\psk@nStep
        \readdata@ii%
      \fi
    \endgroup
    \global\let#2\pst@tempg
    \global\let\pst@tempg\relax
    \ignorespaces
  \egroup
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\newcount\linecnt
\begingroup
  \catcode`\,=13
  \catcode`\_=13
%    \end{macrocode}
% \begin{macro}{\savedata@i}
%    \begin{macrocode}
  \gdef\savedata@i#1[#2]{%
    \xdef\pst@tempg{#2_}%
    \endgroup
    \let#1\pst@tempg
    \global\let\pst@tempg\relax
    \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\readdata@ii}
%    \begin{macrocode}
  \gdef\readdata@ii{%
    \read1 to \pst@tempa
    \ifnum\linecnt=\psk@nStep
      \global\linecnt\z@
      \expandafter\readdata@iii\pst@tempa_\@nil
    \fi
    \global\advance\linecnt by 1
    \ifeof1\else\expandafter\readdata@ii\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@readfile}
%    \begin{macrocode}
  \gdef\pst@@readfile#1#2\@nil{\addto@pscode{,#1#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\readdata@iii}
%    \begin{macrocode}
  \gdef\readdata@iii#1#2\@nil{\xdef\pst@tempg{\pst@tempg,#1#2}}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\endgroup
%    \end{macrocode}
% \begin{macro}{\pst@readfile}
%    \begin{macrocode}
\def\pst@readfile#1{{\let\readdata@iii\pst@@readfile\readdata\pst@tempg{#1}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@altreadfile}
%    \begin{macrocode}
\def\pst@altreadfile#1{%
  \openin1=#1
  \ifeof1
    \@pstrickserr{Data file `#1' not found.}\@ehpa
  \else
    \catcode`\{=10
    \catcode`\}=10
    \catcode`\(=10
    \catcode`\)=10
    \catcode`\,=10
    \catcode`\^^M=10
    \catcode`\[=1
    \catcode`\]=2
    \pst@@altreadfile
  \fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@altreadfile}
%    \begin{macrocode}
\def\pst@@altreadfile{%
  \read1 to \pst@tempg
  \expandafter\pst@@@altreadfile\pst@tempg\@empty\@nil
  \ifeof1\else\expandafter\pst@@@altreadfile\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pst@@@altreadfile}
%    \begin{macrocode}
\def\pst@@@altreadfile#1#2\@nil{\addto@pscode{#1#2}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\dataplot}
%    \begin{macrocode}
\def\dataplot{\def\pst@par{}\pst@object{dataplot}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\dataplot@i}
%|\dataplot@i| takes one argument that must expand to something like
%\verb*| D x1 D y1 D x2 D y2 D x3 D y3 D|.
%    \begin{macrocode}
\def\dataplot@i#1{%
  \pst@killglue
  \begingroup
    \use@par
    \@pstfalse
    \@nameuse{testqp@\psk@plotstyle}%
    \if@pst
      \dataplot@ii{\addto@pscode{#1}}%
    \else
      \listplot@ii{\addto@pscode{#1}}%
    \fi
  \endgroup
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\dataplot@ii}
%    \begin{macrocode}
\def\dataplot@ii#1{%
  \@nameuse{beginplot@\psk@plotstyle}%
    \addto@pscode{%
      /Dx { \pst@number\psxunit mul /D { Dy } def } def
      /Dy { \pst@number\psyunit mul Do /D { Dx } def } def
      /D { /D { Dx } def } def
      /Do {
        \@nameuse{beginqp@\psk@plotstyle}%
        /Do { \@nameuse{doqp@\psk@plotstyle}} def
      } def}%
    #1%
    \addto@pscode{D}%
  \@nameuse{endqp@\psk@plotstyle}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fileplot}
%    \begin{macrocode}
\def\fileplot{\def\pst@par{}\pst@object{fileplot}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\fileplot@i}
%    \begin{macrocode}
\def\fileplot@i#1{%
  \pst@killglue
  \begingroup
    \use@par
    \@pstfalse
    \@nameuse{testqp@\psk@plotstyle}%
    \if@pst
      \dataplot@ii{\pst@readfile{#1}}%
    \else
      \listplot@ii{\pst@altreadfile{#1}}%
    \fi
  \endgroup
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\pstScalePoints}
%    \begin{macrocode}
\def\pstScalePoints(#1,#2)#3#4{%
%  xScale | yScale | xOperator | yOperator
% the operators can be any Postscript code
  \pst@def{ScalePoints}<%
    /y ED /x ED
    counttomark dup dup cvi eq not { exch pop } if
    /m exch def /n m 2 div cvi def
    n {
      #4\space y mul #2\space mul m 1 roll
      #3\space x mul #1\space mul m 1 roll
      /m m 2 sub
      def } repeat>
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
%\pstScalePoints(1,1){}{}% the default -> no special operators
%
\pst@def{ScalePoints}<%
  /y ED /x ED
  counttomark dup dup cvi eq not { exch pop } if
  /m exch def /n m 2 div cvi def
  n { y mul m 1 roll x mul m 1 roll /m m 2 sub def } repeat>

\pst@def{PreparePoints}<{%
  counttomark /m exch def
  /n m \psk@plotNoMax\space 1 add div cvi def
  \psk@plotNoMax\space 1 gt {% multiple data files?
    n {
      \psk@plotNoMax\space \psk@plotNo\space 1 sub neg roll % x yNo y y y ...
      \psk@plotNoMax\space 1 sub { pop } repeat % x yNo
      /m m \psk@plotNoMax\space 1 sub sub def
      m 2 roll
    } repeat
  } if % no multiple data files
% counttomark /m exch def
% /n m 2 div cvi def
  /xMax -99999 def /yMax -99999 def
  /xP 0 def /yP 0 def
  m copy
  n {
    /y exch def /x exch def
    xMax x lt { /xMax x def } if
    yMax y lt {/yMax y def } if
    xP x gt { /xP x def } if
    yP y gt { /yP y def } if
  } repeat
% m 2 roll
  \psk@xStep\space 0 gt \psk@yStep\space 0 gt or (\psk@xStart) length 0 gt or
  (\psk@yStart) length 0 gt or (\psk@xEnd) length 0 gt or (\psk@yEnd) length 0 gt or {
%
    (\psk@xStart) length 0 gt {\psk@xStart\space }{ xP } ifelse /xStart exch def
    (\psk@yStart) length 0 gt {\psk@yStart\space }{ yP } ifelse /yStart exch def
    (\psk@xEnd) length 0 gt { \psk@xEnd\space }{ xMax } ifelse /xEnd exch def
    (\psk@yEnd) length 0 gt { \psk@yEnd\space }{ yMax } ifelse /yEnd exch def
    n {
      m -2 roll
      2 copy /yVal exch def /xVal exch def
      xVal xP ge
      yVal yP ge and
      xVal xEnd le and
      yVal yEnd le and
      xVal xStart ge and
      yVal yStart ge and {
        /xP xP \psk@xStep\space add def
        /yP yP \psk@yStep\space add def
      }{%
        pop pop
        /m m 2 sub def
      } ifelse
    } repeat
  }{%
    /ncount 0 def
    (\psk@nEnd) length 0 gt { \psk@nEnd\space }{ m } ifelse
    /nEnd exch def
    n {
      m -2 roll
      \psk@nStep\space 1 gt {
        ncount \psk@nStart\space sub \psk@nStep\space mod 0 eq }{ true } ifelse
        ncount nEnd le and
        ncount \psk@nStart\space ge and not {
          pop pop
          /m m 2 sub def
        } if
        /ncount ncount 1 add def
      } repeat
  } ifelse
}>
%
%    \end{macrocode}
% \begin{macro}{\listplot}
%    \begin{macrocode}
\def\listplot{\def\pst@par{}\pst@object{listplot}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\listplot@i}
%    \begin{macrocode}
\def\listplot@i#1{\listplot@ii{\addto@pscode{#1}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\listplot@ii}
%    \begin{macrocode}
\def\listplot@ii#1{%
  \@nameuse{beginplot@\psk@plotstyle}%
  \addto@pscode{/D {} def mark}%
  #1%
  \addto@pscode{%
    \tx@PreparePoints
    \pst@number\psxunit
    \pst@number\psyunit
    \tx@ScalePoints%
  }%
  \@nameuse{endplot@\psk@plotstyle}%
}
%    \end{macrocode}
% \end{macro}
% \paragraph{Mathematical function plotting}
%    \begin{macrocode}
\define@key[psset]{}{method}{\edef\psk@method{#1}}%
\define@key[psset]{}{whichabs}{\edef\psk@whichabs{#1}}%
\define@key[psset]{}{whichord}{\edef\psk@whichord{#1}}%
\define@key[psset]{}{plotfuncx}{\edef\psk@plotfuncx{#1}}%
\define@key[psset]{}{plotfuncy}{\edef\psk@plotfuncy{#1}}%
\define@key[psset]{}{expression}{\edef\psk@expression{#1}}%
\define@key[psset]{}{VarStep}{\edef\psk@VarStep{#1}}%

\newif\ifPst@buildvector%
\define@key[psset]{}{buildvector}[true]{\@nameuse{Pst@buildvector#1}}%

\def\@rkiv{rk4}%
\def\@adams{adams}%
\def\@undef{undef}%
\def\@default{default}%

% none= 0 (postfix) , TeX=1 (conversion by TeX), PS=-1 (conversion by PostScript)
\define@key[psset]{}{infix}{\pst@expandafter\pstinfix@i{#1}\@nil}
\def\pstinfix@i#1#2\@nil{%
  \ifx#1n\let\psk@infix\z@\else
    \ifx#1T\let\psk@infix\@ne\else
      \ifx#1P\let\psk@infix\m@ne\else
        \@pstrickserr{Bad infix modus: `#1#2'}\@ehpa
  \fi\fi\fi}
%
\def\psplotinit#1{\xdef\psplot@init{#1 }}
\def\psplot@init{}
%
%    \end{macrocode}
% \begin{macro}{\psplot}
%    \begin{macrocode}
\def\psplot{\def\pst@par{}\pst@object{psplot}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psplot@i}
%    \begin{macrocode}
\def\psplot@i#1#2#3{%
  \pst@killglue
  \begingroup
    \use@par
    \@nameuse{beginplot@\psk@plotstyle}%
    \addto@pscode{%
      \psplot@init
      /x #1 def
      /x1 #2 def
      /dx x1 x sub \psk@plotpoints div def
      /F@pstplot \ifnum\psk@infix<\z@\space (#3) tx@EqdfDict begin AlgParser end cvx
                 \else { #3 } \fi  def
      /xy {
        x \pst@number\psxunit mul F@pstplot \pst@number\psyunit mul
      } def}%
    \gdef\psplot@init{}%
    \@pstfalse
    \@nameuse{testqp@\psk@plotstyle}%
    \if@pst
      \psplot@ii
    \else
      \psplot@iii
    \fi
  \endgroup
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psplot@ii}
%    \begin{macrocode}
\def\psplot@ii{%
  \ifx\psk@VarStep\@default
    \addto@pscode{%
      xy \@nameuse{beginqp@\psk@plotstyle}
      \psk@plotpoints 1 sub {
        /x x dx add def
        xy \@nameuse{doqp@\psk@plotstyle}
      } repeat
      /x x1 def
      xy \@nameuse{doqp@\psk@plotstyle}}%
  \else
    \addto@pscode{%
      xy \@nameuse{beginqp@\psk@plotstyle}
      /Olddt dx def /OldOlddt dx def /Oldy F@pstplot def /y 0 def
      /Ndt dx def /Ny 0 def
      { /Ndt Ndt 1.5 mul def %%new step is 50% larger
        x1 x sub dup Ndt lt { /Ndt exch def } { pop } ifelse
        { /x x /Ny /x x Ndt add def tx@EqdfDict begin F@pstplot end def def
          /x x /y /x x Ndt 2 div add def tx@EqdfDict begin F@pstplot end def def
              /Oldy tx@EqdfDict begin F@pstplot end def
         Ny y sub Ndt div y Oldy sub Ndt div dup 0 eq { pop pop exit } if div abs
         dup 1 gt { 1 exch div } if \psk@VarStep\space gt%%if greater than rate OK
         { exit } { /Ndt Ndt 2 div def } ifelse
          Ndt dx lt { exit } if
       } loop
        /x x Ndt add def xy \@nameuse{doqp@\psk@plotstyle}
        x x1 eq { exit } if
        /Olddt Ndt def
        /OldOlddt Olddt def
       /y Ny def} loop}%
  \fi
  \@nameuse{endqp@\psk@plotstyle}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psplot@iii}
%    \begin{macrocode}
\def\psplot@iii{%
  \ifx\psk@VarStep\@default
    \addto@pscode{%
      mark
      /n 2 def
      \psk@plotpoints {
        xy
        n 2 roll
        /n n 2 add def
        /x x dx add def
      } repeat
      /x x1 def
      xy
      n 2 roll}%
  \else\pst@killglue
    \addto@pscode{%
      /Olddt dx def /OldOlddt dx def /Oldy F@pstplot def /y 0 def
      /Ndt dx def /Ny 0 def /n 2 def
      mark xy
      { /Ndt Ndt 1.5 mul def %%new step is 50% larger
        x1 x sub dup Ndt lt { /Ndt exch def } { pop } ifelse
        { /x x /Ny /x x Ndt add def tx@EqdfDict begin F@pstplot end def def
          /x x /y /x x Ndt 2 div add def tx@EqdfDict begin F@pstplot end def def
              /Oldy tx@EqdfDict begin F@pstplot end def
         Ny y sub Ndt div y Oldy sub Ndt div dup 0 eq { pop pop exit } if div abs
         dup 1 gt { 1 exch div } if \psk@VarStep\space gt%%if greater than rate OK
         { exit } { /Ndt Ndt 2 div def } ifelse
          Ndt dx lt { exit } if
       } loop
        /x x Ndt add def xy /n n 2 add def n 2 roll
        x x1 eq { exit } if
        /Olddt Ndt def
        /OldOlddt Olddt def
       /y Ny def} loop}%
  \fi
  \@nameuse{endplot@\psk@plotstyle}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\parametricplot@i}
%    \begin{macrocode}
\def\parametricplot@i#1#2#3{%
  \pst@killglue%
  \begingroup
    \use@par
    \@nameuse{beginplot@\psk@plotstyle}%
    \addto@pscode{%
      \psplot@init
      /t #1 def
      /t1 #2 def
      /dt t1 t sub \psk@plotpoints div def
      \ifnum\psk@infix<\z@\space /F@pstplot (#3) tx@EqdfDict begin AlgParser end cvx def \fi
      /xy {
        \ifnum\psk@infix<\z@\space  F@pstplot \else #3 \fi
        \pst@number\psyunit mul exch
        \pst@number\psxunit mul exch
      } def}%
    \gdef\psplot@init{}%
    \@pstfalse
    \@nameuse{testqp@\psk@plotstyle}%
    \if@pst
      \parametricplot@ii
    \else
      \parametricplot@iii
    \fi
  \endgroup
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\parametricplot@ii}
%    \begin{macrocode}
\def\parametricplot@ii{%
    \addto@pscode{%
      xy \@nameuse{beginqp@\psk@plotstyle}
      \psk@plotpoints 1 sub {
        /t t dt add def
        xy \@nameuse{doqp@\psk@plotstyle}
      } repeat
      /t t1 def
      xy \@nameuse{doqp@\psk@plotstyle}}%
  \@nameuse{endqp@\psk@plotstyle}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\parametricplot@iii}
%    \begin{macrocode}
\def\parametricplot@iii{%
    \addto@pscode{%
      mark
      /n 2 def
      \psk@plotpoints {
        xy
        n 2 roll
        /n n 2 add def
        /t t dt add def
      } repeat
      /t t1 def
      xy
      n 2 roll}%
  \@nameuse{endplot@\psk@plotstyle}}
%    \end{macrocode}
% \end{macro}
% \paragraph{Axis}
%    \begin{macrocode}
\newcount\@zero\@zero=0\relax

\newif\ifPst@plot@comma
\define@key[psset]{}{comma}[true]{\@nameuse{Pst@plot@comma#1}}

\newif\ifPst@plot@xAxis
\newif\ifPst@plot@yAxis
\define@key[psset]{}{xAxis}[true]{\@nameuse{Pst@plot@xAxis#1}}
\define@key[psset]{}{yAxis}[true]{\@nameuse{Pst@plot@yAxis#1}}
\define@key[psset]{}{xyAxes}[true]{\psset{xAxis=#1,yAxis=#1}}

\define@key[psset]{}{xDecimals}{\def\psk@xDecimals{#1}}
\define@key[psset]{}{yDecimals}{\def\psk@yDecimals{#1}}
\define@key[psset]{}{xyDecimals}{\psset{xDecimals=#1,yDecimals=#1}}

\define@key[psset]{}{xLabel}{\def\psk@xLabel{#1}}
\define@key[psset]{}{yLabel}{\def\psk@yLabel{#1}}
\define@key[psset]{}{xyLabel}{\psset{xLabel=#1,yLabel=#1}}

\define@key[psset]{}{xlogBase}{\edef\psk@xlogBase{#1}}
\define@key[psset]{}{ylogBase}{\edef\psk@ylogBase{#1}}
\define@key[psset]{}{xylogBase}{\psset{xlogBase=#1,ylogBase=#1}}

\define@key[psset]{}{logLines}{\pst@expandafter\pst@test@all@x@y@none{#1}\@nil\psk@logLines}

%    \end{macrocode}
% \begin{macro}{\pst@test@all@x@y@none}
%    \begin{macrocode}
\def\pst@test@all@x@y@none#1#2\@nil#3{%
  \ifx#1a
    \let#3\z@
  \else
    \ifx#1x
      \let#3\@ne
    \else
      \ifx#1y
        \let#3\tw@
      \else
        \ifx#1n
          \let#3\thr@@
        \else
          \@pstrickserr{Bad argument: `#1#2'}\@ehpa
        \fi
      \fi
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}

\define@key[psset]{}{xlabelFactor}{\edef\psk@xlabelFactor{#1}}
\define@key[psset]{}{ylabelFactor}{\edef\psk@ylabelFactor{#1}}
\define@key[psset]{}{xylabelFactor}{\psset{xlabelFactor=#1,ylabelFactor=#1}}

\define@key[psset]{}{ticks}{\pst@expandafter\pst@test@all@x@y@none{#1}\@nil\psk@ticks}

\define@key[psset]{}{labels}{\pst@expandafter\pst@test@all@x@y@none{#1}\@nil\psk@labels}

\define@key[psset]{}{Ox}{\edef\psk@Ox{#1}}
\define@key[psset]{}{Oy}{\edef\psk@Oy{#1}}

\define@key[psset]{}{Dx}{\edef\psk@Dx{#1}}
\define@key[psset]{}{Dy}{\edef\psk@Dy{#1}}

\define@key[psset]{}{dx}{%
  \pssetxlength\pst@dimg{#1}%
  \edef\psk@dx{\number\pst@dimg}}
\define@key[psset]{}{dy}{%
  \pssetylength\pst@dimg{#1}%
  \edef\psk@dy{\number\pst@dimg}}

\newif\ifshoworigin
\define@key[psset]{}{showorigin}{\@nameuse{showorigin#1}}

\newdimen\psk@subticksize\psk@subticksize=\z@
\newdimen\pst@xticksizeA
\newdimen\pst@xticksizeB
\newdimen\pst@xticksizeC
\newdimen\pst@yticksizeA
\newdimen\pst@yticksizeB
\newdimen\pst@yticksizeC

\define@key[psset]{}{xticksize}{%
  \pst@expandafter\pst@getydimdim{#1}{\pst@missing}{}{}\@nil%
  \pst@xticksizeA=\the\pst@dimm%
  \pst@xticksizeB=\the\pst@dimn%
  \edef\psk@xticksize{\pst@number\pst@xticksizeA\space \pst@number\pst@xticksizeB}%
  \ifdim\pst@xticksizeA=\z@\pst@xticksizeC=\z@\else
    \pst@absdim{\pst@xticksizeA}\pst@dimm%
    \pst@absdim{\pst@xticksizeB}\pst@dimn%
    \pst@maxdim{\pst@dimm}{\pst@dimn}\pst@dimo%
    \pst@xticksizeC=\pst@dimo%
  \fi%
}
\define@key[psset]{}{yticksize}{%
  \pst@expandafter\pst@getxdimdim{#1}{\pst@missing}{}{}\@nil%
  \pst@yticksizeA=\the\pst@dimm%
  \pst@yticksizeB=\the\pst@dimn%
  \edef\psk@yticksize{\pst@number\pst@yticksizeA \pst@number\pst@yticksizeB}%
  \ifdim\pst@yticksizeA=0pt\pst@yticksizeC=\z@\else
    \pst@absdim{\pst@yticksizeA}\pst@dimm%
    \pst@absdim{\pst@yticksizeB}\pst@dimn%
    \pst@maxdim{\pst@dimm}{\pst@dimn}\pst@dimo%
    \pst@yticksizeC=\pst@dimo%
  \fi%
}
\define@key[psset]{}{ticksize}{\psset{xticksize=#1,yticksize=#1}}

\define@key[psset]{}{tickstyle}{%
  \pst@expandafter\pst@test@full@top@bottom{#1}\@nil%
  \ifnum\psk@tickstyle>\z@%
    \psset{xticksize=0 \pst@xticksizeB}%
    \psset{yticksize=0 \pst@yticksizeB}%
  \else\ifnum\psk@tickstyle<\z@%
    \psset{xticksize=\pst@xticksizeA\space 0}%
    \psset{yticksize=\pst@yticksizeA\space 0}%
  \fi\fi%
}

\define@key[psset]{}{xtickwidth}{\pst@getlength{#1}\psk@xtickwidth}
\define@key[psset]{}{ytickwidth}{\pst@getlength{#1}\psk@ytickwidth}
\define@key[psset]{}{tickwidth}{\psset{xtickwidth=#1,ytickwidth=#1}}

\define@key[psset]{}{xtickcolor}{\edef\psk@xtickcolor{#1}}
\define@key[psset]{}{ytickcolor}{\edef\psk@ytickcolor{#1}}
\define@key[psset]{}{tickcolor}{\psset{xtickcolor=#1,ytickcolor=#1}}

\define@key[psset]{}{xticklinestyle}{%
  \@ifundefined{psls@#1}%
    {\@pstrickserr{Line style `#1' not defined}\@eha}%
    {\edef\psxticklinestyle{#1}}%
}
\define@key[psset]{}{yticklinestyle}{%
  \@ifundefined{psls@#1}%
    {\@pstrickserr{Line style `#1' not defined}\@eha}%
    {\edef\psyticklinestyle{#1}}%
}
\define@key[psset]{}{ticklinestyle}{\psset{xticklinestyle=#1,yticklinestyle=#1}}

\def\pst@test@full@top@bottom#1#2\@nil{%
  \ifx#1f
    \let\psk@tickstyle\z@
  \else
    \ifx#1t
      \let\psk@tickstyle\@ne
    \else
      \ifx#1b
        \let\psk@tickstyle\m@ne
      \else
        \@pstrickserr{Bad tick style: `#1#2'}\@ehpa
      \fi
    \fi
  \fi}

\define@key[psset]{}{xsubticks}{\edef\psk@xsubticks{#1}}
\define@key[psset]{}{ysubticks}{\edef\psk@ysubticks{#1}}
\define@key[psset]{}{subticks}{\psset{xsubticks=#1,ysubticks=#1}}

\define@key[psset]{}{xsubticksize}{\edef\psk@xsubticksize{#1}}
\define@key[psset]{}{ysubticksize}{\edef\psk@ysubticksize{#1}}
\define@key[psset]{}{subticksize}{\psset{xsubticksize=#1,ysubticksize=#1}}

\define@key[psset]{}{xsubtickwidth}{\pst@getlength{#1}\psk@xsubtickwidth}
\define@key[psset]{}{ysubtickwidth}{\pst@getlength{#1}\psk@ysubtickwidth}
\define@key[psset]{}{subtickwidth}{\psset{xsubtickwidth=#1,ysubtickwidth=#1}}

\define@key[psset]{}{xsubtickcolor}{\edef\psk@xsubtickcolor{#1}}
\define@key[psset]{}{ysubtickcolor}{\edef\psk@ysubtickcolor{#1}}
\define@key[psset]{}{subtickcolor}{\psset{xsubtickcolor=#1,ysubtickcolor=#1}}

\define@key[psset]{}{xsubticklinestyle}{%
  \@ifundefined{psls@#1}%
    {\@pstrickserr{Line style `#1' not defined}\@eha}%
    {\edef\psxsubticklinestyle{#1}}%
}
\define@key[psset]{}{ysubticklinestyle}{%
  \@ifundefined{psls@#1}%
    {\@pstrickserr{Line style `#1' not defined}\@eha}%
    {\edef\psysubticklinestyle{#1}}%
}
\define@key[psset]{}{subticklinestyle}{\psset{xsubticklinestyle=#1,ysubticklinestyle=#1}}
%    \end{macrocode}
% \begin{macro}{\psaxes}
%    \begin{macrocode}
% These axes macros are complicated. Be careful.
\def\psaxes{\pst@object{psaxes}}

\def\psaxes@i{\pst@getarrows\psaxes@ii}

\def\psaxes@ii(#1){\@ifnextchar({\psaxes@iii(#1)}{\psaxes@iv(0,0)(0,0)(#1)}}

\def\psaxes@iii(#1)(#2){\@ifnextchar({\psaxes@iv(#1)(#2)}{\psaxes@iv(#1)(#1)(#2)}}

\def\psaxes@iv(#1,#2)(#3,#4)(#5,#6){%
  \pst@killglue
  \begingroup
    \setbox\pst@hbox=\hbox\bgroup%
      \use@par%
      \pssetxlength\pst@dimg{#1}% o-x
      \pssetylength\pst@dimh{#2}% o-y
      \pssetxlength\pst@dima{#3}% bl-x
      \pssetylength\pst@dimb{#4}% bl-y
      \pssetxlength\pst@dimc{#5}% ur-x
      \pssetylength\pst@dimd{#6}% ur-y
%    \end{macrocode}
% If minimum values are negative in log mode, we modify Ox
% (respectively Oy) if this was not done by the user
% X axis labels (|\psk@log| = 0 or 1)
%    \begin{macrocode}
      \ifx\psk@xlogBase\@empty
      \else
        \ifx\psk@Ox\@empty
        \else% we do nothing ... hv
          \ifdim\psk@Ox pt=\z@
            \ifdim#3pt<\z@
              \pssetxlength\pst@dimg{#3}% o-x
              \psset{Ox=#3}%
            \fi
          \fi
        \fi
      \fi
    % Y axis labels (\psk@log = 0 or 2)
      \ifx\psk@ylogBase\@empty
      \else
        \ifx\psk@Ox\@empty
        \else
          \ifdim#4pt<\z@
            \ifdim\psk@Oy pt=\z@
              \pssetylength\pst@dimh{#4}% o-y
              \psset{Oy=#4}%
            \fi
          \fi
        \fi
      \fi
    % Whole thing will be translated to origin:
      \advance\pst@dima-\pst@dimg % Dist. from bl-x to o-x
      \advance\pst@dimb-\pst@dimh % Dist. from bl-y to o-y
      \advance\pst@dimc-\pst@dimg % Dist. from ur-x to o-x
      \advance\pst@dimd-\pst@dimh % Dist. from ur-y to o-y
    % Make lines/arrows or frame:
      \@nameuse{psxs@\psk@axesstyle}%  \psxs@axes or \psxs@frame
      \ifPst@plot@xAxis
        \begingroup
          \ifdim\pst@dimb=\z@
          \else
            \showoriginfalse
          \fi
          \ifnum\psk@dx=\z@
            \pst@dimg=\psk@Dx\psxunit
            \edef\psk@dx{\number\pst@dimg}%
          \fi
          \ifPst@plot@yAxis
          \else
            \showorigintrue
          \fi
          \pst@hlabels{\pst@dimc}{\psk@arrowB}{#4}{#6}%
          \ifPst@plot@yAxis\showoriginfalse\fi
          \pst@hlabels{\pst@dima}{\psk@arrowA}{#4}{#6}%
        \endgroup
      \fi
      \ifPst@plot@yAxis
        \begingroup
          \ifdim\pst@dima=\z@
          \else
            \showoriginfalse
          \fi
          \ifnum\psk@dy=\z@
            \pst@dimg=\psk@Dy\psyunit
            \edef\psk@dy{\number\pst@dimg}%
          \fi
          \ifPst@plot@xAxis
          \else
            \showorigintrue
          \fi
          \pst@vlabels{\pst@dimd}{\psk@arrowB}{#3}{#5}%
          \ifPst@plot@xAxis\showoriginfalse\fi
          \pst@vlabels{\pst@dimb}{\psk@arrowA}{#3}{#5}%
        \endgroup
      \fi
      % Now close "\pst@hbox" (which is 0-dimensional), and put it at the origin.
    \egroup%
    \pssetxlength\pst@dimg{#1}%
    \pssetylength\pst@dimh{#2}%
    \leavevmode\psput@cartesian\pst@hbox%
    \ignorespaces%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}

% \pst@ticks{angle}{dx}{n}{int}
% int=1 if ticks appear on top of axes, 0 otherwise.
\def\pst@ticks#1#2#3#4{%
  \begin@SpecialObj
    \addto@pscode{%
      #1 rotate
      /n #3 def
      /dx #2 def
      n 0 lt { /dx dx neg def /n n neg def } if
      /y2 \psk@ticksize CLW 2 div add def
      /y1 y2 neg def
      \ifnum\psk@tickstyle=1
        \ifdim#4<\z@ /y2 \else /y1 \fi 0 def
      \else
        \ifnum\psk@tickstyle=-1
          \ifdim#4<\z@ /y1 \else /y2 \fi 0 def
        \fi
      \fi
      /x dx def
      n { x y1 moveto x y2 lineto stroke /x x dx add def } repeat}%
  \end@SpecialObj}
%

%
%%-------------- hv patch 3 2004-05-23 --------------------------
% to get axesstyle=dashed run
\edef\pst@linetype{0}
%%---------------hv end ----------------------------------------
%
%% #1 integer
%% #2 decimals
%% #3 dot
\def\@stripDecimals#1.#2.#3\@nil{%
  \def\dummy{#1}%
  \ifx\dummy\@empty\the\@zero\else#1\fi% the integer part
}
%
\def\pst@@@hlabel#1{%
  \edef\@xyDecimals{\psk@xDecimals}%
  \psk@xLabel%
  \ifnum\psk@ticks<\tw@ % ticks=all|x
    \ifx\psk@xlogBase\@empty
      \ifPst@plot@comma\pshlabel{\expandafter\@LabelComma#1..\@nil\psk@xlabelFactor}%
      \else\pshlabel{#1}%
      \fi%
    \else%
      {\psk@xLabel\pshlabel{\psk@xlogBase\textsuperscript{\expandafter\@stripDecimals#1..\@nil }}}
    \fi%
  \fi%
}
\def\pst@@@vlabel#1{%
  \edef\@xyDecimals{\psk@yDecimals}%
  \psk@yLabel%
  \ifodd\psk@ticks  % ticks=all||y (0,2)
  \else
    \ifx\psk@ylogBase\@empty
      \ifPst@plot@comma\psvlabel{\expandafter\@LabelComma#1..\@nil\psk@ylabelFactor}%
      \else\psvlabel{#1}%
      \fi%
    \else%
      {\psk@yLabel\psvlabel{\psk@ylogBase\textsuperscript{\expandafter\@stripDecimals#1..\@nil }}}
    \fi%
  \fi%
}
\newcount\@digitcounter\@digitcounter=0\relax
\def\@inc@digitcounter{\global\advance\@digitcounter by 1\relax}
\def\@get@digitcounter{\the\@digitcounter\relax}
\def\@Reset@digitcounter{\global\@digitcounter=0\relax}
\def\@zeroFill{%
  \ifnum \@xyDecimals>\@get@digitcounter
    \bgroup
      0\@inc@digitcounter\@zeroFill
    \egroup%
  \fi%
}
% #1 the value, maybe empty
%
\def\@process@digits#1#2;{%
  \ifx *#1\@zeroFill\else#1\@inc@digitcounter\@process@digits#2;\fi%
}
\def\@writeDecimals#1{%
  \ifx\@xyDecimals\@empty% take value as is
    \def\@tempa{#1}% write only if not empty
    \ifx\@tempa\@empty% write nothing
    \else
      \ifPst@plot@comma,\else.\fi%
      #1%
    \fi%
  \else% write only \xy@decimals
    \ifnum\@xyDecimals>\@zero
      \ifPst@plot@comma,\else.\fi
        \@Reset@digitcounter
        \@process@digits#1*;
      \fi%
  \fi%
}
%% #1 integer
%% #2 decimals
%% #3 dot
\def\@LabelComma#1.#2.#3\@nil{%
  \def\dummy{#1}%
  \ifx\dummy\@empty\the\@zero\else#1\fi% the integer part
  \def\dummy{#2}%
  \ifx\dummy\@empty\@writeDecimals{}\else\@writeDecimals{#2}\fi%
}
%
\def\psxs@axes{{%
  \ifPst@plot@xAxis\psxs@@axes\pst@dima\pst@dimb\pst@dimc\pst@dimd{}\fi
  \ifPst@plot@yAxis\psxs@@axes\pst@dima\pst@dimb\pst@dimc\pst@dimd{exch}\fi
}}

%

%
\newif\ifis@yAxis%
%
\def\psxs@@axes#1#2#3#4#5{% llx,lly,urx,ury,exch,arrowA,arrowB
  \begin@SpecialObj%
    \def\pst@tempa{#5}%
    \ifx\pst@tempa\@empty\relax
      \is@yAxisfalse
      \ifnum\psk@dx=\z@
        \pst@dimg=\psk@Dx\psxunit
        \edef\psk@dx{\number\pst@dimg}%
      \fi
    \else
      \is@yAxistrue
      \ifnum\psk@dy=\z@
        \pst@dimg=\psk@Dy\psyunit
        \edef\psk@dy{\number\pst@dimg}%
      \fi
    \fi%
    \let\pst@linetype\pst@arrowtype%
    \pst@addarrowdef%
    \addto@pscode{%
      \ifis@yAxis 0 \pst@number#4 \else \pst@number#3 0 \fi
      \ifis@yAxis 0 \pst@number#2 \else \pst@number#1 0 \fi
      ArrowA
      CP 4 2 roll
      ArrowB
      /yEnd exch def /xEnd exch def
      xEnd yEnd L                                  % the line with arrows
      /yStart exch def
      /xStart exch def
      stroke                                       % draw the main line
%\psk@ticks: all=0; x=1; y=2; none=3
      \number\psk@ticks\space dup 2 mod 0 eq \ifis@yAxis true \else false \fi and
      exch 2 lt \ifis@yAxis false \else true \fi and or {
      /viceversa
        \ifis@yAxis\pst@number#2 \pst@number#4 \else\pst@number#1 \pst@number#3 \fi
         gt { true }{ false } ifelse def           % other way round
      /epsilon 0.01 def                            % rounding errors
      /minTickline \ifis@yAxis \pst@number#1 \else \pst@number#2 \fi def
      /maxTickline \ifis@yAxis \pst@number#3 \else \pst@number#4 \fi def
      /dT \ifis@yAxis\psk@dy\else\psk@dx\fi\space 65536 div viceversa {neg} if def
      /subTNo \ifis@yAxis\psk@ysubticks\else\psk@xsubticks\fi \space def
      subTNo 0 gt { /dsubT dT subTNo div def}{ /dsubT 0 def } ifelse  % deltaSubTick
      \ifis@yAxis \psk@yticksize \else \psk@xticksize \fi
      /tickend exch def /tickstart exch def
      /Twidth \ifis@yAxis \psk@ytickwidth \else \psk@xtickwidth \fi\space def
      /subTwidth \ifis@yAxis \psk@ysubtickwidth \else \psk@xsubtickwidth \fi\space def
      /STsize \ifis@yAxis \psk@ysubticksize \else \psk@xsubticksize \fi\space def
      /TColor {
        \ifis@yAxis\pst@usecolor\psk@ytickcolor
        \else\pst@usecolor\psk@xtickcolor\fi\space } def
      /subTColor {
        \ifis@yAxis\pst@usecolor\psk@ysubtickcolor
        \else\pst@usecolor\psk@xsubtickcolor\fi\space } def
      /MinValue { \ifis@yAxis yStart \else xStart \fi
        \ifx\psk@arrowA\@empty\else
          \psk@arrowsize\space CLW mul add \psk@arrowlength\space mul
           viceversa { sub epsilon add } { add epsilon sub } ifelse \fi } def
      /MaxValue { \ifis@yAxis yEnd \else xEnd \fi
        \ifx\psk@arrowB\@empty\else
          \psk@arrowsize\space CLW mul add \psk@arrowlength\space mul
           viceversa { add epsilon sub } { sub epsilon add } ifelse \fi } def
      /logLines {
        \ifnum\psk@logLines=\z@ true \else         % all axes
          \ifnum\psk@logLines<\tw@                 % x axis
            \ifis@yAxis false \else true \fi       % do we have x or y axis
          \else
            \ifnum\psk@logLines<\thr@@             % y axis
              \ifis@yAxis true \else false \fi     % do we have x or y axis
            \else
              false                                % no one
            \fi
          \fi
        \fi
      } def
      /LSstroke {                                  % set linestyle and stroke
        \ifis@yAxis\@nameuse{psls@\psyticklinestyle}
        \else\@nameuse{psls@\psxticklinestyle}\fi } def
      /subLSstroke {                               % set sublinestyle and stroke
        \ifis@yAxis\@nameuse{psls@\psysubticklinestyle}
        \else\@nameuse{psls@\psxsubticklinestyle}\fi } def
%\iffalse
% start ticks ---------------------------------------------------------
      0 dT MaxValue {                              % the positive part of the axes
        /cntTick exch def                          % the index
        logLines {                                 % log lines?
          gsave
          1 10 subTNo div 9.99 {                   % do not write a line for 1
            /dx exch def                           % save index
            /x cntTick dT dx log mul add def       %
            x abs MaxValue abs le {                % out of range?
              x minTickline #5\space moveto
              x maxTickline #5\space lineto
            } if
          } for
          subTwidth SLW subTColor                  % set line width and subtick color
          subLSstroke
          grestore                                 % restore main tick status
          stroke
          /dsubT 0 def                             % no other subticks
        } if
        dsubT abs 0 gt {                           % du we have subticks?
          gsave                                    % save graphic state
% start subticks ----------------------------------------------------------
            /cntsubTick cntTick dsubT add def
            subTNo 1 sub {
            cntsubTick abs MaxValue abs le {       % out of range?
              cntsubTick tickstart STsize mul #5\space moveto
              cntsubTick tickend STsize mul #5\space lineto
            }{ exit }  ifelse
            /cntsubTick cntsubTick dsubT add def
          } repeat
          subTwidth SLW subTColor                  % set line width and subtick color
          subLSstroke
% end subticks ----------------------------------------------------------
          grestore                                 % restote tick status
        } if
        gsave
        cntTick tickstart #5\space moveto          % line begin main Tick
        cntTick tickend #5\space lineto            % lineto tick end
        Twidth SLW TColor                            % set line width and tick color
        LSstroke
        grestore
      } for
% end ticks ----------------------------------------------------------
%\fi
%\iffalse
% ================================================ % the other side
      /dT dT neg def                               % the other side of the axis
      /dsubT dsubT neg def
% start ticks ----------------------------------------------------------
      0 dT MinValue epsilon viceversa { add }{ sub } ifelse {
        /cntTick exch def
        logLines {                                 % log lines?
          gsave
          1 10 subTNo div 9.99 {                   % do not write a line for 1
            /dx exch def                           % save index
            /x cntTick dT dx log mul add def       %
            x abs MinValue abs le {                % out of range?
              x minTickline #5\space moveto
              x maxTickline #5\space lineto
            } if
          } for
          /dsubT 0 def
          subTwidth SLW subTColor                  % set line width and subtick color
          subLSstroke
          grestore
        }
        dsubT abs 0 gt {                           % do we have subticks?
          gsave                                    % save main state
% start subticks ----------------------------------------------------------
          /cntsubTick cntTick dsubT add def
          subTNo 1 sub {
            cntsubTick abs MinValue abs le {       % out of range?
              cntsubTick tickstart STsize mul #5\space moveto
              cntsubTick tickend STsize mul #5\space lineto
            }{ exit } ifelse
            /cntsubTick cntsubTick dsubT add def
          } repeat % for
% end subticks ----------------------------------------------------------
          subTwidth SLW subTColor                  % set line width and subtick color
          subLSstroke
          grestore                                 % restore main state
        } if
        gsave
        cntTick tickstart #5\space moveto         % line begin main Tick
        cntTick tickend #5\space lineto           % lineto tick end
        Twidth SLW TColor                         % set line width and tick color
        LSstroke
        grestore
      } for
% end ticks ----------------------------------------------------------
%\fi
    } if
   }%
  \end@SpecialObj%
}
%
\def\psxs@frame{%
  \begin@SpecialObj%
    \addto@pscode{%
      0 0 moveto \pst@number\pst@dimc 0 L
      0 \pst@number\pst@dimd 2 copy rlineto L closepath}%
    \pst@stroke%
    \psk@fillstyle%
  \end@SpecialObj%
  \let\psk@arrowA\@empty%
  \let\psk@arrowB\@empty%
  \pst@xticksizeC=\z@\pst@yticksizeC=\z@%
  \psxs@@axes\pst@dima\pst@dimb\pst@dimc\pst@dimd{}%
  \psxs@@axes\pst@dima\pst@dimb\pst@dimc\pst@dimd{exch}%
}
%
\define@key[psset]{}{axesstyle}{%
  \@ifundefined{psxs@#1}%
    {\@pstrickserr{Axes style `#1' not defined}\@eha}%
    {\edef\psk@axesstyle{#1}}}

\def\psxs@none{\let\psk@arrowA\@empty\let\psk@arrowB\@empty}

% The origin is never the only label.
% #1:Max/Min in pt from origin; #2:arrow; #3:min; #4:max
\def\pst@hlabels#1#2#3#4{%
  \ifdim#1=\z@\else%                   % start from 0 ?
    \ifx#2\empty\else\advance#1\ifdim#1>\z@-\fi7\pslinewidth\fi%
    \pst@cnta=#1\relax%                % Distance (in sp) to end.
    \divide\pst@cnta\psk@dx\relax%     % Number of ticks/labels
    \ifnum\pst@cnta=\z@\else%
      \pst@dimb=\psk@dx sp%            % Space between ticks.
%        \ifPst@plot@yAxis\else\showorigintrue\fi%
        \ifnum\psk@labels<\tw@ \ifPst@plot@xAxis\pst@@hlabels\fi\fi%
        \showoriginfalse%
    \fi%
  \fi%
}
% Knows \pst@dimb and \pst@cnta
\def\pst@@hlabels{%
  \pst@dimm=\pst@xticksizeC\advance\pst@dimm by \pslabelsep%
  \vbox to\z@{%
    \ifdim\pst@dimd>\z@\vskip\pst@dimm\else\vss\fi%
    \ifnum\pst@cnta<\z@\pst@dimb=-\pst@dimb\fi%
    \hbox to\z@{%
      \ifshoworigin\hbox to \z@{\hss\pst@@@hlabel{\psk@Ox}\hss}\fi%
      \mmultido{\n=\psk@Ox+\psk@Dx}{\pst@cnta}{%
        \hskip\pst@dimb\hbox to \z@{\hss\pst@@@hlabel{\n}\hss}%
      }\hss%
    }%
    \ifdim\pst@dimd>\z@\vss\else\vskip\pst@dimm\fi%
}}%
%
\def\pshlabel#1{$#1$}
%
% #1:Max/Min in pt from origin; #2:arrow; #3:min; #4:max
% \psk@labels 0:all; 1:x; 2:y; 3:none
\def\pst@vlabels#1#2#3#4{%
  \ifdim#1=\z@\else%
    \ifx#2\empty\else\advance#1\ifdim#1>\z@-\fi7\pslinewidth\fi%
    \pst@cnta=#1\relax          %      % Distance (in sp) to end.
    \divide\pst@cnta\psk@dy\relax  %   % Number of ticks/labels
    \ifnum\pst@cnta=\z@\else%
      \pst@dima=\psk@dy sp%            % Space between ticks.
%      \ifPst@plot@xAxis\else\showorigintrue\fi%
      \ifodd\number\psk@labels\else\ifPst@plot@yAxis\pst@@vlabels\fi\fi%
      \showoriginfalse%
    \fi%
  \fi%
}

% \pst@dima: the width between two labels in pt
% \pst@dimc: the coordinate of the origin in pt
% \pst@cnta: the lowest label
\def\pst@@vlabels{%
  \pst@dimm=\pst@yticksizeC%
  \advance\pst@dimm by \pslabelsep%
  \vbox to\z@{%
    \ifnum\pst@cnta>\z@\pst@dima=-\pst@dima\fi%
    \offinterlineskip%
    \ifshoworigin
      \vbox to \z@{\vss\hbox to\z@{%
        \ifdim\pst@dimc>\z@\hss\else\hskip\pst@dimm\fi
        \pst@@@vlabel{\psk@Oy}%
        \ifdim\pst@dimc>\z@\hskip\pst@dimm\else\hss\fi}\vss}%
    \fi%
    \mmultido{\n=\psk@Oy+\psk@Dy}{\pst@cnta}{%
      \vbox to\pst@dima{\vss}
      \vbox to \z@{%
        \vss\hbox to\z@{%
          \ifdim\pst@dimc>\z@%
            \hss\pst@@@vlabel{\n}\hskip\pst@dimm%
          \else%
            \hskip\pst@dimm\pst@@@vlabel{\n}\hss%
          \fi
        }\vss%
    }}%
    \vss%
}}
%
\def\psvlabel#1{$#1$}
%
\define@key[psset]{}{barwidth}{\pst@getlength{#1}\psk@barwidth}
%
\def\psbar@ii{\addto@pscode{false \tx@NArray \psbar@iii}}% hv
\def\psbar@iii{%
  newpath
  n {
    /Yval exch def /Xval exch def
    Xval \number\psk@barwidth 0.5 mul sub 0 moveto
    0 Yval rlineto \number\psk@barwidth 0 rlineto
    0 Yval neg rlineto \number\psk@barwidth neg 0 rlineto
  } repeat
}%
\def\beginplot@bar{\begin@SpecialObj}
\def\endplot@bar{%
  \psbar@ii\psk@fillstyle\ifpsshadow\pst@closedshadow\fi%
  \pst@stroke
  \end@SpecialObj%
}
%    \end{macrocode}
% \begin{macro}{\psk@xAxisLabel}
%    \begin{macrocode}
\define@key[psset]{}{xAxisLabel}{\edef\psk@xAxisLabel{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@yAxisLabel}
%    \begin{macrocode}
\define@key[psset]{}{yAxisLabel}{\edef\psk@yAxisLabel{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@xAxisLabelPos}
%    \begin{macrocode}
\define@key[psset]{}{xAxisLabelPos}{\edef\psk@xAxisLabelPos{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\psk@yAxisLabelPos}
%    \begin{macrocode}
\define@key[psset]{}{yAxisLabelPos}{\edef\psk@yAxisLabelPos{#1}}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\newdimen\psk@llx
\newdimen\psk@lly
\newdimen\psk@urx
\newdimen\psk@ury
\define@key[psset]{}{llx}{\pssetxlength\psk@llx{#1}}
\define@key[psset]{}{lly}{\pssetylength\psk@lly{#1}}
\define@key[psset]{}{urx}{\pssetxlength\psk@urx{#1}}
\define@key[psset]{}{ury}{\pssetylength\psk@ury{#1}}
%
\newif\ifPst@plot@box
\define@key[psset]{}{box}[true]{\@nameuse{Pst@plot@box#1}}
%
\newdimen\pst@xunit
\newdimen\pst@yunit
%
\def\psgraph{\begingroup\pst@ifstar\psgraph@i}

\def\psgraph@i{\@ifnextchar[{\psgraph@ii}{\psgraph@ii[]}}

\def\psgraph@ii[#1](#2,#3)(#4,#5)#6#7{%
% options | minX | minY | maxX | maxY | Length x-axis | length y-axis%
  \pst@dimo=#4\p@
  \advance\pst@dimo by -#2\p@ % delta x
  \pst@divide{#6}{\pst@dimo}\pst@tempa
  \pst@xunit=\pst@tempa\p@%

  \pst@dimo=#5\p@
  \advance\pst@dimo by -#3\p@ % delta y
  \pst@divide{#7}{\pst@dimo}\pst@tempa%
  \pst@yunit=\pst@tempa\p@%

  \pst@dima=#2\pst@xunit
  \advance\pst@dima\psk@llx%
  \pst@dimb=#3\pst@yunit
  \advance\pst@dimb\psk@lly%
  \pst@dimc=#4\pst@xunit
  \advance\pst@dimc\psk@urx%
  \pst@dimd=#5\pst@yunit
  \advance\pst@dimd\psk@ury%

  \if@star
    \pspicture*(\pst@dima,\pst@dimb)(\pst@dimc,\pst@dimd)
  \else
    \pspicture(\pst@dima,\pst@dimb)(\pst@dimc,\pst@dimd)
  \fi

  \psset{xunit=\pst@xunit,yunit=\pst@yunit}

  \psaxes[#1](0,0)(#2,#3)(#4,#5)
  \ifx\psk@xAxisLabel\@empty
  \else
    \ifx\psk@xAxisLabelPos\@empty
      \uput[0](#4,0){\psk@xAxisLabel}
    \else
      \uput[0](\psk@xAxisLabelPos){\psk@xAxisLabel}
    \fi
  \fi
  \ifx\psk@yAxisLabel\@empty
  \else
    \ifx\psk@yAxisLabelPos\@empty
      \uput[90](0,#5){\psk@yAxisLabel}
    \else
      \uput[90](\psk@yAxisLabelPos){\psk@yAxisLabel}
    \fi
  \fi
}

\def\endpsgraph{%
  \pst@killglue
  \endpspicture
  \endgroup
}

\@namedef{psgraph*}{\psgraph*}
\@namedef{endpsgraph*}{\endpsgraph}
%
%\def\resetPSTPlotOptions{%
%  \@zero=0%
%  \pstScalePoints(1,1){}{}% reset
%  \psset{%
%       infix=none,% TeX | PS
%       xyAxes=true,
%       xyDecimals={},%
%       xyLabel={},
%       xylogBase={},
%       logLines=none,
%       xlabelFactor=\relax,ylabelFactor=\relax,
%       nStep=1,nStart=0,nEnd={},%
%       xStep=0,yStep=0,xStart={},xEnd={},yStart={},yEnd={},comma=false,%
%       plotNo=1,plotNoMax=1,
%       xAxisLabel=x,yAxisLabel=y,
%       yAxisLabelPos=\@empty,xAxisLabelPos=\@empty,
%       plotstyle=line,
%       plotpoints=50,
%       method=default, whichabs=default, whichord=default,%
%       plotfuncx=default, plotfuncy=default, buildvector=false,
%%       algebraic=false,
%       VarStep=default,
%       dimen=middle,% remark of ML
%       ticks=all,
%       labels=all,
%       Ox=0,Dx=1,dx=0,Oy=0,Dy=1,dy=0,
%       showorigin=true,
%       xticksize=-4pt 4pt,yticksize=-4pt 4pt,
%       tickstyle=full,
%       subticksize=0.75,subticks=1,tickcolor=black,ticklinestyle=solid,%
%       subticklinestyle=solid,%
%       subtickcolor=gray,%
%       tickwidth=0.5\pslinewidth,%
%       subtickwidth=0.25\pslinewidth,
%       axesstyle=axes,
%       barwidth=0.25cm,
%       xAxisLabel=x,yAxisLabel=y,
%       yAxisLabelPos=\@empty,xAxisLabelPos=\@empty,
%       llx=\z@, lly=\z@, urx=\z@, ury=\z@}% prevents rounding errors
%}
%\resetPSTPlotOptions%
%    \end{macrocode}
% Finalize.
%    \begin{macrocode}
\catcode`\@=\PstAtCode\relax
%    \end{macrocode}
% \subsubsection{Former pst-node.tex (adapted)}
%    \begin{macrocode}
\csname PSTnodesLoaded\endcsname
\let\PSTnodesLoaded\endinput
\ifx\PSTricksLoaded\endinput\else\input pstricks2 \fi
\ifx\PSTXKeyLoaded\endinput\else\input pst-xkey \fi
%
\def\fileversion{2.00}
\def\filedate{2004/11/23}
\message{ v\fileversion, \filedate}
\message{`pst-node2' v\fileversion, \filedate\space (tvz,hv)}
%
\edef\PstAtCode{\the\catcode`\@} \catcode`\@=11\relax
\SpecialCoor
%\pst@addfams{pst-node}
%
%\pstheader{pst-node2.pro}
%
\def\pst@nodedict{tx@NodeDict begin }
\def\pst@zapspace#1 #2{%
  #1%
  \ifx#2\@empty\else\expandafter\pst@zapspace\fi%
  #2}
\def\pst@getnode#1#2{%
  \pst@expandafter\pst@@getnode{#1},,\@nil#2%
}
\def\pst@@getnode#1,#2,#3\@nil#4{%
  \ifx\@empty#3\@empty
    \edef#4{/N@\pst@zapspace#1 \@empty\space}%
  \else
    \pst@cntg=#1\relax
    \pst@cnth=#2\relax
    \edef#4{/N@M-\ifnum\psmatrixcnt=\z@ 1\else\the\psmatrixcnt\fi
      -\the\pst@cntg-\the\pst@cnth\space}%
  \fi%
}
\def\tx@NewNode{NewNode }
\def\pst@newnode#1#2#3#4{%
% DG/SR modification begin - Nov.  9, 2000 - Patch 11
  \pst@killglue%
% DG/SR modification end
  \leavevmode%
  \pst@getnode{#1}\pst@thenode%
  \pst@Verb{%
    \pst@nodedict
    {#3}%
    \ifx\psk@name\relax false \else \psk@name true \fi
    \pst@thenode
    #2
    {#4}
    \tx@NewNode
    end%
  }%
  \global\let\psk@name\relax%
  \pstree@nodehook%
  \global\let\pstree@nodehook\relax%
}
\let\pstree@nodehook\relax
\newif\ifnodealign
\define@key[psset]{}{nodealign}{\@nameuse{nodealign#1}}
\psset{nodealign=false}
\def\pst@nodealign{%
  \pst@dimg=\ht\pst@hbox%
  \advance\pst@dimg-\dp\pst@hbox%
  \divide\pst@dimg2%
  \lower\pst@dimg}
\def\tx@InitPnode{InitPnode }
\def\pnode{\@ifnextchar({\pnode@}{\pnode@(0,0)}}
\def\pnode@(#1)#2{%
  \pst@@getcoor{#1}%
  \pst@newnode{#2}{10}{\pst@coor}{\tx@InitPnode}%
  \ignorespaces%
}
\def\tx@InitCnode{InitCnode }
\def\cnode{\pst@object{cnode}}
\def\cnode@i{\@ifnextchar({\cnode@ii}{\cnode@ii(0,0)}}
\def\cnode@ii(#1)#2#3{%
\leavevmode
\hbox{%
\use@par
\pst@@getcoor{#1}%
\pssetlength\pst@dimc{#2}%
\pst@dimg=\psk@dimen\pslinewidth
\advance\pst@dimc-\pst@dimg
\advance\pst@dimc.5\pslinewidth
\ifnodealign
\kern\pst@dimc
\vrule width\z@ height \pst@dimc depth \pst@dimc
\fi
\pscircle@do(#1){#2}%
\pst@newnode{#3}{11}{\pst@coor \pst@number\pst@dimc}{\tx@InitCnode}%
% DG/SR modification begin - Jul. 30, 1997 - Patch 2
%\ifnodealign \kern\pst@dimc\egroup \fi}%
\ifnodealign\kern\pst@dimc\fi}%
% DG/SR modification end
\ignorespaces}
\def\Cnode{\pst@object{Cnode}}
\def\Cnode@i{\@ifnextchar({\Cnode@ii}{\Cnode@ii(0,0)}}
\def\Cnode@ii(#1)#2{\cnode@ii(#1){\psk@radius}{#2}}%
\def\cnodeput{\pst@object{cnodeput}}
\def\cnodeput@i{\@ifnextchar({\cnodeput@iii}{\cnodeput@ii}}
\def\cnodeput@ii#1{%
\addto@par{rot={#1}}%
\@ifnextchar({\cnodeput@iii}{\cnodeput@iii(\z@,\z@)}}
\def\cnodeput@iii(#1)#2{%
\pst@killglue
\@fixedradiusfalse
\def\pst@nodehook{\cnodeput@iv{#2}}%
\pst@makebox{\cput@v{#1}}}
\def\cnodeput@iv#1{%
\pst@newnode{#1}{11}{\pscirclebox@iv \pst@number\pslinewidth add}%
{\tx@InitCnode}%
\global\let\pst@nodehook\relax}
\def\Cnodeput{\pst@object{Cnodeput}}
\def\Cnodeput@i{\@ifnextchar({\Cnodeput@iii}{\Cnodeput@ii}}
\def\Cnodeput@ii#1{%
\addto@par{rot={#1}}%
\@ifnextchar({\Cnodeput@iii}{\Cnodeput@iii(\z@,\z@)}}
\def\Cnodeput@iii(#1)#2{%
\pst@killglue
\@fixedradiustrue
\def\pst@nodehook{\Cnodeput@iv{#2}}%
\pst@makebox{\cput@iv{#1}}}
\def\Cnodeput@iv#1{%
\pst@newnode{#1}{11}{%
\pst@number{\wd\pst@hbox} 2 div \pst@number\pst@dima % x y
\pst@number\pst@dimb \pst@number\pslinewidth \psk@dimen .5 sub mul sub }% r
{\tx@InitCnode}%
\global\let\pst@nodehook\relax}
\def\circlenode{\pst@object{circlenode}}
\def\circlenode@i#1{\pst@makebox{\circlenode@ii{#1}}}
\def\circlenode@ii#1{%
\begingroup
\pst@useboxpar
\setbox\pst@hbox=\hbox{%
\cnodeput@iv{#1}%
\pscirclebox@iii
\box\pst@hbox}%
\ifnodealign \psboxseptrue \fi
\ifpsboxsep \pscirclebox@sep \fi
\leavevmode
\ifnodealign\pst@nodealign\fi
\box\pst@hbox
\endgroup}
\def\Circlenode{\pst@object{Circlenode}}
\def\Circlenode@i#1{\pst@makebox{\Circlenode@ii{#1}}}
\def\Circlenode@ii#1{%
\begingroup
\pst@useboxpar
\pst@dima=\ht\pst@hbox
\advance\pst@dima\dp\pst@hbox
\divide\pst@dima\tw@
\pssetlength\pst@dimb\psk@radius
\setbox\pst@hbox=\hbox{%
\Cnodeput@iv{#1}%
\pscircle(.5\wd\pst@hbox,\pst@dima){\pst@dimb}%
\box\pst@hbox}%
\ifnodealign \psboxseptrue \fi
\ifpsboxsep \psCirclebox@sep \fi
\leavevmode
\ifnodealign\pst@nodealign\fi
\box\pst@hbox
\endgroup}
\def\tx@GetRnodePos{GetRnodePos }
\def\tx@InitRnode{InitRnode }
\def\rnode{\@ifnextchar[{\rnode@i}{\def\pst@par{}\rnode@ii}}
\def\rnode@i[#1]{\def\pst@par{ref=#1}\rnode@ii}
\def\rnode@ii#1{\pst@makebox{\rnode@iii\rnode@iv{#1}}}
\def\rnode@iii#1#2{%
% DG modification begin - Jan. 1997
  \leavevmode
% DG modification end
  \begingroup
% DG/SR modification begin - Apr. 28, 1998 - Patch 6
    \pst@useboxpar
% DG/SR modification end
    #1%
    \if@star\pst@starbox\fi
    \ifnodealign\lower\pst@dimb\fi
    \hbox{%
      \pst@newnode{#2}{16}{%
        \pst@number{\ht\pst@hbox}%
        \pst@number{\dp\pst@hbox}%
        \pst@number{\wd\pst@hbox}%
        \pst@number\pst@dima
        \pst@number\pst@dimb%
      }{\tx@InitRnode}%
      \box\pst@hbox%
    }%
  \endgroup}
\def\rnode@iv{%
  \pst@dima=\psk@xref\wd\pst@hbox
  \ifx\psk@yref\relax
    \pst@dimb=\z@
  \else
    \pst@dimb=\ht\pst@hbox
    \advance\pst@dimb\dp\pst@hbox
    \pst@dimb=\psk@yref\pst@dimb
    \advance\pst@dimb-\dp\pst@hbox
  \fi%
}
\define@key[psset]{}{href}{\pst@checknum{#1}\psk@href}
\define@key[psset]{}{vref}{\def\psk@vref{#1}}
\psset{href=0,vref=.7ex}
%
\def\Rnode{\pst@object{Rnode}}
\def\Rnode@i#1{\pst@makebox{\rnode@iii\Rnode@ii{#1}}}
\def\Rnode@ii{%
% DG modification begin - Jan. 1997
%   - \begingroup removed  as it seems to doesn't work any more
%   - \Rnode doesn't process the optional parameter changes
%\begingroup
    \use@par
% DG modification end
    \pst@dima=\psk@href\wd\pst@hbox
    \advance\pst@dima\wd\pst@hbox
    \divide\pst@dima 2
    \pssetlength\pst@dimb{\psk@vref}%
}
\def\tx@DiaNodePos{DiaNodePos }
  \def\dianode{\pst@object{dianode}}%
  \def\dianode@i#1{\pst@makebox{\dianode@ii{#1}}}%
  \def\dianode@ii#1{%
    \begingroup
    \pst@useboxpar
    \psdiabox@iii
    \setbox\pst@hbox=\hbox{%
  \pst@newnode{#1}{14}{}{%
      /X \pst@number\pst@dima def
      /Y \pst@number\pst@dimb def
      /w \pst@number\pst@dimc 2 mul def
      /h \pst@number\pst@dimd 2 mul def
      /NodePos { \tx@DiaNodePos } def%
  }%
  \box\pst@hbox%
    }%
    \ifnodealign\psboxseptrue\fi
    \ifpsboxsep\psdiabox@sep\fi
% DG/SR modification begin - Sep. 2, 1997 - Patch 3
    \leavevmode
% DG/SR modification end
    \ifnodealign\lower\pst@dimb\fi
    \box\pst@hbox
    \endgroup%
}
\def\tx@TriNodePos{TriNodePos }
\def\tx@InitTriNode{InitTriNode }
\def\trinode{\pst@object{trinode}}
\def\trinode@i#1{\pst@makebox{\trinode@ii{#1}}}
\def\trinode@ii#1{%
\begingroup
\pst@useboxpar
\pstribox@iii
\setbox\pst@hbox=\hbox{%
\pst@newnode{#1}{14}{}{%
\pst@number\pst@dimc
\pst@number\pst@dimd
\ifodd\psk@trimode
exch
\pst@number\pst@dima
\else
\pst@number\pst@dimb
\fi
\psk@trimode
\pst@number{\wd\pst@hbox}%
\pst@number{\ht\pst@hbox}%
\pst@number{\dp\pst@hbox}%
\tx@InitTriNode}%
\box\pst@hbox}%
\ifnodealign\psboxseptrue\fi
\ifpsboxsep\pstribox@sep\fi
% DG/SR modification begin - Sep. 2, 1997 - Patch 3
\leavevmode
% DG/SR modification end
\ifnodealign\lower\pst@tempa\fi
\box\pst@hbox
\endgroup}
\def\tx@OvalNodePos{OvalNodePos }
\def\ovalnode{\pst@object{ovalnode}}
\def\ovalnode@i#1{\pst@makebox{\ovalnode@ii{#1}}}
\def\ovalnode@ii#1{%
    \begingroup
  \pst@useboxpar
  \psovalbox@iii
  \setbox\pst@hbox=\hbox{%
      \pst@newnode{#1}{14}{}{%
    /X \pst@number\pst@dima def
    /Y \pst@number\pst@dimb def
    /w \pst@number\pst@dimc def
    /h \pst@number\pst@dimd def
    /NodePos { \tx@OvalNodePos } def
      }%
      \unhbox\pst@hbox%
  }%
  \ifnodealign\psboxseptrue\fi
  \ifpsboxsep\psovalbox@sep\fi
% DG/SR modification begin - Sep. 2, 1997 - Patch 3
  \leavevmode
% DG/SR modification end
  \ifnodealign\lower\pst@dimb\fi
  \box\pst@hbox
    \endgroup%
}
\def\dotnode{\pst@object{dotnode}}
\def\dotnode@i{\@ifnextchar({\dotnode@ii}{\dotnode@ii(\z@,\z@)}}
\def\dotnode@ii(#1)#2{%
  \leavevmode%
  \hbox{%
    \use@par%
    \pst@@getcoor{#1}%
    \pst@getdotsize%
    \pstree@nodehook%
    \ifnodealign%
      \pst@dima=\pst@dimg%
      \kern\pst@dima%
      \vrule width\z@ height \pst@dimh depth \pst@dimh%
    \fi%
    \pst@newnode{#2}{14}{}{%
      \pst@coor
      /Y ED /X ED
      /w \pst@number\pst@dimg def
      /h \pst@number\pst@dimh def
      /NodePos { \tx@OvalNodePos } def}%
    \psdot@ii(#1)%
    \ifnodealign\kern\pst@dima\fi}%
  \ignorespaces}
\define@key[psset]{}{framesize}{\pst@expandafter\pstframesize@ii{#1} \@nil}
\def\pstframesize@ii#1 #2\@nil{%
  \pssetlength\pst@dimg{#1}%
  \divide\pst@dimg2
  \edef\psk@framewidth{\pst@number\pst@dimg}%
  \ifx\@empty#2\@empty
    \let\psk@frameheight\psk@framewidth
  \else
    \pssetlength\pst@dimg{#2}%
    \divide\pst@dimg2
    \edef\psk@frameheight{\pst@number\pst@dimg}%
  \fi%
}
\psset{framesize=10pt}
%
\def\fnode{\pst@object{fnode}}
\def\fnode@i{\@ifnextchar({\fnode@ii}{\fnode@ii(\z@,\z@)}}
\def\fnode@ii(#1)#2{%
  \leavevmode%
  \pst@killglue%
  \hbox{%
    \use@par%
    \begin@ClosedObj%
    \ifnodealign%
      \kern\psk@framewidth\p@%
      \vrule width\z@ height \psk@frameheight\p@ depth \psk@frameheight\p@%
      \edef\pst@coor{0 0 }%
    \else%
      \pst@@getcoor{#1}%
    \fi%
    \pst@newnode{#2}{14}{}{%
      \pst@coor
      /Y ED /X ED
      /d \psk@dimen .5 sub CLW mul neg def
      /r \psk@framewidth d add def
      /l r neg def
      /u \psk@frameheight d add def
      /d u neg def
      /NodePos { \tx@GetRnodePos } def}%
    \addto@pscode{%
      /x2 \psk@framewidth CLW \psk@dimen mul sub def
      /y2 \psk@frameheight CLW \psk@dimen mul sub def
      \pst@coor 2 copy
      y2 sub /y1 ED
      x2 sub /x1 ED
      y2 add /y2 ED
      x2 add /x2 ED
      \psk@cornersize
      1 index 0 eq { pop pop \tx@Rect } { \tx@OvalFrame } ifelse}%
    \def\pst@linetype{2}%
    \showpointsfalse%
    \end@ClosedObj%
    \ifnodealign\kern\psk@framewidth\p@\fi}%
  \ignorespaces}
\define@key[psset]{}{nodesepA}{%
  \pst@getlength{#1}\psk@nodesepA
  \def\psk@nodeseptypeA{0 }}
\define@key[psset]{}{nodesepB}{%
  \pst@getlength{#1}\psk@nodesepB%
  \def\psk@nodeseptypeB{0 }}
\define@key[psset]{}{nodesep}{%
  \pst@getlength{#1}\psk@nodesepA%
  \let\psk@nodesepB\psk@nodesepA%
  \def\psk@nodeseptypeA{0 }%
  \def\psk@nodeseptypeB{0 }}
\psset{nodesep=0pt}
%
\define@key[psset]{}{XnodesepA}{%
    \pst@getlength{#1}\psk@nodesepA%
    \def\psk@nodeseptypeA{1 }%
}
\define@key[psset]{}{XnodesepB}{%
    \pst@getlength{#1}\psk@nodesepB%
    \def\psk@nodeseptypeB{1 }%
}
\define@key[psset]{}{Xnodesep}{%
    \pst@getlength{#1}\psk@nodesepA%
    \let\psk@nodesepB\psk@nodesepA%
    \def\psk@nodeseptypeA{1 }%
    \def\psk@nodeseptypeB{1 }%
}
\define@key[psset]{}{YnodesepA}{%
    \pst@getlength{#1}\psk@nodesepA%
    \def\psk@nodeseptypeA{2 }%
}
\define@key[psset]{}{YnodesepB}{%
    \pst@getlength{#1}\psk@nodesepB%
    \def\psk@nodeseptypeB{2 }%
}
\define@key[psset]{}{Ynodesep}{%
    \pst@getlength{#1}\psk@nodesepA%
    \let\psk@nodesepB\psk@nodesepA%
    \def\psk@nodeseptypeA{2 }%
    \def\psk@nodeseptypeB{2 }%
}
\define@key[psset]{}{armA}{%
  \pst@getlength{#1}\psk@armA
  \def\psk@armtypeA{0 }}
\define@key[psset]{}{armB}{%
  \pst@getlength{#1}\psk@armB
  \def\psk@armtypeB{0 }}
\define@key[psset]{}{arm}{%
  \pst@getlength{#1}\psk@armA%
  \let\psk@armB\psk@armA%
  \def\psk@armtypeA{0 }%
  \def\psk@armtypeB{0 }}
\psset{arm=10pt}
%
\define@key[psset]{}{XarmA}{%
  \pst@getlength{#1}\psk@armA%
  \def\psk@armtypeA{1 }}
\define@key[psset]{}{XarmB}{%
  \pst@getlength{#1}\psk@armB%
  \def\psk@armtypeB{1 }}
\define@key[psset]{}{Xarm}{%
  \pst@getlength{#1}\psk@armA%
  \let\psk@armB\psk@armA%
  \def\psk@armtypeA{1 }%
  \def\psk@armtypeB{1 }}
\define@key[psset]{}{YarmA}{%
  \pst@getlength{#1}\psk@armA%
  \def\psk@armtypeA{2 }}
\define@key[psset]{}{YarmB}{%
  \pst@getlength{#1}\psk@armB%
  \def\psk@armtypeB{2 }}
\define@key[psset]{}{Yarm}{%
  \pst@getlength{#1}\psk@armA%
  \let\psk@armB\psk@armA%
  \def\psk@armtypeA{2 }%
  \def\psk@armtypeB{2 }}
\define@key[psset]{}{offsetA}{\pst@getlength{#1}\psk@offsetA}
\define@key[psset]{}{offsetB}{\pst@getlength{#1}\psk@offsetB}
\define@key[psset]{}{offset}{\psset{offsetA=#1}\let\psk@offsetB\psk@offsetA}
\define@key[psset]{}{angleA}{\pst@getangle{#1}\psk@angleA}
\define@key[psset]{}{angleB}{\pst@getangle{#1}\psk@angleB}%
\define@key[psset]{}{angle}{%
  \pst@getangle{#1}\psk@angleA
  \let\psk@angleB\psk@angleA%
}
\define@key[psset]{}{arcangleA}{\pst@getangle{#1}\psk@arcangleA}
\define@key[psset]{}{arcangleB}{\pst@getangle{#1}\psk@arcangleB}%
\define@key[psset]{}{arcangle}{%
  \pst@getangle{#1}\psk@arcangleA
  \let\psk@arcangleB\psk@arcangleA}
\define@key[psset]{}{ncurvA}{\pst@checknum{#1}\psk@ncurvA}
\define@key[psset]{}{ncurvB}{\pst@checknum{#1}\psk@ncurvB}%
\define@key[psset]{}{ncurv}{\psset{ncurvA=#1}\let\psk@ncurvB\psk@ncurvA}
\psset{ncurv=.67,arcangle=8,angle=0,offset=0pt}
%
\define@key[psset]{}{lineAngle}{\psset{armB=0.5}\edef\psk@lineAngle{#1}}%
\psset{lineAngle=0}%
%
%
\def\tx@GetCenter{GetCenter }
\def\tx@XYPos{XYPos }
\def\tx@GetEdge{GetEdge }
\def\tx@AddOffset{AddOffset }
\def\tx@GetEdgeA{GetEdgeA }
\def\tx@GetEdgeB{GetEdgeB }
\def\tx@GetArmA{GetArmA }
\def\tx@GetArmB{GetArmB }
\def\check@arrow#1#2{%
\check@@arrow#2-\@nil
\if@pst
\addto@par{arrows=#2}%
\def\next{#1}%
\else
\def\next{#1{#2}}%
\fi
\next}
\def\check@@arrow#1-#2\@nil{%
\ifx\@nil#2\@nil\@pstfalse\else\@psttrue\fi}
\def\tx@InitNC{InitNC }
\def\nc@object#1#2#3#4#5{%
  \csname begin@#1Obj\endcsname%
  \showpointsfalse%
  \pst@getnode{#2}\pst@tempa%
  \pst@getnode{#3}\pst@tempb%
  \gdef\npos@default{#4 }%
  \addto@pscode{%
    /IfArrowInside { false } def
    /NCLW CLW def
    \pst@nodedict
    \psk@offsetA
    \psk@offsetB neg
    \psk@nodesepA
    \psk@nodesepB
    \psk@nodeseptypeA
    \psk@nodeseptypeB
    \pst@tempa
    \pst@tempb
    \tx@InitNC { #5 } if
    end}%
  \def\use@pscode{%
    \pst@Verb{gsave \tx@STV newpath \pst@code\space grestore}%
    \gdef\pst@code{}}%
  \csname end@#1Obj\endcsname%
  \pst@shortput}
\def\npos@default{.5 }
\def\pc@object#1{%
  \@ifnextchar({\pc@@object#1}{\pst@getarrows{\pc@@object#1}}}
\def\pc@@object#1(#2)(#3){%
  \pnode(#2){@@A}\pnode(#3){@@B}%
  #1{@@A}{@@B}%
}
\def\tx@LPutLine{LPutLine }
\def\tx@LPutLines{LPutLines }
\def\tx@BezierMidpoint{BezierMidpoint }
\def\tx@HPosBegin{HPosBegin }
\def\tx@HPosEnd{HPosEnd }
\def\tx@HPutLine{HPutLine }
\def\tx@HPutLines{HPutLines }
\def\tx@VPosBegin{VPosBegin }
\def\tx@VPosEnd{VPosEnd }
\def\tx@VPutLine{VPutLine }
\def\tx@VPutLines{VPutLines }
\def\tx@HPutCurve{HPutCurve }
\def\tx@NCCoor{NCCoor }
\def\tx@NCLine{NCLine }
%
\def\ncline{\pst@object{ncline}}
\def\ncline@i{\check@arrow{\ncline@ii}}
\def\ncline@ii#1#2{\nc@object{Open}{#1}{#2}{.5}{ % hv
  /IfArrowInside { (\psk@ArrowInside) length 0 gt { true }{ false } ifelse } bind def
  /ArrowInsidePos \psk@ArrowInsidePos\space def
  /ArrowInsideOffset \psk@ArrowInsideOffset\space def
  /ArrowInsideNo \psk@ArrowInsideNo\space cvi def
  \tx@NCLine /LPutPos { xB yB xA yA \tx@LPutLine } def
}}
\def\pcline{\pst@object{pcline}}
\def\pcline@i{\pc@object\ncline@ii}
%
\def\tx@NCLines{NCLines }
\def\nclines{\pst@object{nclines}}
\def\nclines@i{\check@arrow\nclines@ii}
\def\nclines@ii#1#2{%
  \begingroup%
  \use@par%
  \def\pst@aftercoors{\nclines@iii{#1}{#2}}%
  \def\pst@coors{}%
  \pst@@getcoors%
}
\def\nclines@iii#1#2{%
  \nc@object{Open}{#1}{#2}{.5}{%
  tx@Dict begin \psline@iii pop end
  mark \pst@coors \tx@NCLines}%
  \endgroup%
  \ignorespaces%
}
%
\def\tx@NCCurve{NCCurve }
\def\nccurve{\pst@object{nccurve}}
\def\nccurve@i{\check@arrow{\nccurve@ii}}
\def\nccurve@ii#1#2{\nc@object{Open}{#1}{#2}{.5}{%
  /IfArrowInside { (\psk@ArrowInside) length 0 gt { true }{ false } ifelse } bind def
  /ArrowInsidePos \psk@ArrowInsidePos\space def
  /ArrowInsideOffset \psk@ArrowInsideOffset\space def
  /ArrowInsideNo \psk@ArrowInsideNo\space cvi def
  /AngleA \psk@angleA\space def /AngleB \psk@angleB\space def
  \psk@ncurvB\space \psk@ncurvA\space
  \tx@NCCurve}}
\def\pccurve{\pst@object{pccurve}}
\def\pccurve@i{\pc@object\nccurve@ii}
%
\def\ncarc{\pst@object{ncarc}}
\def\ncarc@i{\check@arrow{\ncarc@ii}}
\def\ncarc@ii#1#2{\nc@object{Open}{#1}{#2}{.5}{%
  yB yA sub xB xA sub \tx@Atan dup
  \psk@arcangleA\space add /AngleA ED
  \psk@arcangleB\space sub 180 add /AngleB ED
  \psk@ncurvB\space \psk@ncurvA\space
  \tx@NCCurve}}
\def\pcarc{\pst@object{pcarc}}
\def\pcarc@i{\pc@object\ncarc@ii}
\def\tx@NCAngles{NCAngles }
\def\ncangles{\pst@object{ncangles}}
\def\ncangles@i{\check@arrow{\ncangles@ii}}
\def\ncangles@ii#1#2{%
\nc@object{Open}{#1}{#2}{1.5}{\ncangles@iii \tx@NCAngles}}
\def\ncangles@iii{%
  tx@Dict begin \psline@iii pop end
  /AngleA \psk@angleA def
  /AngleB \psk@angleB def
  /ArmA \psk@armA def
  /ArmB \psk@armB def
  /ArmTypeA \psk@armtypeA def
  /ArmTypeB \psk@armtypeB def }
\def\pcangles{\pst@object{pcangles}}
\def\pcangles@i{\pc@object\ncangles@ii}
\def\tx@NCAngle{NCAngle }
\def\ncangle{\pst@object{ncangle}}
\def\ncangle@i{\check@arrow{\ncangle@ii}}
\def\ncangle@ii#1#2{%
\nc@object{Open}{#1}{#2}{1.5}{\ncangles@iii \tx@NCAngle}}
\def\pcangle{\pst@object{pcangle}}
\def\pcangle@i{\pc@object\ncangle@ii}
\def\tx@NCBar{NCBar }
\def\ncbar{\pst@object{ncbar}}
\def\ncbar@i{\check@arrow{\ncbar@ii}}
\def\ncbar@ii#1#2{\nc@object{Open}{#1}{#2}{1.5}{%
  \ncangles@iii /AngleB \psk@angleA def \tx@NCBar}}
\def\pcbar{\pst@object{pcbar}}
\def\pcbar@i{\pc@object\ncbar@ii}
%
\def\tx@NCBarr{NCBarr }
\def\ncbarr{\pst@object{ncbarr}}
\def\ncbarr@i{\check@arrow{\ncbarr@ii}}
\def\ncbarr@ii#1#2{\nc@object{Open}{#1}{#2}{2.5}{%
  \ncangles@iii
  /tpos \psk@tpos\space def
  /AngleB AngleA 180 add def
  \tx@NCBarr}}
\def\pcbarr{\pst@object{pcbarr}}
\def\pcbarr@i{\pc@object\ncbarr@ii}
%
\def\tx@NCDiag{NCDiag }
\def\ncdiag{\pst@object{ncdiag}}
\def\ncdiag@i{\check@arrow{\ncdiag@ii}}
\def\ncdiag@ii#1#2{%
  \nc@object{Open}{#1}{#2}{1.5}{\ncangles@iii /lineAngle \psk@lineAngle\space def \tx@NCDiag}}
\def\pcdiag{\pst@object{pcdiag}}
\def\pcdiag@i{\pc@object\ncdiag@ii}
\def\tx@NCDiagg{NCDiagg }
\def\ncdiagg{\pst@object{ncdiagg}}
\def\ncdiagg@i{\check@arrow{\ncdiagg@ii}}
\def\ncdiagg@ii#1#2{%
  \nc@object{Open}{#1}{#2}{.5}{\ncangles@iii /lineAngle \psk@lineAngle\space def \tx@NCDiagg}}
\def\pcdiagg{\pst@object{pcdiagg}}
\def\pcdiagg@i{\pc@object\ncdiagg@ii}
\def\tx@NCLoop{NCLoop }
\define@key[psset]{}{loopsize}{\pst@getlength{#1}\psk@loopsize}
\psset{loopsize=1cm}
%
\def\ncloop{\pst@object{ncloop}}
\def\ncloop@i{\check@arrow{\ncloop@ii}}
\def\ncloop@ii#1#2{%
\nc@object{Open}{#1}{#2}{2.5}%
{\ncangles@iii /loopsize \psk@loopsize def \tx@NCLoop}}
\def\pcloop{\pst@object{pcloop}}
\def\pcloop@i{\pc@object\ncloop@ii}
\def\tx@NCCircle{NCCircle }
\def\nccircle{\pst@object{nccircle}}
\def\nccircle@i{\check@arrow{\nccircle@ii}}
\def\nccircle@ii#1#2{%
\pssetlength\pst@dima{#2}%
\nc@object{Open}{#1}{#1}{.5}{%
  /AngleA \psk@angleA def
  /r \pst@number\pst@dima def
  \tx@NCCircle \psarc@v end}}
\def\tx@NCBox{NCBox }
\def\ncbox{\pst@object{ncbox}}
\def\ncbox@i{\check@arrow{\ncbox@ii}}
\def\ncbox@ii#1#2{%
  \def\pst@linetype{2}%
  \nc@object{Closed}{#1}{#2}{.5}{%
    tx@Dict begin \psline@iii pop end
    \psk@boxheight \psk@boxdepth
    \tx@NCBox}}
\def\pcbox{\pst@object{pcbox}}
\def\pcbox@i{\pc@object\ncbox@ii}
\def\tx@NCArcBox{NCArcBox }
\define@key[psset]{}{boxheight}{\pst@getlength{#1}\psk@boxheight}
\define@key[psset]{}{boxdepth}{\pst@getlength{#1}\psk@boxdepth}
\define@key[psset]{}{boxsize}{%
  \psset{boxheight=#1}%
  \let\psk@boxdepth\psk@boxheight}
\psset{boxsize=.4cm}
%
\def\ncarcbox{\pst@object{ncarcbox}}
\def\ncarcbox@i{\check@arrow{\ncarcbox@ii}}
\def\ncarcbox@ii#1#2{%
\def\pst@linetype{1}%
\nc@object{Closed}{#1}{#2}{.5}{%
\psk@arcangleA \psk@boxheight \psk@boxdepth \pst@number\pslinearc
\tx@NCArcBox}}
\def\pcarcbox{\pst@object{pcarcbox}}
\def\pcarcbox@i{\pc@object\ncarcbox@ii}
\def\tx@Tfan{Tfan }
% Changed according pst-beta.bug December 3, 1993
% nrot=:<angle> does not work when : is active.
\begingroup
\catcode`\:=13
\gdef\pst@activerot{\def:{\string:}}
\endgroup
\define@key[psset]{}{nrot}{%
  \begingroup%
  \pst@activerot%
  \pst@expandafter{\@ifnextchar:{\pstnrot@ii}{\pstrot@ii}}{#1}\@nil%
  \global\let\pst@tempg\psk@rot%
  \endgroup%
  \let\psk@nrot\pst@tempg}
\def\pstnrot@ii:#1\@nil{%
  \pstrot@ii#1\@nil%
  \edef\psk@rot{NAngle \ifx\psk@rot\@empty\else\psk@rot add \fi}}
%
\def\tx@LPutCoor{LPutCoor }
\def\tx@LPut{LPut }
\define@key[psset]{}{npos}{%
  \def\pst@tempa{#1}%
  \ifx\pst@tempa\@empty
    \def\psk@npos{\npos@default}%
  \else%
    \pst@checknum{#1}\psk@npos%
  \fi}
\psset{nrot=0,npos={}}
%
\def\ncput{\pst@object{ncput}}
\def\ncput@i{\pst@killglue\pst@makebox{\ncput@ii}}
\def\ncput@ii{%
    \begingroup
  \use@par
  \if@star\pst@starbox\fi
  \pst@makesmall\pst@hbox
  \pst@rotate\psk@nrot\pst@hbox
  \ncput@iii
    \endgroup
    \pst@shortput%
}
\def\ncput@iii{%
    \leavevmode
    \hbox{%
  \pst@Verb{%
      \pst@nodedict
      /t \psk@npos def
      \tx@LPut
      end
      \tx@PutBegin
  }%
  \box\pst@hbox
  \pst@Verb{\tx@PutEnd}%
    }%
}
\def\naput{\pst@object{naput}}
\def\naput@i{\pst@killglue\pst@makebox{\naput@ii{NAngle 90 add}}}
\def\naput@ii#1{%
\begingroup
\use@par
\if@star\pst@starbox\fi
\def\psk@refangle{#1 }%
\let\psk@rot\psk@nrot
\uput@vii
{exch pop add a \tx@PtoC h1 add exch w1 add exch }%
{tx@Dict /NCLW known { NCLW add } if }%
\ncput@iii
\endgroup
\pst@shortput}
\def\nbput{\pst@object{nbput}}
\def\nbput@i{\pst@killglue\pst@makebox{\naput@ii{NAngle 90 sub}}}
\define@key[psset]{}{tpos}{%
  \pst@checknum{#1}\psk@tpos%
  \ifdim\psk@tpos \p@<\z@%
    \def\psk@tpos{.5}%
% DG/SR modification begin - Sep. 23, 1998 - Patch 7
%\@pstrickserr{Bad `tpos' value: `#1'. Must be 0<tpos<1}\@epha
    \@pstrickserr{Bad `tpos' value: `#1'. Must be 0<tpos<1}\@ehpa%
% DG/SR modification end
  \else%
    \ifdim\psk@tpos \p@>\p@%
      \def\psk@tpos{.5}%
% DG/SR modification begin - Sep. 23, 1998 - Patch 7
%\@pstrickserr{Bad `tpos' value: `#1'. Must be 0<tpos<1}\@epha
      \@pstrickserr{Bad `tpos' value: `#1'. Must be 0<tpos<1}\@ehpa%
% DG/SR modification end
    \fi%
  \fi}
\psset{tpos=0.5}
%
\def\tvput{\pst@object{tvput}}
\def\tvput@i{\pst@makebox{\psput@tput{H}{1}}}
\def\tlput{\pst@object{tlput}}
\def\tlput@i{\pst@makebox{\psput@tput{H}{true}}}
\def\trput{\pst@object{trput}}
\def\trput@i{\pst@makebox{\psput@tput{H}{false}}}
\def\thput{\pst@object{thput}}
\def\thput@i{\pst@makebox{\psput@tput{V}{1}}}
\def\taput{\pst@object{taput}}
\def\taput@i{\pst@makebox{\psput@tput{V}{true}}}
\def\tbput{\pst@object{tbput}}
\def\tbput@i{\pst@makebox{\psput@tput{V}{false}}}
\def\tx@HPutAdjust{HPutAdjust }
\def\tx@VPutAdjust{VPutAdjust }
\def\psput@tput#1#2{%
    \begingroup
  \use@par
  \pst@tputmakesmall
  \leavevmode
  \hbox{%
      \pst@Verb{%
    \pst@nodedict
    /t \psk@tpos \pst@tposflip def
    tx@NodeDict /HPutPos known
        { #1PutPos }
        { CP /Y ED /X ED /NAngle 0 def /NCLW 0 def } ifelse
    /Sin NAngle sin def
    /Cos NAngle cos def
    /s \pst@number\pslabelsep NCLW add def
    /l \pst@number\pst@dima def
    /r \pst@number\pst@dimb def
    /h \pst@number\pst@dimc def
    /d \pst@number\pst@dimd def
% DG/SR modification begin - Sep. 26, 1997 - Patch 4
    %\ifnum1=0#2\else
    \ifnum1=0#2 \else
% DG/SR modification end
        /flag #2 def
        \csname tx@#1PutAdjust\endcsname
    \fi
    \tx@LPutCoor
    end
    \tx@PutBegin
      }%
      \box\pst@hbox
      \pst@Verb{\tx@PutEnd}%
  }%
    \endgroup
    \pst@shortput%
}
\def\pst@tposflip{}
\def\pst@tputmakesmall{%
\pst@dima=\wd\pst@hbox
\divide\pst@dima 2
\pst@dimg=\psk@href\pst@dimg
\pst@dimb\pst@dima
\advance\pst@dima\pst@dimg % leftsize
\advance\pst@dimb-\pst@dimg % rightsize
\pst@dimd=\psk@vref\relax
\pst@dimc=\ht\pst@hbox
\advance\pst@dimc-\pst@dimd % height
\advance\pst@dimd\dp\pst@hbox % depth
\setbox\pst@hbox=\hbox to\z@{%
\kern-\pst@dima\vbox to\z@{\vss\box\pst@hbox\vskip-\pst@dimd}\hss}}
\def\MakeShortNab#1#2{%
  \def\pst@shortput@nab{%
    \def\pst@tempg{\next}%
    \ifx#1\next
      \let\pst@tempg\naput
    \else
      \ifx#2\next
        \let\pst@tempg\nbput
      \else
        \ifx\@sptoken\next
          \let\pst@tempg\pst@shortput
        \fi
      \fi
    \fi
    \pst@tempg}}
\MakeShortNab{^}{_}
\def\MakeShortTablr#1#2#3#4{%
  \def\pst@shortput@tablr{%
    \def\pst@tempg{\next}%
    \ifx#1\next
      \let\pst@tempg\taput
    \else
      \ifx#2\next
        \let\pst@tempg\tbput
      \else
        \ifx#3\next
          \let\pst@tempg\tlput
        \else
          \ifx#4\next
            \let\pst@tempg\trput
          \else
            \ifx\@sptoken\next
              \let\pst@tempg\pst@shortput
            \fi
          \fi
        \fi
      \fi
    \fi
    \pst@tempg}}
\MakeShortTablr{^}{_}{<}{>}
\def\MakeShortTab#1#2{%
  \def\pst@shortput@tab{%
    \def\pst@tempg{\next}%
    \ifx#1\next%
      \def\pst@tempg{%
        \@nameuse{%
          t\ifodd\psk@treemode\ifpstreeflip b\else a\fi%
          \else\ifpstreeflip r\else l\fi\fi put}}%
    \else%
      \ifx#2\next%
        \def\pst@tempg{%
          \@nameuse{%
            t\ifodd\psk@treemode\ifpstreeflip a\else b\fi%
            \else\ifpstreeflip l\else r\fi\fi put}}%
      \else\ifx\@sptoken\next\let\pst@tempg\pst@shortput\fi%
      \fi%
    \fi%
    \pst@tempg}}
\MakeShortTab{^}{_}
\define@key[psset]{}{shortput}{%
  \def\pst@tempg{#1}%
  \ifx\pst@tempg\@none\let\pst@shortput\ignorespaces%
  \else%
    \@ifundefined{pst@shortput@#1}%
      {\@pstrickserr{Bad short put: `#1'}\@ehpa}%
      {\edef\pst@shortput{\noexpand\afterassignment\expandafter\noexpand%
         \csname pst@shortput@#1\endcsname\noexpand\let\noexpand\next}}%
  \fi%
}
\psset{shortput=none}
%
\def\lput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\lput@i}{\lput@ii}}}
\def\lput@i[#1]{\addto@par{ref=#1}\lput@ii}
\def\lput@ii{\@ifnextchar({\lput@iv}{\lput@iii}}
\def\lput@iii#1{\addto@par{nrot=#1}\@ifnextchar({\lput@iv}{\ncput@i}}
\def\lput@iv(#1){\addto@par{npos=#1}\ncput@i}
\def\mput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\mput@i}{\ncput@i}}}
\def\mput@i[#1]{\addto@par{ref=#1}\ncput@i}
\def\Lput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\Lput@ii}{\Lput@i}}}
\def\Lput@i#1{\addto@par{labelsep=#1}\Lput@ii}
\def\Lput@ii[#1]{\addto@par{ref={#1}}\@ifnextchar({\Lput@iv}{\Lput@iii}}
\def\Lput@iii#1{\addto@par{nrot={#1}}\@ifnextchar({\Lput@iv}{\Lput@v}}
\def\Lput@iv(#1){\addto@par{npos=#1}\Lput@v}
\def\Lput@v{\pst@killglue\pst@makebox{\Lput@vi}}
\def\Lput@vi{%
    \begingroup%
  \use@par%
  \if@star\pst@starbox\fi%
  \Rput@vi%
  \pst@makesmall\pst@hbox%
  \pst@rotate\psk@nrot\pst@hbox%
  \ncput@iii%
    \endgroup%
    \pst@shortput%
}
\def\Mput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\Mput@ii}{\Mput@i}}}
\def\Mput@i#1{\addto@par{labelsep=#1}\Mput@ii}
\def\Mput@ii[#1]{\addto@par{ref={#1}}\Lput@v}
\def\aput@#1{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\aput@i#1}{\aput@ii#1}}}
\def\aput@i#1[#2]{\addto@par{labelsep=#2}\aput@ii#1}
\def\aput@ii#1{\@ifnextchar({\aput@iv#1}{\aput@iii#1}}
\def\aput@iii#1#2{\addto@par{nrot=#2}\@ifnextchar({\aput@iv#1}{#1}}
\def\aput@iv#1(#2){\addto@par{npos=#2}#1}
\def\aput{\aput@\naput@i}
\def\bput{\aput@\nbput@i}
\def\Aput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\Aput@i}{\naput@i}}}
\def\Aput@i[#1]{\addto@par{labelsep=#1}\naput@i}
\def\Bput{\def\pst@par{}\pst@ifstar{\@ifnextchar[{\Bput@i}{\nbput@i}}}
\def\Bput@i[#1]{\addto@par{labelsep=#1}\nbput@i}
\def\node@coor#1;#2\@nil{%
\pst@getnode{#1}\pst@tempg
\edef\pst@coor{%
\pst@nodedict
tx@NodeDict \pst@tempg known
{ \pst@tempg load \tx@GetCenter }
{ 0 0 }
ifelse
end }}
\def\Node@coor[#1]#2;#3\@nil{%
  \begingroup
  \psset{#1}%
  \@ifnextchar\bgroup{\Node@@@coor}{\Node@@coor}#2\@nil
  \endgroup
  \let\pst@coor\pst@tempg}
\def\Node@@coor#1\@nil{%
  \pst@getnode{#1}\pst@tempg
  \xdef\pst@tempg{%
    \pst@nodedict
    tx@NodeDict \pst@tempg known
    { \psk@nodesepA \psk@angleA
      \pst@tempg load \psk@nodeseptypeA \tx@GetEdge
      \psk@offsetA \psk@angleA \tx@AddOffset
      \pst@tempg load \tx@GetCenter
      3 -1 roll add 3 1 roll add exch }
    { CP }
    ifelse
    end
  }%
}%
\def\Node@@@coor#1{%
    \pst@@getcoor{#1}%
\def\psk@angleA{%
\pst@tempg load \tx@GetCenter \pst@coor
3 -1 roll sub 3 1 roll sub neg \tx@Atan}%
\Node@@coor}
\def\nput{\pst@object{nput}}
\def\nput@i#1#2{\pst@killglue\pst@makebox{\nput@ii{#1}{#2}}}
\def\nput@ii#1#2{%
    \begingroup
  \use@par
  \psset{refangle=#1}%
  \let\psk@angleA\psk@refangle
  \edef\psk@nodesepA{\pst@number\pslabelsep}%
  \def\psk@nodeseptypeA{0 }%
  \pslabelsep\z@
  \uput@vi
  \Node@@coor#2\@nil
  \let\pst@coor\pst@tempg
  \leavevmode
  \psput@special\pst@hbox
    \endgroup
    \ignorespaces%
}
%
\newcount\psrow
\newcount\pscol
\newcount\psmatrixcnt
\newskip\psrowsep
\newskip\pscolsep
\define@key[psset]{}{colsep}{\pssetlength\pscolsep{#1}}
\define@key[psset]{}{rowsep}{\pssetlength\psrowsep{#1}}
\psset{colsep=1.5cm,rowsep=1.5cm}
\newif\ifpsmatrix
% DG/SR modification begin - Nov. 27, 1998 - Patch 8
%\let\mscount\@multicnt
\ifx\mscount\@undefined\let\mscount\@multicnt\fi
% DG/SR modification end
\def\psmatrix{%
    \begingroup
    {\ifnum0=`}\fi % Don't want to expand any &.
    \@ifnextchar[{\psmatrix@i}{\ifnum0=`{\fi}{}\psmatrix@ii}%
}
\def\psmatrix@i[#1]{%
    \ifnum0=`{\fi}{}%
    \psset{#1}%
    \psmatrix@ii%
}
\def\psmatrix@ii{%
    \KillGlue
    \edef\psm@beginmath{%
  \ifmmode$\m@th\ifinner\textstyle\else\displaystyle\fi\fi}%
    \edef\psm@endmath{\ifmmode$\fi}%
    \let\\\psm@cr
    \advance\psmatrixcnt 1
    \def\psm@thenode{M-\the\psmatrixcnt-\the\psrow-\the\pscol}%
    \tabskip\z@
    \psrow1
    \pscol\z@
    \psset{shortput=tablr}%
    \leavevmode
    \vbox\bgroup\halign\bgroup&%
    \begingroup
  \global\advance\pscol 1
  \csname psrowhook\romannumeral\psrow\endcsname
  \csname pscolhook\romannumeral\pscol\endcsname
  \psm@beginnode##\psm@endnode\endgroup
  \cr%
}
\def\endpsmatrix{%
    \crcr\egroup\unskip\egroup
    \endgroup%
}
\def\psm@cr{{\ifnum0=`}\fi\@ifnextchar[{\psm@@cr}{\psm@@@cr{}}}
\def\psm@@cr[#1]{\psm@@@cr{\vskip#1\relax}}
\def\psm@@@cr#1{%
    \ifnum0=`{\fi}{}\cr
    \noalign{%
  \global\advance\psrow 1
  \global\pscol\z@
  \vskip\psrowsep
  #1%
    }%
}
\def\psm@beginnode{%
    \@ifnextchar\psm@endnode
  {\let\psm@endnode@i\relax\setbox\pst@hbox=\hbox{}}%
  {\pst@object{psm@beginnode}}%
}
\def\psm@beginnode@i{%
    \setbox\pst@hbox=\hbox\bgroup
    \psm@beginmath
    \begingroup
    \ignorespaces%
}
\def\psm@endnode@i{%
    \unskip
    \endgroup
    \psm@endmath
    \egroup
    \use@par
    \@psttrue%
}
\def\psm@endnode{%
    \@pstfalse
    \psm@endnode@i
    \ifnum\pscol>1 \hskip\pscolsep \fi
    \psk@mnodesize
    \hfil
    \nodealigntrue
    \if@pst
  \csname mnode@\psk@mnode\endcsname
    \else
  \csname mnode@\psk@emnode\endcsname
    \fi
    \psk@mcol
    \psk@@mnodesize%
}
% DG/SR modification begin - Sep. 3, 1999 - Patch 10 - From Michael Sharpe
%\def\psspan#1{\mscount#1\relax\loop\ifnum\mscount>\@ne \sp@n\repeat}
\def\psspan#1{\global\mscount#1\relax\pstloop\ifnum\mscount>\@ne\sp@n\repeat}
\def\pstloop#1\repeat{\gdef\pstiterate{#1\relax\expandafter\pstiterate\fi}%
  \pstiterate%
  \let\pstiterate\relax}
% DG/SR modification end
\define@key[psset]{}{name}{\pst@getnode{#1}\psk@name}
\let\psk@name\relax
\define@key[psset]{}{mcol}{%
    \ifx r#1\relax%
  \let\psk@mcol\relax%
    \else%
  \ifx l#1\relax%
      \let\psk@mcol\hfill%
  \else%
      \let\psk@mcol\hfil%
  \fi%
    \fi%
}
\define@key[psset]{}{mnodesize}{%
    \pssetlength\pst@dimg{#1}%
    \ifdim\pst@dimg<\z@
  \let\psk@mnodesize\relax
  \let\psk@@mnodesize\relax
    \else
  \edef\psk@mnodesize{\noexpand\hbox to\number\pst@dimg sp\noexpand\bgroup}%
  \let\psk@@mnodesize\egroup
    \fi%
}
\psset{mnodesize=-1pt,mcol=c}
\def\mnode@R{\rnode@iii\Rnode@ii{\psm@thenode}}
\def\mnode@r{\rnode@iii\rnode@iv{\psm@thenode}}
\def\mnode@oval{\ovalnode@ii{\psm@thenode}}
\def\mnode@tri{\trinode@ii{\psm@thenode}}
\def\mnode@dia{\dianode@ii{\psm@thenode}}
\def\mnode@C{{\nodealigntrue\cnode@ii(\z@,\z@){\psk@radius}{\psm@thenode}}}
\def\mnode@f{{\nodealigntrue\fnode@ii(\z@,\z@){\psm@thenode}}}
\def\mnode@circle{\circlenode@ii{\psm@thenode}}
\def\mnode@p{\pnode(\z@,\z@){\psm@thenode}}
% DG/SR modification begin - Jul. 22, 1997 - Patch 1
\def\mnode@dot{\dotnode@ii(\z@,\z@){\psm@thenode}}
% DG/SR modification end
\def\mnode@none{\box\pst@hbox}
\define@key[psset]{}{mnode}{%
  \@ifundefined{mnode@#1}%
    {\@pstrickserr{\string\psmatrix\space node `#1' not defined.}\@ehpa}%
    {\edef\psk@mnode{#1}}}
\define@key[psset]{}{emnode}{%
  \@ifundefined{mnode@#1}%
    {\@pstrickserr{\string\psmatrix\space node `#1' not defined.}\@ehpa}%
    {\edef\psk@emnode{#1}}}
\psset{mnode=R,emnode=none}
%
%%%% FROM pst-coil.tex
\def\nccoil{\pst@object{nccoil}}
\def\nccoil@i{\check@arrow{\nccoil@ii}}
\def\nccoil@ii#1#2{\nc@object{Open}{#1}{#2}{.5}{%
  \tx@NCCoor
  tx@Dict begin
% DG/SR modification begin - Mar. 19, 1998 - Patch 5
  4 2 roll
% DG/SR modification end
  \psk@coilwidth \pscoilheight
  \psk@coilarmA \psk@coilarmB
  \psk@coilaspect \psk@coilinc
  \pst@coildict \tx@Coil end
  end}}
\def\nczigzag{\pst@object{nczigzag}}
\def\nczigzag@i{\check@arrow{\nczigzag@ii}}
\def\nczigzag@ii#1#2{%
  \nc@object{Open}{#1}{#2}{.5}{%
    \tx@NCCoor
    tx@Dict begin
% DG/SR modification begin - Mar. 19, 1998 - Patch 5
    4 2 roll
% DG/SR modification end
    \pscoilheight
    \psk@coilwidth
    \psk@coilarmA
    \psk@coilarmB
    \pst@coildict \tx@ZigZag end
    \psline@iii
    \tx@Line
    end %
  }%
}
%
%%--------- the new 2005 stuff ---------%%
%
%   #1-------#4----------------#2
% where #1#4= #3 * #1#2
%
\def\setLNode(#1)(#2)#3#4{%
  \pst@getcoor{#1}\pst@tempa%
  \pst@getcoor{#2}\pst@tempb%
  \pnode(!%
    \pst@tempa /YA exch \pst@number\psyunit div def
    /XA exch \pst@number\psxunit div def
    \pst@tempb /YB exch \pst@number\psyunit div def
    /XB exch \pst@number\psxunit div def
    /dx XB XA sub def
    /dy YB YA sub def
    XA dx #3\space mul add YA dy #3\space mul add){#4}
}
%
% build the linear combination #2*#1+#4*#3=#5
\def\setLCNode(#1)#2(#3)#4#5{%
  \pst@getcoor{#1}\pst@tempa%
  \pst@getcoor{#3}\pst@tempb%
  \pnode(!%
    \pst@tempa /YA exch \pst@number\psyunit div def
    /XA exch \pst@number\psxunit div def
    \pst@tempb /YB exch \pst@number\psyunit div def
    /XB exch \pst@number\psxunit div def
    XA #2\space mul XB #4\space mul add
    YA #2\space mul YB #4\space mul add){#5}
}
%
\newif\ifPst@trueAngle
\define@key[psset]{}{trueAngle}[true]{\@nameuse{Pst@trueAngle#1}}
\psset{trueAngle=false}
%
\def\psRelLine{\pst@object{psRelLine}}
\def\psRelLine@i{\@ifnextchar({\psRelLine@iii}{\psRelLine@ii}}
\def\psRelLine@ii#1{%
  \addto@par{arrows=#1}%
  \psRelLine@iii%
}
\def\psRelLine@iii(#1)(#2)#3#4{{
  \pst@killglue
  \use@par
  \pst@getcoor{#1}\pst@tempa
  \pst@getcoor{#2}\pst@tempb
  \pnode(!
    \pst@tempa /YA exch \pst@number\psyunit div def
    /XA exch \pst@number\psxunit div def
    \pst@tempb /YB exch \pst@number\psyunit div def
    /XB exch \pst@number\psxunit div def
    /AlphaStrich \psk@angleA\space def
    /unit \pst@number\psyunit \pst@number\psxunit div def % yunit/xunit
%
    /dx XB XA sub  def
    /dy YB YA sub \ifPst@trueAngle\space unit mul \fi\space def
    /laenge dy dup mul dx dup mul add sqrt #3 mul def
    /Alpha dy dx atan def
    /beta Alpha AlphaStrich add def
    laenge beta cos mul XA add
    laenge beta sin mul \ifPst@trueAngle\space unit div \fi\space YA add ){#4}%
  \psline(#1)(#4)%
}\ignorespaces}
%
% #1 options
% draw a parallel line to #2 #3
%     #2---------#3
%         #4----------#5(new node)
% #5 length of the line
% #6 node name
\def\psParallelLine{\pst@object{psParallelLine}}
\def\psParallelLine@i{\@ifnextchar({\psParallelLine@iii}{\psParallelLine@ii}}
\def\psParallelLine@ii#1{%
  \addto@par{arrows=#1}%
  \psParallelLine@iii%
}
\def\psParallelLine@iii(#1)(#2)(#3)#4#5{{
  \pst@killglue
  \use@par
  \pst@getcoor{#1}\pst@tempa
  \pst@getcoor{#2}\pst@tempb
  \pst@getcoor{#3}\pst@tempc
%  \pst@getlength{#4}\pst@dima
  \pnode(!%
     \pst@tempa /YA exch \pst@number\psyunit div def
     /XA exch \pst@number\psxunit div def
     \pst@tempb /YB exch \pst@number\psyunit div def
     /XB exch \pst@number\psxunit div def
     \pst@tempc /YC exch \pst@number\psyunit div def
     /XC exch \pst@number\psxunit div def
%
    /dx XB XA sub  def
    /dy YB YA sub  def
    /laenge dy dup mul dx dup mul add sqrt #4 mul def
    /Alpha dy dx atan def
    laenge Alpha cos mul XC add
    laenge Alpha sin mul YC add ){#5}%
  \psline(#3)(#5)
}\ignorespaces}
%
\def\psIntersectionPoint(#1)(#2)(#3)(#4)#5{%
    \pst@getcoor{#1}\pst@tempa
    \pst@getcoor{#2}\pst@tempb
    \pst@getcoor{#3}\pst@tempc
    \pst@getcoor{#4}\pst@tempd
\pnode(!%
     \pst@tempa /YA exch \pst@number\psyunit div def
     /XA exch \pst@number\psxunit div def
     \pst@tempb /YB exch \pst@number\psyunit div def
     /XB exch \pst@number\psxunit div def
     \pst@tempc /YC exch \pst@number\psyunit div def
     /XC exch \pst@number\psxunit div def
     \pst@tempd /YD exch \pst@number\psyunit div def
     /XD exch \pst@number\psxunit div def
    /dY1 YB YA sub def
    /dX1 XB XA sub def
    /dY2 YD YC sub def
    /dX2 XD XC sub def
    dX1 abs 0.01 lt {
        /m2 dY2 dX2 div def
        XA dup XC sub m2 mul YC add
    }{
        dX2 abs 0.01 lt {
            /m1 dY1 dX1 div def
            XC dup XA sub m1 mul YA add
        }{%
            /m1 dY1 dX1 div def
            /m2 dY2 dX2 div def
            m1 XA mul m2 XC mul sub YA sub YC add m1 m2 sub div dup
            XA sub m1 mul YA add
        } ifelse
    } ifelse ){#5}%
}
%
%
\def\resetPSTNodeOptions{%
\psset{%
  nodealign=false,%
  href=0,%
  vref=.7ex,%
  framesize=10pt,%
  nodesep=0pt,%
  arm=10pt,%
  offset=0pt,%
  angle=0,%
  arcangle=8,%
  ncurv=.67,%
  loopsize=1cm,%
  boxsize=.4cm,%
  nrot=0,%
  npos=,%
  tpos=0.5,%
  shortput=none,%
  colsep=1.5cm,%
  rowsep=1.5cm,%
%  shortput=tablr,%%
  mcol=c,%
  mnode=R,%
  emnode=none,
  trueAngle=false}
}
%
\catcode`\@=\PstAtCode\relax
%</tex>
%    \end{macrocode}
% \subsection{\LaTeX\ program}
% Initialize the package.
%    \begin{macrocode}
%<*latex>
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{pstricks2}
  [2004/05/06 v0.2k LaTeX wrapper for `PSTricks2' (RN,HV)]
\RequirePackage{pst-xkey}
\@ifpackageloaded{pstcol}{}{\let\saved@gray\color@gray}

\@ifundefined{PSTricksLoaded}
{%
  \let\saved@scalebox\scalebox
  \input{pstricks2.tex}
  \ProvidesFile{pstricks2.tex}
    [\filedate\space v\fileversion\space `PSTricks' (tvz)]
}{}

\DeclareOption{noxcolor}{\def\pst@ColorPackage{color}}

\def\pst@LaTeX@Setup{%
  \PassOptionsToPackage{override}{xcolor}
%
  \IfFileExists{xcolor.sty}%
    {\def\pst@ColorPackage{xcolor}}{\def\pst@ColorPackage{color}}
%
  \DeclareOption*{\PassOptionsToPackage\CurrentOption{\pst@ColorPackage}}
  \ProcessOptions\relax
  \RequirePackage{\pst@ColorPackage}
%
  \@ifpackageloaded{xcolor}%
  {%
    \@ifpackagelater{xcolor}{2004/05/02}%
    {%
      \let\pst@getcolor\XC@getcolor
      \let\pst@usecolor\XC@usecolor
    }
    {%
      \PackageError{pstricks}{%
      *************************************************\MessageBreak
      * Your Version of `xcolor.sty' is too old!\MessageBreak
      * You need the version from 2004/05/02 or newer\MessageBreak
      * or use: \string\usepackage[noxcolor]{pstricks}\MessageBreak
      *************************************************}{}%
    }%
  }
  {%
    \def\pst@getcolor##1##2{%
      \@ifundefined{\string\color@##1}%
      {\@pstrickserr{Color `##1' not defined}\@eha}%
      {\edef##2{##1}}}%
    \def\pst@usecolor##1{\expandafter\expandafter\expandafter\c@lor@to@ps%
      \csname\string\color@##1\endcsname\@@\space}%
    \definecolor{darkgray}{gray}{.25}
    \definecolor{gray}{gray}{.5}
    \definecolor{lightgray}{gray}{.75}
  }
%
  \definecolor{gradbegin}{rgb}{0,1,1}
  \definecolor{gradend}{rgb}{0,.1,.95}
%
  \@ifpackageloaded{pstcol}
  {%
    \psset{bordercolor=white,doublecolor=white,linecolor=black,%
    fillcolor=white,hatchcolor=black,gridcolor=black,gridlabelcolor=black,%
    shadowcolor=darkgray,subgridcolor=gray}
  }{}
%
  \def\newgray##1{%
    \expandafter\gdef\csname ##1\endcsname{\color{##1}}%  HV 2004-03-31
    \definecolor{##1}{gray}}
  \def\newrgbcolor##1##2{%
    \expandafter\gdef\csname ##1\endcsname{\color{##1}}%  HV 2004-03-31
    \newrgbcolorx{##1}##2\@@}
  \def\newrgbcolorx##1##2 ##3 ##4\@@{%
    \definecolor{##1}{rgb}{##2,##3,##4}}
  \def\newcmykcolor##1##2{%
    \expandafter\gdef\csname ##1\endcsname{\color{##1}}%  HV 2004-03-31
    \newcmykcolorx{##1}##2\@@}
  \def\newcmykcolorx##1##2 ##3 ##4 ##5\@@{%
    \definecolor{##1}{cmyk}{##2,##3,##4,##5}}
  \def\newhsbcolor##1##2{%
    \expandafter\gdef\csname ##1\endcsname{\color{##1}}%  HV 2004-03-31
    \newhsbcolorx{##1}##2\@@}
  \def\newhsbcolorx##1##2 ##3 ##4\@@{%
    \definecolor{##1}{hsb}{##2,##3,##4}}
%
  \renewcommand\black    {\color{black}}
  \renewcommand\darkgray {\color{darkgray}}
  \renewcommand\gray     {\color{gray}}
  \renewcommand\lightgray{\color{lightgray}}
  \renewcommand\white    {\color{white}}
  \renewcommand\blue     {\color{blue}}
  \renewcommand\red      {\color{red}}
  \renewcommand\green    {\color{green}}
  \renewcommand\yellow   {\color{yellow}}
  \renewcommand\magenta  {\color{magenta}}
  \renewcommand\cyan     {\color{cyan}}
%
  \let\pst@LaTeX@Setup=\relax
}

\@ifpackageloaded{pstcol}% Is our package called from `pstcol'?
{%
%  We use our own definitions even if `pstcol' is in the first
%  place (adding to pstcol's \AtEndOfPackage hook). RN 2004-05-02
  \expandafter\g@addto@macro\csname pstcol.sty-h@@k\endcsname{%
    \pst@LaTeX@Setup}%
}
{%
  \let\color@gray\saved@gray
% Dummy version entry for `pstcol' to prevent forther loading. RN 2004-04-22
  \@namedef{ver@pstcol.sty}{1938/01/10}% The birthday of Don Knuth
  \PassOptionsToPackage{usenames}{color}
  \pst@LaTeX@Setup
}

\AtBeginDocument{%
  \@ifpackageloaded{pstcol}%
  {%
    \@ifpackagelater{pstcol}{1938/01/11}{% Really loaded? RN 2004-04-22
      \PackageWarningNoLine{pstricks}{%
      *************************************************\MessageBreak
      * The installed version of `pstricks.sty' doesn't\MessageBreak
      * need `pstcol' any more. You should write only:\MessageBreak
      * \@spaces\string\usepackage{pstricks}\MessageBreak
      *************************************************}
    }{\expandafter\let\csname ver@pstcol.sty\endcsname\relax}%
  }{}%
  \@ifundefined{saved@scalebox}{}{\let\scalebox=\saved@scalebox}
  \let\pst@endcolor=\relax
% LaTeX used `\color@endgroup' instead. RN 2004-05-06
}
%</latex>
%    \end{macrocode}
% \subsection{DVIPS header}
% This section generates |pstricks2.pro| which contains the PostScript
% header for DVIPS.
% \subsubsection{Former pstricks.pro, modified}
%    \begin{macrocode}
%<*dvips>
%!
% PostScript prologue for pstricks2
% Version 2.00, 2004-11-23
%
/tx@Dict 200 dict def tx@Dict begin
/ADict 25 dict def
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Atan { /atan load stopped { pop pop 0 } if } def
/Div { dup 0 eq { pop } { div } ifelse } def
/NET { neg exch neg exch T } def
/Pyth { dup mul exch dup mul add sqrt } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def }
def
/PathLength { flattenpath /z 0 def { /y1 ED /x1 ED /y2 y1 def /x2 x1 def
} { /y ED /x ED PathLength@ } {} { /y y2 def /x x2 def PathLength@ }
/pathforall load stopped { pop pop pop pop } if z } def
/STP { .996264 dup scale } def
/STV { SDict begin normalscale end STP  } def
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
%% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
%%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
%%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
/DotLine { /b PathLength def /a ED /z ED /y CLW def /z y z add def a 0 gt
{ /b b a div def } { a 0 eq { /b b y sub def } { a -3 eq { /b b y add
def } if } ifelse } ifelse [ 0 b b z Div round Div dup 0 le { pop 1 } if
] a 0 gt { 0 } { y 2 div a -2 gt { neg } if } ifelse setdash 1
setlinecap stroke } def
/LineFill { gsave abs CLW add /a ED a 0 dtransform round exch round exch
2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
% DG/SR modification end
Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
% def
a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
pop pop } def
% DG/SR modification end
/BeginArrow { ADict begin /@mtrx CM def gsave 2 copy T 2 index sub neg
exch 3 index sub exch Atan rotate newpath } def
/EndArrow { @mtrx setmatrix CP grestore end } def
%
%/Arrow { CLW mul add dup 2 div /w ED mul dup /h ED mul /a ED { 0 h T 1 -1
%scale } if w neg h moveto 0 0 L w h L w neg a neg rlineto gsave fill
%grestore } def
%
/Tbar { CLW mul add /z ED z -2 div CLW 2 div moveto z 0 rlineto stroke 0
CLW moveto } def
/Bracket { CLW mul add dup CLW sub 2 div /x ED mul CLW add /y ED /z CLW 2
div def x neg y moveto x neg CLW 2 div L x CLW 2 div L x y L stroke 0
CLW moveto } def
/RoundBracket { CLW mul add dup 2 div /x ED mul /y ED /mtrx CM def 0 CLW
2 div T x y mul 0 ne { x y scale } if 1 1 moveto .85 .5 .35 0 0 0
curveto -.35 0 -.85 .5 -1 1 curveto mtrx setmatrix stroke 0 CLW moveto }
def
/SD { 0 360 arc fill } def
/EndDot { { /z DS def } { /z 0 def } ifelse /b ED 0 z DS SD b { 0 z DS
CLW sub SD } if 0 DS z add CLW 4 div sub moveto } def
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
/closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
load } if ] cvx newpath 3 1 roll T exec } def
/NArray { aload length 2 div dup dup cvi eq not { exch pop } if /n exch
cvi def } def
%
/NArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop } if
f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
%
/Line {
  NArray n 0 eq not { n 1 eq { 0 0 /n 2 def } if
    IfArrowInside {
    2 copy /y1 ED /x1 ED ArrowA x1 y1
    /n n 1 sub def
    n {
      4 copy
      /y1 ED /x1 ED /y2 ED /x2 ED
      x1 y1
      ArrowInsidePos 1 gt {
        /Alpha y2 y1 sub x2 x1 sub atan def
        /ArrowPos ArrowInsideOffset def
        /Length x2 x1 sub y2 y1 sub Pyth def
        /dArrowPos ArrowInsidePos abs def
        {
          /ArrowPos ArrowPos dArrowPos add def
          ArrowPos Length gt { exit } if
          x1 Alpha cos ArrowPos mul add
          y1 Alpha sin ArrowPos mul add
          ArrowInside
          pop pop
        } loop
      }{
        /ArrowPos ArrowInsideOffset def
        /dArrowPos ArrowInsideNo 1 gt {%
          1.0 ArrowInsideNo 1.0 add div
        }{ ArrowInsidePos } ifelse def
          ArrowInsideNo cvi {
            /ArrowPos ArrowPos dArrowPos add def
            x2 x1 sub ArrowPos mul x1 add
            y2 y1 sub ArrowPos mul y1 add
            ArrowInside
            pop pop
          } repeat
      } ifelse
      pop pop Lineto
    } repeat
  }{ ArrowA /n n 2 sub def n { Lineto } repeat } ifelse
  CP 4 2 roll ArrowB L pop pop } if
} def
%
/Arcto { /a [ 6 -2 roll ] cvx def a r /arcto load stopped { 5 } { 4 }
ifelse { pop } repeat a } def
%
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
and { pop pop /n n 1 sub def } if } def
%
/Polygon {
  NArray n 2 eq { 0 0 /n 3 def } if
  n 3 lt { n { pop pop } repeat }{
    n 3 gt { CheckClosed } if
    n 2 mul
    -2 roll
    /y0 ED /x0 ED /y1 ED /x1 ED
    /xx1 x1 def
    /yy1 y1 def
    x1 y1
    /x1 x0 x1 add 2 div def
    /y1 y0 y1 add 2 div def
    x1 y1 moveto
    /n n 2 sub def
    /drawArrows {
      x11 y11
      ArrowInsidePos 1 gt {
  /Alpha y12 y11 sub x12 x11 sub atan def
  /ArrowPos ArrowInsideOffset def
  /Length x12 x11 sub y12 y11 sub Pyth def
  /dArrowPos ArrowInsidePos abs def
    {
      /ArrowPos ArrowPos dArrowPos add def
      ArrowPos Length gt { exit } if
      x11 Alpha cos ArrowPos mul add
      y11 Alpha sin ArrowPos mul add
      ArrowInside
      pop pop
    } loop
       }{
   /ArrowPos ArrowInsideOffset def
   /dArrowPos ArrowInsideNo 1 gt {%
      1.0 ArrowInsideNo 1.0 add div
   }{ ArrowInsidePos } ifelse def
   ArrowInsideNo cvi {
      /ArrowPos ArrowPos dArrowPos add def
      x12 x11 sub ArrowPos mul x11 add
      y12 y11 sub ArrowPos mul y11 add
            ArrowInside
      pop pop
   } repeat
       } ifelse
     pop pop Lineto
   } def
   n {
     4 copy
     /y11 ED /x11 ED /y12 ED /x12 ED
     drawArrows
   } repeat
   x1 y1 x0 y0
   6 4 roll
   2 copy
   /y11 ED /x11 ED /y12 y0 def /x12 x0 def
   drawArrows
   /y11 y0 def /x11 x0 def /y12 yy1 def /x12 xx1 def
   drawArrows
   pop pop
   closepath
  } ifelse
} def
%
/Diamond {
  /mtrx CM def
  T rotate
  /h ED
  /w ED
  dup 0 eq { pop } { CLW mul neg
    /d ED
    /a w h Atan def
    /h d a sin Div h add def
    /w d a cos Div w add def } ifelse
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div
  /ArrowA { moveto } def
  /ArrowB { } def
  false Line
  closepath mtrx setmatrix
} def
%
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
/Triangle {
  /mtrx CM def translate rotate /h ED 2 div /w ED dup
  CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
  div dup cos exch sin Div mul sub def mark 0 d w neg d 0 h w d 0 d
  /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop
} def
% DG/SR modification end
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CCA { /y ED /x ED 2 copy y sub /dy1 ED x sub /dx1 ED /l1 dx1 dy1 Pyth
def } def
/CC { /l0 l1 def /x1 x dx sub def /y1 y dy sub def /dx0 dx1 def /dy0 dy1
def CCA /dx dx0 l1 c exp mul dx1 l0 c exp mul add def /dy dy0 l1 c exp
mul dy1 l0 c exp mul add def /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos
abs b exp a mul dx dy Pyth Div 2 div def /x2 x l0 dx mul m mul sub def
/y2 y l0 dy mul m mul sub def /dx l1 dx mul m mul neg def /dy l1 dy mul
m mul neg def } def
/IC { /c c 1 add def c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if }
ifelse /a a 2 mul 3 div 45 cos b exp div def CCA /dx 0 def /dy 0 def }
def
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
/OpenCurve { NArray n 3 lt { n { pop pop } repeat } { BOC /n n 3 sub def
    n { NC } repeat EOC } ifelse } def
/AltCurve { { false NArray n 2 mul 2 roll [ n 2 mul 3 sub 1 roll ] aload
/Points ED n 2 mul -2 roll } { false NArray } ifelse n 4 lt { n { pop
pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse } def
/ClosedCurve { NArray n 3 lt { n { pop pop } repeat } { n 3 gt {
CheckClosed } if 6 copy n 2 mul 6 add 6 roll IC CC x y moveto n { NC }
repeat closepath pop pop } ifelse } def
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore }
def
/FontDot { DS 2 mul dup matrix scale matrix concatmatrix exch matrix
rotate matrix concatmatrix exch findfont exch makefont setfont } def
/Rect { x1 y1 y2 add 2 div moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto
x1 y1 lineto closepath } def
/OvalFrame { x1 x2 eq y1 y2 eq or { pop pop x1 y1 moveto x2 y2 L } { y1
y2 sub abs x1 x2 sub abs 2 copy gt { exch pop } { pop } ifelse 2 div
exch { dup 3 1 roll mul exch } if 2 copy lt { pop } { exch pop } ifelse
/b ED x1 y1 y2 add 2 div moveto x1 y2 x2 y2 b arcto x2 y2 x2 y1 b arcto
x2 y1 x1 y1 b arcto x1 y1 x1 y2 b arcto 16 { pop } repeat closepath }
ifelse } def
/Frame { CLW mul /a ED 3 -1 roll 2 copy gt { exch } if a sub /y2 ED a add
/y1 ED 2 copy gt { exch } if a sub /x2 ED a add /x1 ED 1 index 0 eq {
pop pop Rect } { OvalFrame } ifelse } def
/BezierNArray { /f ED counttomark 2 div dup cvi /n ED n eq not { exch pop
} if n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat f { ]
aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse } def
%
/OpenBezier {
  /dArrowPos ArrowInsideNo 1 gt {%
    1.0 ArrowInsideNo 1.0 add div
    }{ ArrowInsidePos } ifelse def
      BezierNArray
      n 1 eq { pop pop
      }{ 2 copy
        /y0 ED /x0 ED
        ArrowA
        n 4 sub 3 idiv { 6 2 roll 4 2 roll curveto } repeat
        6 2 roll
        4 2 roll
        ArrowB
        /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED
        /cx x1 x0 sub 3 mul def
        /cy y1 y0 sub 3 mul def
        /bx x2 x1 sub 3 mul cx sub def
        /by y2 y1 sub 3 mul cy sub def
        /ax x3 x0 sub cx sub bx sub def
        /ay y3 y0 sub cy sub by sub def
        /getValues {
          ax t0 3 exp mul bx t0 t0 mul mul add cx t0 mul add x0 add
          ay t0 3 exp mul by t0 t0 mul mul add cy t0 mul add y0 add
          ax t 3 exp mul bx t t mul mul add cx t mul add x0 add
          ay t 3 exp mul by t t mul mul add cy t mul add y0 add
        } def
        /getdL {
          getValues
          3 -1 roll sub 3 1 roll sub Pyth
        } def
        /CurveLength {
          /u 0 def
          /du 0.01 def
          0 100 {
            /t0 u def
            /u u du add def
            /t u def
            getdL add
          } repeat } def
          /GetArrowPos {
            /ende ArrowInsidePos 1 gt
              { ArrowPos }
              { ArrowPos CurveLength mul } ifelse def
            /u 0 def
            /du 0.01 def
            /sum 0 def
            { /t0 u def
              /u u du add def
              /t u def
              /sum getdL sum add def
              sum ende gt {exit} if
            } loop u
          } def
          /ArrowPos ArrowInsideOffset def
          /loopNo ArrowInsidePos 1 gt {%
            CurveLength ArrowInsidePos div cvi
          }{ ArrowInsideNo } ifelse def
            loopNo cvi {
              /ArrowPos ArrowPos dArrowPos add def
              /t GetArrowPos def
              /t0 t 0.95 mul def
              getValues
              ArrowInside pop pop pop pop
            } repeat
            x1 y1 x2 y2 x3 y3 curveto
  } ifelse
} def
%
/ClosedBezier { BezierNArray n 1 eq { pop pop } { moveto n 1 sub 3 idiv {
6 2 roll 4 2 roll curveto } repeat closepath } ifelse } def
/BezierShowPoints { gsave Points aload length 2 div cvi /n ED moveto n 1
sub { lineto } repeat CLW 2 div SLW [ 4 4 ] 0 setdash stroke grestore }
def
/Parab { /y0 exch def /x0 exch def /y1 exch def /x1 exch def /dx x0 x1
sub 3 div def /dy y0 y1 sub 3 div def x0 dx sub y0 dy add x1 y1 ArrowA
x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB curveto /Points [ x1 y1 x0
y0 x0 2 mul x1 sub y1 ] def } def
/Grid { newpath /a 4 string def /b ED /c ED /n ED cvi dup 1 lt { pop 1 }
if /s ED s div dup 0 eq { pop 1 } if /dy ED s div dup 0 eq { pop 1 } if
/dx ED dy div round dy mul /y0 ED dx div round dx mul /x0 ED dy div
round cvi /y2 ED dx div round cvi /x2 ED dy div round cvi /y1 ED dx div
round cvi /x1 ED /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def /w x2 x1 sub
0 gt { 1 } { -1 } ifelse def b 0 gt { /z1 b 4 div CLW 2 div add def
/Helvetica findfont b scalefont setfont /b b .95 mul CLW 2 div add def }
if systemdict /setstrokeadjust known { true setstrokeadjust /t { } def }
{ /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
exch itransform } bind def } ifelse gsave n 0 gt { 1 setlinecap [ 0 dy n
div ] dy n div 2 div setdash } { 2 setlinecap } ifelse /i x1 def /f y1
dy mul n 0 gt { dy n div 2 div h mul sub } if def /g y2 dy mul n 0 gt {
dy n div 2 div h mul add } if def x2 x1 sub w mul 1 add dup 1000 gt {
pop 1000 } if { i dx mul dup y0 moveto b 0 gt { gsave c i a cvs dup
stringwidth pop /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse h 0 gt {b neg}
{z1} ifelse rmoveto show grestore } if dup t f moveto g t L stroke /i i
w add def } repeat grestore gsave n 0 gt
% DG/SR modification begin - Nov. 7, 1997 - Patch 1
%{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
{ 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
% DG/SR modification end
{ 2 setlinecap } ifelse /i y1 def /f x1 dx mul
n 0 gt { dx n div 2 div w mul sub } if def /g x2 dx mul n 0 gt { dx n
div 2 div w mul add } if def y2 y1 sub h mul 1 add dup 1000 gt { pop
1000 } if { newpath i dy mul dup x0 exch moveto b 0 gt { gsave c i a cvs
dup stringwidth pop /z2 ED w 0 gt {z1 z2 add neg} {z1} ifelse h 0 gt
{z1} {b neg} ifelse rmoveto show grestore } if dup f exch t moveto g
exch t L stroke /i i h add def } repeat grestore } def
/ArcArrow { /d ED /b ED /a ED gsave newpath 0 -1000 moveto clip newpath 0
1 0 0 b grestore c mul /e ED pop pop pop r a e d PtoC y add exch x add
exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
mul neg d } def
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
/RotBegin { tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 }
def } if /TMatrix [ TMatrix CM ] cvx def /a ED a Rot /RAngle [ RAngle
dup a add ] cvx def } def
/RotEnd { /TMatrix [ TMatrix setmatrix ] cvx def /RAngle [ RAngle pop ]
cvx def } def
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
/Uput { /a ED add 2 div /h ED 2 div /w ED /s a sin def /c a cos def /b s
abs c abs 2 copy gt dup /q ED { pop } { exch pop } ifelse def /w1 c b
div w mul def /h1 s b div h mul def q { w1 abs w sub dup c mul abs } {
h1 abs h sub dup s mul abs } ifelse } def
/UUput { /z ED abs /y ED /x ED q { x s div c mul abs y gt } { x c div s
mul abs y gt } ifelse { x x mul y y mul sub z z mul add sqrt z add } { q
{ x s div } { x c div } ifelse abs } ifelse a PtoC h1 add exch w1 add
exch } def
/BeginOL { dup (all) eq exch TheOL eq or { IfVisible not { Visible
/IfVisible true def } if } { IfVisible { Invisible /IfVisible false def
} if } ifelse } def
/InitOL { /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
/Visible { CP OLUnit idtransform T moveto } def /Invisible { CP OLUnit
neg exch neg exch idtransform T moveto } def /BOL { BeginOL } def
/IfVisible true def } def
end
%    \end{macrocode}
% \subsubsection{Former pst-node.pro (adapted)}
%    \begin{macrocode}
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin /T /translate load def end
/NewNode { gsave /next ED dict dup 3 1 roll def exch { dup 3 1 roll def }
if begin tx@Dict begin STV CP T exec end /NodeMtrx CM def next end
grestore } def
/InitPnode { /Y ED /X ED /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
/InitCnode { /r ED /Y ED /X ED /NodePos { NodeSep r add dup Cos mul exch
Sin mul } def } def
/GetRnodePos { Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def
} ifelse Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def }
ifelse dx Sin mul abs dy Cos mul abs gt { dy Cos mul Sin div dy } { dx
dup Sin mul Cos Div } ifelse } def
/InitRnode { /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub
/u ED /NodePos { GetRnodePos } def } def
/DiaNodePos { w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
Cos mul exch Sin mul } def
/TriNodePos { Sin s lt { d NodeSep sub dup Cos mul Sin Div exch } { w h
mul w Sin mul h Cos abs mul add Div NodeSep add dup Cos mul exch Sin mul
} ifelse } def
/InitTriNode { sub 2 div exch 2 div exch 2 copy T 2 copy 4 index index /d
ED pop pop pop pop -90 mul rotate /NodeMtrx CM def /X 0 def /Y 0 def d
sub abs neg /d ED d add /h ED 2 div h mul h d sub Div /w ED /s d w Atan
sin def /NodePos { TriNodePos } def } def
/OvalNodePos { /ww w NodeSep add def /hh h NodeSep add def Sin ww mul Cos
hh mul Atan dup cos ww mul exch sin hh mul } def
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
/XYPos { dup sin exch cos Do /Cos ED /Sin ED /Dist ED Cos 0 gt { Dist
Dist Sin mul Cos div } { Cos 0 lt { Dist neg Dist Sin mul Cos div neg }
{ 0 Dist Sin mul } ifelse } ifelse Do } def
/GetEdge {
  dup 0 eq {
    pop
    begin 1 0 NodeMtrx dtransform CM idtransform
    exch atan sub dup sin
    /Sin ED
    cos /Cos ED
    /NodeSep ED
    NodePos NodeMtrx dtransform CM idtransform
    end
  }{
    1 eq {{exch}} {{}} ifelse
    /Do ED pop XYPos } ifelse
} def
/AddOffset { 1 index 0 eq { pop pop } { 2 copy 5 2 roll cos mul add 4 1
roll sin mul sub exch } ifelse } def
/GetEdgeA {
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge OffsetA AngleA AddOffset
  yA add /yA1 ED
  xA add /xA1 ED
} def
/GetEdgeB {
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge OffsetB AngleB AddOffset
  yB add /yB1 ED
  xB add /xB1 ED
} def
/GetArmA {
  ArmTypeA 0 eq {
    /xA2 ArmA AngleA cos mul xA1 add def
    /yA2 ArmA AngleA sin mul yA1 add def
  }{
    ArmTypeA 1 eq {{exch}} {{}} ifelse
    /Do ED
    ArmA AngleA XYPos OffsetA AngleA AddOffset yA add
    /yA2 ED xA add
    /xA2 ED
  } ifelse
} def
/GetArmB { ArmTypeB 0 eq { /xB2 ArmB AngleB cos mul xB1 add def /yB2 ArmB
AngleB sin mul yB1 add def } { ArmTypeB 1 eq {{exch}} {{}} ifelse /Do ED
ArmB AngleB XYPos OffsetB AngleB AddOffset yB add /yB2 ED xB add /xB2 ED
} ifelse } def
/InitNC { /b ED /a ED /NodeSepTypeB ED /NodeSepTypeA ED /NodeSepB ED
/NodeSepA ED /OffsetB ED /OffsetA ED tx@NodeDict a known tx@NodeDict b
known and dup { /NodeA a load def /NodeB b load def NodeA GetCenter /yA
ED /xA ED NodeB GetCenter /yB ED /xB ED } if } def
/LPutLine { 4 copy 3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 1 t sub
mul 3 1 roll 1 t sub mul 4 1 roll t mul add /Y ED t mul add /X ED } def
/LPutLines { mark LPutVar counttomark 2 div 1 sub /n ED t floor dup n gt
{ pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse cvi 2 mul { pop
} repeat LPutLine cleartomark } def
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { % hv 2004-11-28
  NCCoor
  tx@Dict begin
  ArrowA CP 4 2 roll ArrowB
%  IfArrowInside {
    4 copy
    /y2 ED /x2 ED /y1 ED /x1 ED
    x1 y1
    ArrowInsidePos 1 gt {
      /Alpha y2 y1 sub x2 x1 sub atan def
      /ArrowPos ArrowInsideOffset def
      /Length x2 x1 sub y2 y1 sub Pyth def
      /dArrowPos ArrowInsidePos abs def
      {%
        /ArrowPos ArrowPos dArrowPos add def
        ArrowPos Length gt { exit } if
        x1 Alpha cos ArrowPos mul add
        y1 Alpha sin ArrowPos mul add
        ArrowInside
        pop pop
      } loop
    }{%
      /ArrowPos ArrowInsideOffset def
      /dArrowPos ArrowInsideNo 1 gt {%
        1.0 ArrowInsideNo 1.0 add div
      }{ ArrowInsidePos } ifelse def
        ArrowInsideNo cvi {
        /ArrowPos ArrowPos dArrowPos add def
        x2 x1 sub ArrowPos mul x1 add
        y2 y1 sub ArrowPos mul y1 add
        ArrowInside
        pop pop
      } repeat
    } ifelse
    pop pop %} if
  lineto pop pop
  end
} def
%
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
%
/NCCurve {
  GetEdgeA GetEdgeB
  xA1 xB1 sub yA1 yB1 sub
  Pyth 2 div dup 3 -1 roll mul
  /ArmA ED
  mul
  /ArmB ED
  /ArmTypeA 0 def
  /ArmTypeB 0 def
  GetArmA GetArmB
  xA2 yA2 xA1 yA1
  2 copy
  /y0 ED /x0 ED
  tx@Dict begin ArrowA end
  xB2 yB2 xB1 yB1
  tx@Dict begin ArrowB end
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED
  /cx x1 x0 sub 3 mul def
  /cy y1 y0 sub 3 mul def
  /bx x2 x1 sub 3 mul cx sub def
  /by y2 y1 sub 3 mul cy sub def
  /ax x3 x0 sub cx sub bx sub def
  /ay y3 y0 sub cy sub by sub def
  /getValues {
    ax t0 3 exp mul bx t0 t0 mul mul add cx t0 mul add x0 add
    ay t0 3 exp mul by t0 t0 mul mul add cy t0 mul add y0 add
    ax t 3 exp mul bx t t mul mul add cx t mul add x0 add
    ay t 3 exp mul by t t mul mul add cy t mul add y0 add
  } def
  /getdL {
    getValues
    3 -1 roll sub 3 1 roll sub Pyth
  } def
  /CurveLength {
    /u 0 def
    /du 0.01 def
    0 100 {
      /t0 u def
      /u u du add def
      /t u def
      getdL add
    } repeat } def
   /GetArrowPos {
     /ende ArrowInsidePos 1 gt { ArrowPos }{ ArrowPos CurveLength mul } ifelse def
     /u 0 def
     /du 0.01 def
     /sum 0 def
     { /t0 u def
       /u u du add def
       /t u def
       /sum getdL sum add def
       sum ende gt {exit} if
     } loop u
  } def
  /dArrowPos ArrowInsideNo 1 gt {%
    1.0 ArrowInsideNo 1.0 add div
  }{ ArrowInsidePos } ifelse def
  /ArrowPos ArrowInsideOffset def
  /loopNo ArrowInsidePos 1 gt {%
    CurveLength ArrowInsidePos div cvi
  }{ ArrowInsideNo } ifelse def
  loopNo cvi {
    /ArrowPos ArrowPos dArrowPos add def
    /t GetArrowPos def
    /t0 t 0.95 mul def
    getValues
    ArrowInside pop pop pop pop
  } repeat
  x1 y1 x2 y2 x3 y3 curveto
  /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ] cvx def
  /LPutPos { t LPutVar BezierMidpoint } def
  /HPutPos { { HPutLines } HPutCurve } def
  /VPutPos { { VPutLines } HPutCurve } def
} def
%
/NCAngles {
  GetEdgeA GetEdgeB GetArmA GetArmB
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx transform pop
  xB2 yB2 mtrx transform exch pop
  mtrx itransform
  /y0 ED /x0 ED mark
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 x0 y0 xA2 yA2 ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
} def
/NCAngle { GetEdgeA GetEdgeB GetArmB /mtrx AngleA matrix rotate def xB2
yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
/y0 ED /x0 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2 x0 y0 xA1 yA1
tx@Dict begin false Line end /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
/NCBar {
  GetEdgeA GetEdgeB GetArmA GetArmB
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop xB2 yB2 mtrx itransform pop sub dup 0
  mtrx transform
  3 -1 roll 0 gt {
    /yB2 exch yB2 add def
    /xB2 exch xB2 add def
  }{
    /yA2 exch neg yA2 add def
    /xA2 exch neg xA2 add def } ifelse
  mark ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
} def
/NCBarr { % hv
  GetEdgeA GetEdgeB GetArmA GetArmB
  /mtrx AngleA matrix rotate def
  /yMid yB2 yA2 sub tpos mul yA2 add def
  mark ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xB2 yMid xA2 yMid xA2 yA2 ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xB2 yMid xA2 yMid xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
} def
/NCDiag { %hv
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2
  xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
} def
/NCDiagg { % hv
  GetEdgeA GetArmA lineAngle abs 0 gt { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
} def
/NCLoop { GetEdgeA GetEdgeB GetArmA GetArmB /mtrx AngleA matrix rotate
def xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED /xB3 xB2 yB2
mtrx transform pop def xB3 yA3 mtrx itransform /yB3 ED /xB3 ED xA3 yA3
mtrx itransform /yA3 ED /xA3 ED mark ArmB 0 ne { xB1 yB1 } if xB2 yB2
xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if tx@Dict begin false
Line end /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ]
cvx def /LPutPos { LPutLines } def /HPutPos { HPutLines } def /VPutPos {
VPutLines } def } def
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
/NCCircle { NodeSepA 0 NodeA 0 GetEdge pop 2 div dup 2 exp r
r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
mul add dup 5 1 roll 90 sub PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
% DG/SR modification end
} def /HPutPos { LPutPos } def /VPutPos { LPutPos } def r AngleA 90 sub a add
AngleA 270 add a sub tx@Dict begin /angleB ED /angleA ED /r ED /c 57.2957 r
Div def /y ED /x ED } def
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
/LPutCoor { NAngle tx@Dict begin /NAngle ED end gsave CM STV CP Y sub neg
exch X sub neg exch moveto setmatrix CP grestore } def
/LPut { tx@NodeDict /LPutPos known { LPutPos } { CP /Y ED /X ED /NAngle 0
def } ifelse LPutCoor  } def
/HPutAdjust { Sin Cos mul 0 eq { 0 } { d Cos mul Sin div flag not { neg }
if h Cos mul Sin div flag { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { r add neg } { l add } ifelse X add /X ED }
def
/VPutAdjust { Sin Cos mul 0 eq { 0 } { l Sin mul Cos div flag { neg } if
r Sin mul Cos div flag not { neg } if 2 copy gt { pop } { exch pop }
ifelse } ifelse s add flag { d add } { h add neg } ifelse Y add /Y ED }
def
end
%    \end{macrocode}
% \subsubsection{pst-plot stuff (adapted from pst-math and psteqdf)}
%    \begin{macrocode}

/PI 3.14159265359 def
/ENeperian 2.71828182846 def

/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def

/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def

/EXP {ENeperian exch exp} bind def

/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def

/SINC {dup SIN exch Div} bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def

/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def

/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def

/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def

/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul}
    ifelse} bind def

/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul}
    ifelse} bind def

/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul}
    ifelse} bind def

/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul}
    ifelse} bind def

%% In progress...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%    \end{macrocode}
% Here begins the part that Dominique Rodriguez wrote. Basically, it is
% a lexical analyser that converts an infix expression to a Reverse Polish Notation (RPN)
% expression, compatible with the PostScript syntax.
%    \begin{macrocode}
/tx@EqdfDict 400 dict def tx@EqdfDict begin

/Pi 3.14159265359 def
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.11
% E->T|E+T
% T->FS|T*FS                                  %%% NEW 2004/11/14
% FS -> F | +SF | -SF                         %%% NEW 2004/11/14
% F->P|F^P                                    %%% OLD
% F->P|F^SF                                   %%% NEW 2004/11/14  ???? ^FS
% P->(E)|literal
% literal->number|var|var[E]|func(params)%%|-P|+P%%% OLD
% params->E|E,param
%
% E expression, T term, SF signed factor, F factor, P power
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% parser
%% str -> [ LIFO vector ]
/AlgParser {
  InitParser
  SetExpr
  LexStr
  0 exch AnalyzeListOfE
  ExpressionVector
  /ExpressionVector [] def
  } def

/InitParser {
  /AddVector [] def
  /AddVectorfree [] def
  /MulVector [] def
  /MulVectorfree [] def
  /PowVector [] def
  /PowVectorfree [] def
  /OpParVector [] def
  /ClParVector [] def
  /ParVectorFree [] def
  /BraVector [] def
  /SemVector [] def
  /ComVector [] def
  /ExpressionVector [] def
  } def
%    \end{macrocode}
% \verb|/SetExpr| takes one parameter (the Expression String) and stores it in
% \verb|ExpressionString|.
%    \begin{macrocode}
/SetExpr {
  /ExpressionString exch def
  } def
%    \end{macrocode}
% Lexical analysis of the string stored in \verb|ExpressionString|.
%    \begin{macrocode}
/LexStr {
  /freepar 0 def
  /lastpar 0 def
  /lastchar 0 def
  0 ExpressionString
%    \end{macrocode}
% Here, we start a loop on every characters that belongs to the string \verb|ExpressionString|.
% The lexical analysis begins with the last character.
%    \begin{macrocode}
  {
%    \end{macrocode}
% Tests if current char is an opening parenthesis (ASCII code: 40),
%    \begin{macrocode}
    dup 40 eq
%    \end{macrocode}
% or an opening bracket (ASCII code: 91).
%    \begin{macrocode}
    1 index 91 eq
    or {
      /OpParVector OpParVector aload length dup 3 add index exch 1 add array astore def
      /ClParVector ClParVector aload length -1 exch 1 add array astore def
      /lastpar freepar def
      /freepar freepar 1 add def
      /NoPar false def
      } if
%    \end{macrocode}
% Tests if current char is an closing parenthesis (ASCII code: 41),
%    \begin{macrocode}
    dup 41 eq
%    \end{macrocode}
% or an closing bracket (ASCII code: 93).
%    \begin{macrocode}
    1 index 93 eq
    or {
      ClParVector lastpar 3 index put lastpar
      dup 0 eq {
        pop
        }{
          { 1 sub dup ClParVector exch get -1 eq {
            /lastpar exch def exit
            }{
            dup 0 eq {
              pop exit
              } if
            } ifelse
          } loop
        } ifelse
      } if
%    \end{macrocode}
% Tests if current char is a star (ASCII code: 42) that stands for the multiplication operator.
%    \begin{macrocode}
      dup 42
      eq  {
        /MulVector 2 index MulVector aload length 1 add array astore def
      } if
%    \end{macrocode}
% Tests if current char is a plus (ASCII code: 43) that stands for the addition operator.
%    \begin{macrocode}
      dup 43
      eq {
%    \end{macrocode}
% We need to test if it is really an add operator or only an unary operator.
%    \begin{macrocode}
        lastchar dup  40 ne      %% open parenthesis
            1 index  59 ne and  %% ;
            1 index  42 ne and  %% *
            1 index  43 ne and  %% +
            1 index  44 ne and  %% ,
            1 index  45 ne and  %% -
            1 index  47 ne and  %% /
            1 index   0 ne and  %% first char
            1 index  94 ne and  %% ^%%2004/11/14
                exch 124 ne and  %% |
        {/AddVector 2 index AddVector aload length 1 add array astore def } if}
      if
      dup 44 eq %% , separator
      { /ComVector ComVector aload length dup 3 add index exch 1 add array astore def }
      if
      dup 45 eq %% - operator
      { %%test if it is a real operator and not the unary operator
        lastchar dup  40 ne      %% open parenthesis
            1 index  59 ne and  %% ;
            1 index  42 ne and  %% *
            1 index  43 ne and  %% +
            1 index  44 ne and  %% ,
            1 index  45 ne and  %% -
            1 index  47 ne and  %% /
            1 index   0 ne and  %% first char
            1 index  94 ne and  %% ^%%2004/11/14
                exch 124 ne and  %% |
         {/AddVector 2 index neg AddVector aload length 1 add array astore def } if}
      if
      dup 47 eq %% / operator
      { /MulVector 2 index neg MulVector aload length 1 add array astore def }
      if
      dup 59 eq 1 index 124 eq or%% ; separator |
      { /SemVector SemVector aload length dup 3 add index exch 1 add array astore def }
      if
      dup 91 eq %% open bracket
      { /BraVector BraVector aload length dup 3 add index exch 1 add array astore def }
      if
      dup 94 eq %% ^ operator
      { /PowVector 2 index PowVector aload length 1 add array astore def }%%2004/11/14
      if
      /lastchar exch def 1 add
    } forall
  /AddVectorFree AddVector CreateFree def
  /MulVectorFree MulVector CreateFree def
  /ParVectorFree OpParVector CreateFree def
  /PowVectorFree PowVector CreateFree def
  /ComVectorFree ComVector CreateFree def
  1 sub
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Create Free vector
%% ->
/CreateFree {
  dup length array exch
  { pop true exch } forall astore
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree parenthesis
%% pos ->
/UnfreePar {
  /pos exch def ParVectorFree 0
  OpParVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree mul
%% pos ->
/UnfreeMul {
  MulVectorFree 0
  MulVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree add
%% pos ->
/UnfreeAdd {
  AddVectorFree 0
  AddVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree exp
%% pos ->
/UnfreePow {
  PowVectorFree 0
  PowVector { pos eq { exit } if 1 add } forall
  false put
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Unfree com
%% pos ->
/UnfreeCom {
  ComVectorFree 0
  ComVector { pos eq { exit } if 1 add } forall
  false put
} def

/FLbreak { tst not {/L exch def /F exch def 2 copy L eq exch F eq and /tst exch def} {pop pop}ifelse} def
/Negbreak { tst not { dup 0 lt /tst exch def } if } def
/STOP { tst {TOUF} if} def
/tst false def

%% analyze Expression List
%% first last
/AnalyzeListOfE {
  exch SemVector {
    exch 1 index 1 sub AnalyzeExpr 1 add
  } forall%%last_char
  exch AnalyzeExpr
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Expr
%% first last
/AnalyzeExpr {
  FindFirstAdd%% first last pos+
  2 copy abs 1 sub ne
  { 3 -1 roll 1 index abs 1 sub AnalyzeExpr dup abs 1 add 3 -1 roll  AnalyzeTerm EvalAdd }
  { pop AnalyzeTerm } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Term
%% first last
/AnalyzeTerm {%%19 28 FLbreak STOP
  FindFirstMul%% first last pos*
  2 copy abs 1 sub ne
  { 3 -1 roll 1 index abs 1 sub AnalyzeTerm dup abs 1 add 3 -1 roll  AnalyzeSignedFactor EvalMul }%%% NEW 2004/11/14
  { pop AnalyzeSignedFactor } ifelse%%% NEW 2004/11/14
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% NEW 2004/11/14
%% analyze Signed Factor
%% first last ->
/AnalyzeSignedFactor {
  ExpressionString 2 index get
  dup 45 eq%% a - sign
  { pop exch 1 add exch AnalyzeSignedFactor EvalNeg }
  { 43 eq%%a + sign
    { exch 1 add exch AnalyzeSignedFactor }
    { AnalyzeFactor } ifelse } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Factor
%% first last ->
/AnalyzeFactor {
  FindFirstPow%% first last pos*
  2 copy abs 1 sub ne
%  { 3 -1 roll 1 index abs 1 sub AnalyzeFactor dup abs 1 add 3 -1 roll  AnalyzePower EvalPow }
  { 3 -1 roll 1 index abs 1 sub AnalyzeFactor dup abs 1 add 3 -1 roll  AnalyzeSignedFactor EvalPow }% NEW 2004/11/14
  { pop AnalyzePower } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze Power
%% first last ->
/compteur 0 def
/AnalyzePower {
  ExpressionString 2 index get
  dup 40 eq%% an open parenthesis
  { pop 1 index UnfreePar 1 sub exch 1 add exch AnalyzeExpr }
  {  dup 45 eq%% a - sign
    { pop exch 1 add exch AnalyzePower EvalNeg }
    { dup 43 eq%%a + sign
      { pop exch 1 add exch AnalyzePower }
      { dup 46 eq 1 index 48 ge 2 index 57 le and or%%a digit or a dot
        { pop AnalyzeNumber }
        { pop AnalyzeLiteral } ifelse } ifelse } ifelse } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% analyze parameters list
%% first last
/AnalyzeParam {
  { FindFirstCom%% first last pos,
    3 -1 roll 1 index 1 sub AnalyzeExpr
    2 copy 1 sub ne { 1 add exch } { pop pop exit } ifelse
  } loop
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual addition at this level
%% first last -> position
/FindFirstAdd {
  2 copy /Last exch def /First exch def false 0
  AddVector {
    AddVectorFree 2 index get
    { /pos exch def
      true 0 1 ClParVector length 1 sub
      { ParVectorFree 1 index get
        { OpParVector 1 index get pos abs le
          ClParVector 2 index get pos abs ge and
    pos abs First lt pos abs Last gt or or
          { pop pop false exit } if
        } if
        pop
      } for
      { pop pop true dup exit } if
    }
    { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreeAdd}%% find one add
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual multiplication at this level
%% first last -> first last position
/FindFirstMul {
  2 copy /Last exch def /First exch def false 0
  MulVector {
    MulVectorFree 2 index get
    { /pos exch def
      %% if it is in the current part of the analysed expr
      pos abs First gt pos abs Last lt and
      { true 0 1 ClParVector length
        dup 0 eq%% no parenthesis
        { pop pop pop pop exch not exch exit }
        { 1 sub
          { ParVectorFree 1 index get
            { OpParVector 1 index get pos abs lt%% in this parenthesis level
              ClParVector 2 index get pos abs gt and
              { pop pop false exit } if%%then exit loop
            } if
            pop } for
          { pop pop true dup exit } if } ifelse } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreeMul} %% find one mul
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual power at this level
%% first last -> first last position
/FindFirstPow {
  2 copy /Last exch def /First exch def false 0
  PowVector {
    PowVectorFree 2 index get
    { /pos exch def
      %% if it is in the current part of the analysed expr
      pos First gt pos Last lt and
      { true 0 1 ClParVector length
        dup 0 eq%% no parenthesis
        { pop pop pop pop exch not exch exit }
        { 1 sub
          { ParVectorFree 1 index get
            { OpParVector 1 index get pos abs lt%% in this parenthesis level
              ClParVector 2 index get pos abs gt and
              { pop pop false exit } if%%then exit loop
            } if
            pop } for
          { pop pop true dup exit } if } ifelse } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreePow} %% find one ^
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual comma at this level
%% first last -> first last position
/FindFirstCom {
  2 copy /Last exch def /First exch def false 0
  ComVector {
    ComVectorFree 2 index get
    { /pos exch def
      %% if it is in the current part of the analysed expr
      pos First gt pos Last lt and
      { true 0 1 ClParVector length
        dup 0 eq%% no parenthesisSTOP
        { pop pop pop pop exch not exch exit }
        { 1 sub
          { ParVectorFree 1 index get
            { OpParVector 1 index get pos abs lt%% in this parenthesis level
              ClParVector 2 index get pos abs gt and
              { pop pop false exit } if%%then exit loop
            } if
            pop } for
          { pop pop true dup exit } if } ifelse } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos UnfreeCom} %% find one mul
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the eventual addition at this level
%% first last -> first last position
/FindFirstPar {
  2 copy /Last exch def /First exch def false 0
  OpParVector {
    ParVectorFree 2 index get
    { /pos exch def
      pos First gt pos Last lt and
      { exch not exch exit } if
    } { pop } ifelse
    1 add
  } forall
  pop
  { pos dup UnfreePar }%% find one mul
  { Last 1 add } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Find the first opening bracket
%% first last -> first last position
/FindFirstBra {
  2 copy /Last exch def /First exch def
  BraVector {
    /pos exch def
    pos First gt pos Last lt and
    { exit } if
  } forall
  pos dup UnfreePar%% finding it is mandatory
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Read the number and push it in the vector
%% first last ->
/AnalyzeNumber {
  1 index sub 1 add ExpressionString 3 1 roll getinterval cvr /n exch def
  /ExpressionVector ExpressionVector aload length n exch 1 add array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Read the literal and push it in the vector
%% first last ->
/AnalyzeLiteral {
  ExpressionString 1 index get dup 41 eq%%close par at the end => function call
  { pop FindFirstPar%%first last parpos
    ExpressionString 3 index dup 3 index exch sub getinterval
    dup (SUM) eq
    { 1 index 1 add 3 index 1 sub FindFirstCom%%
      3 -1 roll 1 index 1 sub AnalyzeExpr  toto }
    { 1 index 1 add 3 index 1 sub AnalyzeParam
      dup cvn /n exch def TrigoFunc
      /ExpressionVector ExpressionVector aload length
      /tx@EqdfDict cvx /begin cvx n cvx /end cvx 5 -1 roll 4 add array astore def
      %%n cvx exch 1 add array astore def
      pop pop pop } ifelse
  }
  { 93 eq%%close bracket => vector element
    { FindFirstBra%%first last brapos
      ExpressionString 3 index dup 3 index exch sub getinterval cvn /n exch def
      /ExpressionVector ExpressionVector aload length n cvx exch 1 add array astore def
      2 copy 1 add exch 1 sub AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def
      pop pop pop
    }
    { 1 index sub 1 add ExpressionString 3 1 roll getinterval cvn /n exch def
     /ExpressionVector ExpressionVector aload length n cvx exch 1 add array astore def } ifelse } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push add in the vector
%% kind ->
%% if kind>0 then add else sub
/EvalAdd {
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll
  0 gt { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push mul in the vector
%% ->
/EvalMul {
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll
  0 gt { /mul } { /div } ifelse cvx exch 1 add  array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push exp in the vector
%% ->
/EvalPow {
  pop /ExpressionVector ExpressionVector aload length
  /exp cvx exch 1 add array astore def
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% push neg in the vector
%% ->
/EvalNeg {
  /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def
} def

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.14159265359 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% METHODS FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PI     3.14155265359 def
/PIdiv2 1.57079632680 def
%% Make a discrete sum
%% n begin end expr ->
/SUM {} def
%% function arcsine in radians
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup abs 1 eq
  { PIdiv2 exch -1 eq { neg } if }
  { .1 %% asin(x)
    { dup dup PI div 180 mul sin 3 index sub exch PI div 180 mul cos div
      dup abs 1e-6 lt { sub exit } if sub
    } loop
    exch pop } ifelse
} def
%% function arccosine in radians
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup abs 1 eq
  { -1 eq { PI } { 0 } ifelse }
  { 1.5 %% asin(x)
    { dup dup PI div 180 mul cos 3 index sub exch PI div 180 mul sin neg div
      dup abs 1e-6 lt { sub exit } if sub
    } loop
    exch pop } ifelse
} def
/fact { 1 exch 2 exch 1 exch { mul } for } def
end
%</dvips>
%    \end{macrocode}
% \Finale
\endinput
